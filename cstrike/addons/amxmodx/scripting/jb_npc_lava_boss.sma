/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <fakemeta>
#include <cstrike>
#include <jailbreak_core>
#include <hamsandwich>
#include <xs>
#include <engine>
#include <fun>
#include <npc_library>

#if AMXX_VERSION_NUM <= 182
#include <dhudmessage>
#endif

enum any:VALUABLES_TYPES(+=1)
{
    VALUABLE_MONEY_STACK = 0,
    VALUABLE_BRIEF_CASE,
    VALUABLE_GOLD_INGOT,
    VALUABLE_GOLD_INGOTS
}

native jb_drop_valuable(const Float:fLocation[3], VALUABLES_TYPES:iValuableType, const iAmount = 1, const iOwner = 0)

#define PLUGIN "[JB] REVENANT Boss"
#define AUTHOR "Natsheh"

#if AMXX_VERSION_NUM > 182
#define client_disconnect client_disconnected
#endif

#define NPC_CUSTOM_CLASSNAME "npc_revenant_boss"
#define NPC_REVENANT_MONSTER_ID 300

#define MONSTER_MOUTH_ATTACHMENT 2
#define MONSTER_L_HAND_ATTACHMENT 0
#define MONSTER_R_HAND_ATTACHMENT 1

new const NPC_DEATH_SOUNDS[][] = {
    "garg/gar_die2.wav"
}

new const NPC_STEP_SOUNDS[][] = {
    "garg/gar_step1.wav",
    "garg/gar_step2.wav"
}

new const NPC_CLAWS_MISS_SOUNDS[][] = {
    "zombie/claw_miss1.wav",
    "zombie/claw_miss2.wav"
}

new const NPC_CLAWS_STRIKE_SOUNDS[][] = {
    "zombie/claw_strike1.wav",
    "zombie/claw_strike2.wav",
    "zombie/claw_strike3.wav"
}

new const g_szSND_FireBoltExplosion[] = "weapons/hegrenade-1.wav";

new NPC_BOSS_MODEL[64] = "models/jailbreak/npc_revenant_boss.mdl";

enum CVAR_DATA
{
    CVAR_NAME[32],
    CVAR_VALUE[16]
}

new const g_szCvars[][CVAR_DATA] =
{
    { "jb_firedesk_damage", "80" },
    { "jb_firedesk_radius", "500" },
    { "jb_firedesk_life", "2" },
    { "jb_firebolts_damage", "80" },
    { "jb_firebolts_force", "800" },
    { "jb_flame_damage", "5" },
    { "jb_dash_damage", "50" },
    { "jb_dash_force", "2500" },
    { "jb_monster_speed", "300" },
    { "jb_monster_jspeed", "500" },
    { "jb_monster_melee_dist", "200" },
    { "jb_monster_melee_damage", "250" }
}

enum any:CVARS_MAX
{
    CVAR_FIREDESK_DMG,
    CVAR_FIREDESK_RADIUS,
    CVAR_FIREDESK_LIFE,
    CVAR_FIREBOLTS_DMG,
    CVAR_FIREBOLTS_FORCE,
    CVAR_FLAME_DMG,
    CVAR_DASH_DMG,
    CVAR_DASH_FORCE,
    CVAR_MONSTER_SPEED,
    CVAR_MONSTER_JSPEED,
    CVAR_MONSTER_MELEE_DISTANCE,
    CVAR_MONSTER_MELEE_DAMAGE
}

enum MONSTER_EVENTS (+=1)
{
    EVENT_MELEEATTACK = 1,
    EVENT_DASH_ATTACK = 5,
    EVENT_CREATE_FIRE_BOLTS = 10,
    EVENT_SHOOT_FIRE_BOLTS,
    EVENT_INITIATE_LAVA_SPHERE,
    EVENT_INITIATE_LAVA_ASTEROIDS,
    EVENT_INITIATE_LAVA_DISK,
    EVENT_INITIATE_LAVA_SPRAY,
    EVENT_INITIATE_DASH_RUN = 20,
    EVENT_FOOT_STEP = 5008
}

enum (+=1)
{
    NPC_PENTAGRAM_SPAWN = 7000,
    NPC_REVENANT_PENTAGRAM_SPAWN,
    NPC_FADING_IN
}

new const CLASS_FIRE_FLAME[] = "Flame";
new const CLASS_FIRE_DESK[] = "FireDesk";
new const CLASS_FIRE_BOLTS[] = "FireBolts";
new const CLASS_FIRE_BREATH[] = "FireBreath";
new const CLASS_DASH_ATTACK[] = "DashAttack";
new const CLASS_PENTAGRAM[] = "Pentagram";

new const g_szSPRITE_FIRE[] = "sprites/fire3.spr";
new const g_szSPRITE_FIRE_BALL[] = "sprites/sphere_csnz_exp.spr";

new const g_szPentagramMDL[] = "models/jailbreak/pentagram.mdl";

new const Float:g_fNPCViewOFS[3] = { 0.0, 0.0, 160.0 };
new const Float:g_fMAX_SIZE[3] = { 64.0, 64.0, 164.0 };
new const Float:g_fMIN_SIZE[3] = { -64.0, -64.0, 0.0 };

new spr_blood_drop, spr_blood_spray, g_iCvars[CVARS_MAX],
    g_sprite_smoke, g_sprite_flame_breath, g_sprite_shockwave,
    Trie:g_trie_NPC_EVENTS = Invalid_Trie, Float:g_fTotalDamage, Float:g_fPrevDamageTime;

public plugin_precache()
{
    PRECACHE_SOUND(g_szSND_FireBoltExplosion);

    for(new i; i < sizeof NPC_DEATH_SOUNDS; i++)
    {
        PRECACHE_SOUND(NPC_DEATH_SOUNDS[i]);
    }

    for(new i; i < sizeof NPC_STEP_SOUNDS; i++)
    {
        PRECACHE_SOUND(NPC_STEP_SOUNDS[i]);
    }

    for(new i; i < sizeof NPC_CLAWS_STRIKE_SOUNDS; i++)
    {
        PRECACHE_SOUND(NPC_CLAWS_STRIKE_SOUNDS[i]);
    }

    for(new i; i < sizeof NPC_CLAWS_MISS_SOUNDS; i++)
    {
        PRECACHE_SOUND(NPC_CLAWS_MISS_SOUNDS[i]);
    }

    precache_model(g_szSPRITE_FIRE_BALL);
    g_sprite_shockwave = precache_model("sprites/shockwave.spr");
    g_sprite_smoke = precache_model("sprites/gas_puff_01.spr");
    precache_model(g_szSPRITE_FIRE);
    g_sprite_flame_breath = precache_model("sprites/explode1.spr");
    
    precache_model("sprites/b-tele1.spr");
    precache_sound("jailbreak/nc_teleport.wav");
    
    spr_blood_drop = precache_model("sprites/blood.spr");
    spr_blood_spray = precache_model("sprites/bloodspray.spr");

    jb_ini_get_keyvalue("REVENANT_BOSS", "BOSS_MODEL", NPC_BOSS_MODEL, charsmax(NPC_BOSS_MODEL));
    precache_model(NPC_BOSS_MODEL);

    PRECACHE_WORLD_ITEM(g_szPentagramMDL);
}

new Array:g_animArrays[NPC_ACTIVITY], g_sizeAnimArrays[NPC_ACTIVITY];

public plugin_end()
{
    NPC_FREE_HOOKS(NPC_CUSTOM_CLASSNAME);
    MDL_STUDIO_FREE_DATA(g_animArrays, g_sizeAnimArrays);
    MDL_STUDIO_DESTROY_HOOKS(engfunc(EngFunc_ModelIndex, NPC_BOSS_MODEL));

    TrieDestroy(g_trie_NPC_EVENTS);
}

public plugin_init()
{
    new iPluginID = register_plugin(PLUGIN, "1.0", AUTHOR);

    MDL_STUDIO_LOAD_ANIMATIONS(NPC_BOSS_MODEL, g_animArrays, g_sizeAnimArrays);
    MDL_STUDIO_HOOK_EVENT(engfunc(EngFunc_ModelIndex, NPC_BOSS_MODEL), "task_npc_event");

    register_think(CLASS_FIRE_FLAME, "Flame_think");
    register_think(CLASS_FIRE_DESK, "FireDesk_think");
    register_think(CLASS_FIRE_BOLTS, "FireBolts_think");
    register_think(CLASS_FIRE_BREATH, "FireBreath_think");
    register_think(CLASS_DASH_ATTACK, "DashAttack_Think");
    register_touch(CLASS_FIRE_BOLTS, "*", "FireBolts_touch");
    register_touch(CLASS_FIRE_BREATH, "*", "FireBreath_touch");
    register_touch(CLASS_FIRE_FLAME, "*", "Flame_touch");
    register_touch(CLASS_DASH_ATTACK, "*", "DashAttack_touch");

    register_think(NPC_CUSTOM_CLASSNAME, "npc_brain");
    NPC_Hook_Event(NPC_CUSTOM_CLASSNAME, NPC_EVENT_DEATH, "npc_killed", iPluginID);
    NPC_Hook_Event(NPC_CUSTOM_CLASSNAME, NPC_EVENT_TAKEDAMAGE, "npc_takedmg", iPluginID);
    NPC_Hook_Event(NPC_CUSTOM_CLASSNAME, NPC_EVENT_TRACEATTACK, "npc_traceattack", iPluginID);

    for(new i, maxloop = sizeof g_szCvars; i < maxloop; i++)
    {
        g_iCvars[i] = register_cvar(g_szCvars[i][CVAR_NAME], g_szCvars[i][CVAR_VALUE]);
    }

    new ent;
    while((ent=find_ent_by_class(ent, "trigger_multiple")))
    {
        set_pev(ent, pev_spawnflags, pev(ent, pev_spawnflags)|SF_TRIGGER_ALLOWMONSTERS);
        DispatchSpawn(ent);
    }

    while((ent=find_ent_by_class(ent, "trigger_hurt")))
    {
        set_pev(ent, pev_spawnflags, pev(ent, pev_spawnflags)|SF_TRIGGER_ALLOWMONSTERS);
        DispatchSpawn(ent);
    }

    while((ent=find_ent_by_class(ent, "trigger_teleport")))
    {
        set_pev(ent, pev_spawnflags, pev(ent, pev_spawnflags)|SF_TRIGGER_ALLOWMONSTERS);
        DispatchSpawn(ent);
    }

    register_clcmd("spawn_revenant_monster", "clcmd_spawn_revenant_monster", ADMIN_IMMUNITY);
    register_clcmd("say /krevenant", "kill_revenant_monsters", ADMIN_IMMUNITY);

    g_trie_NPC_EVENTS = TrieCreate();
}

public plugin_natives()
{
    register_native("npc_spawn_revenant_boss", "native_spawn_revenant_boss");
    register_native("npc_despawn_revenant_boss", "native_despawn_revenant_boss");
}

public native_despawn_revenant_boss(plugin, argc)
{
    new ent = -1;
    while( (ent=engfunc(EngFunc_FindEntityByString, ent, "classname", NPC_CUSTOM_CLASSNAME)) > 0 )
    {
        set_pev(ent, PEV_TASK, NPC_KILLSELF);
        dllfunc(DLLFunc_Think, ent);
    }
}

public native_spawn_revenant_boss(plugin, argc)
{
    new players[32], pnum, Float:fOrigin[3];
    get_players(players, pnum, "ah");

    if( pnum > 0 )
    {
        pev(players[random(pnum)], pev_origin, fOrigin);
        spawn_monster_nearby_origin(1, fOrigin, 500.0);
    }
    else
    {
        pev(find_ent_by_class(-1, "info_player_deathmatch"), pev_origin, fOrigin);
        spawn_monster_nearby_origin(1, fOrigin, 100.0);
    }
}

public kill_revenant_monsters(id, level, cid)
{
    if(level != 0 && !(get_user_flags(id) & level))
    {
        return 1;
    }

    new ent = -1;
    while( (ent=engfunc(EngFunc_FindEntityByString, ent, "classname", NPC_CUSTOM_CLASSNAME)) > 0 )
    {
        if(pev(ent, PEV_OWNER) == 0)
        {
            set_pev(ent, PEV_WEAPON_INFLICTOR, "THE FORCE");
            ExecuteHamB(Ham_Killed, ent, id, GIB_NORMAL);
        }
    }

    return 1;
}

public npc_killed(const id, const killer)
{
    new szClass[32];
    pev(id, PEV_WEAPON_INFLICTOR, szClass, charsmax(szClass));
    Initiate_NPC_DEATHMSG(id, killer, false, szClass);

    emit_sound(id, CHAN_AUTO, NPC_DEATH_SOUNDS[random(sizeof NPC_DEATH_SOUNDS)], VOL_NORM, ATTN_NORM, 0, PITCH_NORM);

    new iZASpecialDayIndex = jb_get_dayid_byname("Zombie Apocalypse");
    if(iZASpecialDayIndex != INVALID_HANDLE && iZASpecialDayIndex == jb_get_current_day())
    {
        new iChances[100];
        arrayset(iChances, 1, 35);
        SortIntegers(iChances, sizeof iChances, .order = Sort_Random);
        SortIntegers(iChances, sizeof iChances, .order = Sort_Random);
        SortIntegers(iChances, sizeof iChances, .order = Sort_Random);

        if( iChances[random(100)] == 1 )
        {
            new Float:fOrigin[3];
            pev(id, pev_origin, fOrigin);
            jb_drop_valuable(fOrigin, VALUABLE_GOLD_INGOT, .iOwner = id);
        }
    }
}

public npc_takedmg(id, inflictor, attacker, Float:damage, damagebits)
{
    static Float:fGameTime;
    fGameTime = get_gametime();
    g_fTotalDamage += damage;

    // Damage Per Second
    if( (fGameTime - g_fPrevDamageTime) <= 1.0 )
    {
        static Float:fMaxHealth;
        pev(id, pev_max_health, fMaxHealth);

        // Attackers did 10% damage in a second to the monster, execute specialattack!
        if( g_fTotalDamage >= (fMaxHealth * 0.1) )
        {
            static szKey[32];
            formatex(szKey, charsmax(szKey), "NPC_#%d_NEXT_SPECIAL_ATTACK", id);
            TrieSetCell(g_trie_NPC_EVENTS, szKey, 0.0);
            g_fTotalDamage = 0.0;
        }
    }

    if(id != inflictor && id != attacker && !pev(id, NPC_TARGET))
    {
        if(inflictor && entity_takedamage_type(inflictor) != DAMAGE_NO)
        {
            set_pev(id, NPC_TARGET, inflictor);
            set_pev(id, PEV_TASK, NPC_ATTACK);
            dllfunc(DLLFunc_Think, id);
        }
        else if(attacker && entity_takedamage_type(attacker) != DAMAGE_NO)
        {
            set_pev(id, NPC_TARGET, attacker);
            set_pev(id, PEV_TASK, NPC_ATTACK);
            dllfunc(DLLFunc_Think, id);
        }
    }

    g_fPrevDamageTime = fGameTime;
}

public npc_traceattack(id, attacker, Float:Damage, Float:fDirection[3], trace_handle, damagebits)
{
    if(damagebits & (DMG_SLASH|DMG_BULLET|DMG_CRUSH|DMG_BLAST|DMG_ENERGYBEAM))
    {
        fDirection[0] *= Damage;
        fDirection[1] *= Damage;
        fDirection[2] *= Damage;

        static Float:fHit[3];
        get_tr2(trace_handle, TR_vecEndPos, fHit);
        EFF_SPILL_BLOOD(fHit, fDirection, spr_blood_spray, spr_blood_drop);
    }
}

spawn_monster_nearby_origin(const amount, Float:fOrigin[3], const Float:fDist, const Float:fHealth=10000.0)
{
    new Array:tempArray = Invalid_Array, iAvailableLocationsCount, iCount = 0;
    iAvailableLocationsCount = find_location_around_origin(fOrigin, g_fMAX_SIZE, g_fMIN_SIZE, fDist, false, any:tempArray);
    for(new i, iItem, loop = min(amount, iAvailableLocationsCount), ent; i < loop; i++)
    {
        ArrayGetArray(tempArray, (iItem=random(iAvailableLocationsCount--)), fOrigin);
        ArrayDeleteItem(tempArray, iItem);
        if((ent = NPC_SPAWN(NPC_CUSTOM_CLASSNAME, "REVENANT BOSS", NPC_BOSS_MODEL, fOrigin, g_fNPCViewOFS,
            get_pcvar_float(g_iCvars[CVAR_MONSTER_SPEED]), fHealth, .NPC_MOVETYPE=MOVETYPE_PUSHSTEP,
            .task=NPC_PENTAGRAM_SPAWN, .fMaxS=g_fMAX_SIZE, .fMinS=g_fMIN_SIZE)) > 0)
        {
            set_pev(ent, PEV_IDENTITY, NPC_ID + NPC_REVENANT_MONSTER_ID);
            set_rendering(ent, .render = kRenderTransAlpha, .amount = 000);
            set_pev(ent, PEV_PREVIOUS_TASK, NPC_SEEK_TARGET);
            iCount ++;
        }
    }

    if(tempArray != Invalid_Array)
    {
        ArrayDestroy(tempArray);
    }

    return iCount;
}

public clcmd_spawn_revenant_monster(id, level, cid)
{
    if(!(get_user_flags(id) & level))
    {
        console_print(id, "You've no access!");
        return 1;
    }

    new szAmount[4], szDist[4], Float:fOrigin[3];
    read_argv(1, szAmount, 3);
    read_argv(2, szDist, 3);
    pev(id, pev_origin, fOrigin);
    fOrigin[2] -= 36.0;

    spawn_monster_nearby_origin(max(str_to_num(szAmount), 1), fOrigin, floatmax( floatstr(szDist), 100.0 ));

    console_print(id, "Boss have been spawned!");
    return 1;
}

Float:NPC_DashAttack(const iNPC, const Float:fDashForce, const Float:fDamage = 50.0)
{
    new Float:fStart[3], Float:fDest[3], Float:fDashDistance = 9999.0;
    pev(iNPC, pev_origin, fStart);
    pev(iNPC, pev_view_ofs, fDest);
    xs_vec_add(fStart, fDest, fStart);

    pev(iNPC, pev_angles, fDest);
    angle_vector(fDest, ANGLEVECTOR_FORWARD, fDest);
    xs_vec_mul_scalar(fDest, fDashDistance, fDest);
    xs_vec_add(fDest, fStart, fDest);
    NPC_traceattack(iNPC, fStart, fDest, fDashDistance, .bitFlags=IGNORE_MONSTERS);
    MoveToOrigin(iNPC, fDest, fDashForce, 0.0);

    new iEnt = CreateProjectile(CLASS_DASH_ATTACK, fStart, fDashForce, fDamage, DMG_CLUB, iNPC, .fMaxS = g_fMAX_SIZE, .fMinS = g_fMIN_SIZE);
    set_pev(iEnt, pev_aiment, iNPC);
    set_pev(iEnt, pev_movetype, MOVETYPE_FOLLOW);
    set_pev(iEnt, pev_iuser4, pev(iNPC, pev_sequence));
    set_pev(iEnt, pev_nextthink, get_gametime() + 0.1);

    return (fDashDistance / fDashForce);
}

public DashAttack_Think(ent)
{
    static iNPC; iNPC = pev(ent, pev_owner);

    if( !iNPC || pev(iNPC, pev_sequence) != pev(ent, pev_iuser4) )
    {
        set_pev(ent, pev_flags, FL_KILLME);
        dllfunc(DLLFunc_Think, ent);
        return;
    }

    static Float:fStart[3], Float:fDest[3], Float:fDashForce, Float:fDashDistance = 9999.0;

    pev(iNPC, pev_origin, fStart);
    pev(iNPC, pev_view_ofs, fDest);
    pev(ent, pev_maxspeed, fDashForce);
    xs_vec_add(fStart, fDest, fStart);

    pev(iNPC, pev_angles, fDest);
    angle_vector(fDest, ANGLEVECTOR_FORWARD, fDest);
    xs_vec_mul_scalar(fDest, fDashDistance, fDest);
    xs_vec_add(fDest, fStart, fDest);
    NPC_traceattack(iNPC, fStart, fDest, fDashDistance, .bitFlags=IGNORE_MONSTERS);
    MoveToOrigin(iNPC, fDest, fDashForce, 0.0);

    set_pev(ent, pev_nextthink, get_gametime() + 0.1);
}

public DashAttack_touch(ent, other)
{
    if( (pev(ent, pev_flags) & FL_KILLME) || !other || pev(ent, pev_owner) == other || entity_takedamage_type(other) == DAMAGE_NO )
    {
        return;
    }

    new iDamageBits, Float:fDamage;
    pev(ent, pev_dmg, iDamageBits);
    pev(ent, pev_dmg_save, fDamage);
    DashAttack(ent, other, 1000.0, fDamage, iDamageBits);
}

DashAttack(npc, id, const Float:fKnockBackForce, const Float:fDamage, const iDamageBits)
{
    if( ExecuteHamB(Ham_TakeDamage, id, npc, npc, fDamage, iDamageBits) )
    {
        new Float:fKnockBack[3], Float:fOrigin[3], Float:fPos[3];
        pev(npc, pev_origin, fOrigin);
        pev(id, pev_origin, fPos);
        fOrigin[2] = 0.0;
        fPos[2] = 200.0;
        xs_vec_sub(fPos, fOrigin, fKnockBack);
        xs_vec_normalize(fKnockBack, fKnockBack);
        xs_vec_mul_scalar(fKnockBack, fKnockBackForce, fKnockBack);
        set_pev(id, pev_velocity, fKnockBack);
        return true;
    }

    return false;
}

public npc_brain(id)
{
    if(!pev_valid(id)) return;

    static Float:fGtime, iOwner, Float:fVelocity[3], Float:fNPCViewAngles[3], Float:fOrigin[3], Float:fTraceAttackOrigin[3], Float:fViewOffset[3], Float:fNPCspeed, Float:fNPCJspeed, iTask;
    fGtime = get_gametime();
    iTask = pev(id, PEV_TASK);
    iOwner = pev(id, PEV_OWNER);
    pev(id, pev_velocity, fVelocity);
    pev(id, pev_angles, fNPCViewAngles);
    pev(id, pev_origin, fOrigin);
    pev(id, pev_view_ofs, fViewOffset);
    xs_vec_add(fOrigin, fViewOffset, fTraceAttackOrigin);
    fNPCspeed = get_pcvar_float(g_iCvars[CVAR_MONSTER_SPEED]);
    fNPCJspeed = get_pcvar_float(g_iCvars[CVAR_MONSTER_JSPEED]);

    switch( iTask )
    {
        case NPC_PENTAGRAM_SPAWN:
        {
            spawn_pentagram(fOrigin, g_szPentagramMDL, id);

            set_pev(id, pev_takedamage, DAMAGE_NO);
            set_pev(id, PEV_TASK, NPC_REVENANT_PENTAGRAM_SPAWN);
            set_pev(id, pev_nextthink, fGtime + 3.0);
        }
        case NPC_REVENANT_PENTAGRAM_SPAWN:
        {
            new Float:flFramerate, bool:bLoops, Float:fGSpeed,
            iSeq = lookup_sequence(id, "scene_appear", flFramerate, bLoops, fGSpeed);

            if(iSeq != -1)
            {
                new szModel[64], xArray[ANIMATION_DATA];
                pev(id, pev_model, szModel, charsmax(szModel));
                getSequenceData(szModel, iSeq, xArray);
                PlayAnimation(id, iSeq,
                    xArray[ANIMATION_FPS], 1.0, xArray[ANIMATION_FRAMES], ACT_INVALID,
                    .bInLOOP=bLoops,
                    .pArrayEvent=Array:xArray[ANIMATION_EVENT_ARRAY],
                    .pArrayEventSize=xArray[ANIMATION_EVENTS]);
            }

            set_pev(id, PEV_TASK, NPC_FADING_IN);
            set_pev(id, pev_nextthink, fGtime + NPC_THINK_LEN);
        }
        case NPC_FADING_IN:
        {
            static Float:fAnimeLength, iAmount;
            pev(id, PEV_ANIMATION_COOLDOWN, fAnimeLength);
            if(fAnimeLength == 0.0) fAnimeLength = fGtime + 1.0;
            iAmount = floatround((fGtime / fAnimeLength) * 255.0);

            if( iAmount <= 255 )
            {
                set_rendering(id, .render = kRenderTransAlpha, .amount = iAmount);
            }
            else
            {
                set_pev(id, pev_takedamage, DAMAGE_YES);
                set_rendering(id);
                set_pev(id, PEV_TASK, pev(id, PEV_PREVIOUS_TASK));
            }

            set_pev(id, pev_nextthink, fGtime + NPC_THINK_LEN);
        }
        case NPC_IDLE:
        {
            NPC_animation(id, g_animArrays, g_sizeAnimArrays);
            set_pev(id, pev_nextthink, fGtime + NPC_THINK_LEN);
        }
        case NPC_DEATH:
        {
            remove_task(id);

            new Float:fLen = NPC_animation(id, g_animArrays, g_sizeAnimArrays);

            set_pev(id, PEV_TASK, NPC_KILLSELF);
            set_pev(id, pev_nextthink, fGtime + fLen + NPC_KILLSELF_THINK_LEN);
        }
        case NPC_KILLSELF:
        {
            remove_task(id);

            new ent = -1;

            while( (ent = find_ent_by_owner(ent, CLASS_FIRE_BOLTS, id)) > 0 )
            {
                set_pev(ent, pev_owner, 0);
            }

            while( (ent = find_ent_by_owner(ent, CLASS_FIRE_DESK, id)) > 0 )
            {
                set_pev(ent, pev_owner, 0);
            }

            while( (ent = find_ent_by_owner(ent, CLASS_FIRE_FLAME, id)) > 0 )
            {
                set_pev(ent, pev_owner, 0);
            }

            while( (ent = find_ent_by_owner(ent, CLASS_FIRE_BREATH, id)) > 0 )
            {
                set_pev(ent, pev_owner, 0);
            }

            while( (ent = find_ent_by_owner(ent, CLASS_DASH_ATTACK, id)) > 0 )
            {
                set_pev(ent, pev_owner, 0);
            }

            while( (ent = find_ent_by_owner(ent, CLASS_PENTAGRAM, id)) > 0 )
            {
                set_pev(ent, pev_flags, FL_KILLME);
                dllfunc(DLLFunc_Think, ent);
            }

            set_pev(id, pev_flags, FL_KILLME);
            dllfunc(DLLFunc_Think, id);
        }
        case NPC_SEEK_TARGET:
        {
            static ent, iTarget, Float:fMaxDistance, Float:fDist, Float:fOriginDest[3];
            ent = iTarget = 0;
            fMaxDistance = 1000.0;

            while( (ent=find_ent_in_sphere(ent, fTraceAttackOrigin, fMaxDistance)) > 0)
            {
                if( ent != iOwner &&
                    IsPlayer(ent) &&
                    entity_takedamage_type(ent) != DAMAGE_NO &&
                    IsEntityVisible(fTraceAttackOrigin, fOriginDest, ent, id) &&
                    fMaxDistance > (fDist = get_distance_f(fTraceAttackOrigin,fOriginDest)) )
                {
                    fMaxDistance = fDist;
                    iTarget = ent;
                }
            }

            static Float:fRoamingDelay, Float:fTeleportDelay;
            pev(id, PEV_NPC_ACTION_DELAY, fRoamingDelay);
            pev(id, PEV_TELEPORTING_COOLDOWN, fTeleportDelay);

            if(iTarget) // We Found a target? engage !
            {
                set_pev(id, PEV_TARGET_LAST_TIME_SEEN, fGtime);
                set_pev(id, PEV_PREVIOUS_TASK, NPC_SEEK_TARGET);
                set_pev(id, NPC_TARGET, iTarget);
                set_pev(id, PEV_TASK, NPC_ATTACK);
            }
            else if( fRoamingDelay < fGtime ) // lets roam and find us a target.
            {
                static i, Float:vfTemp[3] = { 0.0, 0.0, 0.0 }, Float:fChosenAngle, Float:fCurrAngle;
                fMaxDistance = fChosenAngle = 0.0; // 1k unit should be enf for us to find the longest path.
                fOriginDest[2] = fTraceAttackOrigin[2];

                for ( i = 0, fCurrAngle = -45.0;  i < 3; i ++ )
                {
                    fDist = 9999.0;
                    xs_vec_set(vfTemp, 0.0, fNPCViewAngles[1] + fCurrAngle, 0.0);
                    angle_vector(vfTemp, ANGLEVECTOR_FORWARD, vfTemp);
                    xs_vec_mul_scalar(vfTemp, fDist, vfTemp);

                    fOriginDest[0] = fOrigin[0] + vfTemp[0];
                    fOriginDest[1] = fOrigin[1] + vfTemp[1];
                    NPC_traceattack(id, fTraceAttackOrigin, fOriginDest, fDist, .HullType=HULL_HUMAN);

                    if(fDist > fMaxDistance)
                    {
                        fMaxDistance = fDist;
                        fChosenAngle = fNPCViewAngles[1] + fCurrAngle;
                    }

                    fCurrAngle += 45.0;
                }

                if( fMaxDistance > ((xs_vec_len(g_fMAX_SIZE) + xs_vec_len(g_fMIN_SIZE)) * 0.5) )
                {
                    vfTemp[ 0 ] = vfTemp[ 2 ] = 0.0;
                    vfTemp[ 1 ] = fChosenAngle;
                    angle_vector(vfTemp, ANGLEVECTOR_FORWARD, vfTemp);
                    xs_vec_mul_scalar(vfTemp, fMaxDistance, vfTemp);
                    fOriginDest[0] = fOrigin[0] + vfTemp[0];
                    fOriginDest[1] = fOrigin[1] + vfTemp[1];
                    fOriginDest[2] = fOrigin[2];
                    LookAtOrigin(id, fOriginDest);
                    MoveToOrigin(id, fOriginDest, fNPCspeed, fNPCJspeed, fVelocity);
                }
                else // no way to go ? lets turn 45 degrees to the right.
                {
                    xs_vec_set(vfTemp, 0.0, fNPCViewAngles[1] + 45.0, 0.0);
                    angle_vector(vfTemp, ANGLEVECTOR_FORWARD, vfTemp);
                    fOriginDest[0] = fOrigin[0] + vfTemp[0];
                    fOriginDest[1] = fOrigin[1] + vfTemp[1];
                    LookAtOrigin(id, fOriginDest);
                    set_pev(id, PEV_NPC_ACTION_DELAY, fGtime + 0.5); // turning right takes time.
                }
            }

            NPC_animation(id, g_animArrays, g_sizeAnimArrays);
            set_pev(id, pev_nextthink, fGtime + NPC_THINK_LEN);
        }
        case NPC_ATTACK:
        {
            static iVictim, Float:fHealth; fHealth = 0.0;
            if(pev_valid((iVictim = pev(id, NPC_TARGET))))
            {
                pev(iVictim, pev_health, fHealth);
            }

            if(fHealth > 0.0 && entity_takedamage_type(iVictim) != DAMAGE_NO)
            {
                static Float:fOriginDest[3], Float:fDelay = -1.0, Float:fView[3];
                pev(iVictim, pev_origin, fOriginDest);
                pev(id, PEV_NPC_ACTION_DELAY, fDelay);

                if(fDelay > fGtime)
                {
                    set_pev(id, pev_nextthink, fGtime + NPC_THINK_LEN);
                    return;
                }

                // NPC has no visual of the target.
                if( !IsEntityVisible(fTraceAttackOrigin, fView, iVictim, id) )
                {
                    /* npc cannot see the target. */
                    static Float:fLastSeen;
                    pev(id, PEV_TARGET_LAST_TIME_SEEN, fLastSeen);
                    if( fGtime > (fLastSeen + 3.0) )
                    {
                        set_pev(id, NPC_TARGET, 0);
                    }

                    fDelay = -1.0;
                    NPC_animation(id, g_animArrays, g_sizeAnimArrays);
                }
                else // Enemy is visible
                {
                    set_pev(id, PEV_TARGET_LAST_TIME_SEEN, fGtime);

                    LookAtOrigin(id, fOriginDest);

                    static NPC_ACTIVITY:iAttackActivity = ACT_INVALID;
                    iAttackActivity = NPC_GetAttackActivity(id, iVictim, .fMeleeTraceAttack1 = get_pcvar_float(g_iCvars[CVAR_MONSTER_MELEE_DISTANCE]));

                    if(iAttackActivity != ACT_INVALID)
                    {
                        if(g_sizeAnimArrays[iAttackActivity] > 0)
                        {
                            static xArray[ANIMATION_DATA], Float:fLength;
                            ArrayGetArray(Array:g_animArrays[iAttackActivity], random(g_sizeAnimArrays[iAttackActivity]), xArray);
                            fLength = ( xArray[ANIMATION_FRAMES] / floatmax(xArray[ANIMATION_FPS], 1.0) );
                            PlayAnimation(id, xArray[ANIMATION_SEQUENCE],
                                    xArray[ANIMATION_FPS], 1.0, xArray[ANIMATION_FRAMES], iAttackActivity,
                                    .bInLOOP=false,
                                    .pArrayEvent=Array:xArray[ANIMATION_EVENT_ARRAY],
                                    .pArrayEventSize=xArray[ANIMATION_EVENTS]);

                            fDelay = fGtime + fLength;
                        }
                    }
                    else // Target is out of range, order to go to.
                    {
                        if(IsPlayer(iVictim))
                        {
                            fOriginDest[2] -= 36.0;
                        }

                        MoveToOrigin(id, fOriginDest, fNPCspeed, fNPCJspeed, fVelocity);
                        NPC_animation(id, g_animArrays, g_sizeAnimArrays);
                        fDelay = -1.0;
                    }
                }

                set_pev(id, PEV_NPC_ACTION_DELAY, fDelay);
            }
            else
            {
                if(!iVictim && pev(id, PEV_PREVIOUS_TASK) == NPC_FOLLOW_PLAYER)
                {
                    set_pev(id, PEV_PREVIOUS_TASK, NPC_IDLE);
                }

                set_pev(id, PEV_TASK, pev(id, PEV_PREVIOUS_TASK));
                set_pev(id, NPC_TARGET, 0);
            }

            set_pev(id, pev_nextthink, fGtime + NPC_THINK_LEN);
        }
    }
}

spawn_pentagram(const Float:fOrigin[3], const szModel[], const iOwner)
{
    new ent = create_entity("info_target");

    if(!ent) return 0;

    set_pev(ent, pev_classname, CLASS_PENTAGRAM);
    engfunc(EngFunc_SetModel, ent, szModel);
    engfunc(EngFunc_SetOrigin, ent, fOrigin);
    set_pev(ent, pev_owner, iOwner);

    drop_to_floor(ent);
    return ent;
}

NPC_ACTIVITY:NPC_GetAttackActivity(const id, const target, const Float:fMeleeTraceAttack1=250.0, const Float:fMeleeTraceAttack2=800.0, const Float:fRangeTraceAttack1=800.0, const Float:fSpecialAbilityRange=400.0)
{
        static any:iAttackActivity;
        iAttackActivity = ACT_INVALID;

        static szKey[32], Float:fGameTime, Float:fSpecialAbilityTime, Float:fRangeAbilityTime;

        // Use Special ability / Range ability if its ready.
        formatex(szKey, charsmax(szKey), "NPC_#%d_NEXT_SPECIAL_ATTACK", id);
        TrieGetCell(g_trie_NPC_EVENTS, szKey, fSpecialAbilityTime);
        formatex(szKey, charsmax(szKey), "NPC_#%d_NEXT_RANGE_ATTACK", id);
        TrieGetCell(g_trie_NPC_EVENTS, szKey, fRangeAbilityTime);
        fGameTime = get_gametime();

        if( fGameTime > fSpecialAbilityTime)
        {
            if( NPC_NearPlayer(target, id, .fDistance = fSpecialAbilityRange) )
            {
                iAttackActivity = random_num(ACT_SPECIAL_ATTACK1, ACT_SPECIAL_ATTACK2);
                formatex(szKey, charsmax(szKey), "NPC_#%d_NEXT_SPECIAL_ATTACK", id);
                TrieSetCell(g_trie_NPC_EVENTS, szKey, fGameTime + 20.0);
            }
        }
        else if( fGameTime > fRangeAbilityTime)
        {
            if( NPC_NearPlayer(target, id, .fDistance = fRangeTraceAttack1) )
            {
                iAttackActivity = random_num(ACT_RANGE_ATTACK1, ACT_RANGE_ATTACK2);
                formatex(szKey, charsmax(szKey), "NPC_#%d_NEXT_RANGE_ATTACK", id);
                TrieSetCell(g_trie_NPC_EVENTS, szKey, fGameTime + 10.0);
            }
        }
        else if( NPC_NearPlayer(target, id, .fDistance = fMeleeTraceAttack1) )
        {
            iAttackActivity = ACT_MELEE_ATTACK1;
        }
        else if( NPC_NearPlayer(target, id, .fDistance = fMeleeTraceAttack2) )
        {
            iAttackActivity = ACT_MELEE_ATTACK2;
        }

        if(NPC_LOOKUP_ACTIVITY(iAttackActivity, g_sizeAnimArrays) == ACT_INVALID)
        {
            iAttackActivity = ACT_INVALID;
        }

        return iAttackActivity;
}

CreateSprayOfFire(Float:fOrigin[3], Float:fDirection[3], const modelindex, const count = 1, const speed = 10, const noise = 1, const iRenderMode = kRenderNormal)
{
    message_begin(MSG_BROADCAST, SVC_TEMPENTITY);
    write_byte(TE_SPRAY);
    engfunc(EngFunc_WriteCoord, fOrigin[0]);
    engfunc(EngFunc_WriteCoord, fOrigin[1]);
    engfunc(EngFunc_WriteCoord, fOrigin[2]);
    engfunc(EngFunc_WriteCoord, fDirection[0]);
    engfunc(EngFunc_WriteCoord, fDirection[1]);
    engfunc(EngFunc_WriteCoord, fDirection[2]);
    write_short(modelindex);
    write_byte(count); // (count)
    write_byte(speed); // (speed)
    write_byte(noise); // (noise)
    write_byte(iRenderMode); // (rendermode)
    message_end();
}

public task_breathe_fire(const id)
{
    static Float:fOrigin[3], Float:fDirection[3], iFireBreath;
    GetAttachmentData(id, MONSTER_MOUTH_ATTACHMENT, fOrigin, fDirection);
    angle_vector(fDirection, ANGLEVECTOR_FORWARD, fDirection);

    CreateSprayOfFire(fOrigin, fDirection, .modelindex = g_sprite_flame_breath, .speed = 300, .iRenderMode = kRenderTransAdd);

    iFireBreath = CreateProjectile(CLASS_FIRE_BREATH, fOrigin, 300.0, .fDamage=10.0, .iBitsDamage=DMG_BURN, .owner=id, .szProjectileModel="sprites/explode1.spr");
    set_rendering(iFireBreath, .render=kRenderTransAdd, .amount=255);
    set_pev(iFireBreath, pev_gravity, 0.15);
    FireProjectile(iFireBreath, fDirection, 300.0);
    set_pev(iFireBreath, pev_nextthink, get_gametime() + 0.1);
}

public task_npc_event(const Params[ANIMATION_EVENTS_DATA], const id)
{
    switch( Params[EVENT_NUMBER] )
    {
        case EVENT_INITIATE_LAVA_SPRAY:
        {
            new xArray[ANIMATION_DATA], Float:fFrameRate, Float:fAnimeTime, Float:fSpeed, Float:fCurrFrame;
            getSequenceData( NPC_BOSS_MODEL, pev(id, pev_sequence), xArray );
            pev(id, pev_framerate, fFrameRate);
            pev(id, pev_animtime, fAnimeTime);
            fSpeed = (xArray[ANIMATION_FPS] * fFrameRate);
            fCurrFrame = (get_gametime() - fAnimeTime) * fSpeed;
            set_task(0.1, "task_breathe_fire", id, _, _, "a", 10 * floatround( (xArray[ANIMATION_FRAMES] - fCurrFrame) / fSpeed));
        }
        case EVENT_INITIATE_DASH_RUN:
        {
            new xArray[ANIMATION_DATA];
            getSequenceData( NPC_BOSS_MODEL, str_to_num(Params[EVENT_OPTION]), xArray );
            PlayAnimation(id, xArray[ANIMATION_SEQUENCE],
                        xArray[ANIMATION_FPS], 1.0, xArray[ANIMATION_FRAMES], ACT_RANGE_ATTACK1,
                        .bInLOOP=true,
                        .pArrayEvent=Array:xArray[ANIMATION_EVENT_ARRAY],
                        .pArrayEventSize=xArray[ANIMATION_EVENTS]);

            new Float:fLength = NPC_DashAttack(id, 1000.0);
            set_pev(id, PEV_NPC_ACTION_DELAY, get_gametime() + fLength + 1.0 );

            set_task(fLength, "task_dash_end", id);
        }
        case EVENT_MELEEATTACK:
        {
            if(NPC_MeleeAttack1(id, get_pcvar_float(g_iCvars[CVAR_MONSTER_MELEE_DAMAGE]), get_pcvar_float(g_iCvars[CVAR_MONSTER_MELEE_DISTANCE]), DMG_SLASH))
            {
                emit_sound(id, CHAN_BODY, NPC_CLAWS_STRIKE_SOUNDS[random(sizeof NPC_CLAWS_STRIKE_SOUNDS)], VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
            }
            else
            {
                emit_sound(id, CHAN_BODY, NPC_CLAWS_MISS_SOUNDS[random(sizeof NPC_CLAWS_MISS_SOUNDS)], VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
            }
        }
        case EVENT_CREATE_FIRE_BOLTS:
        {
            new Float:fStart[3], Float:fDirection[3], iFireBolt;

            GetAttachmentData(id, MONSTER_L_HAND_ATTACHMENT, fStart, fDirection);

            angle_vector(fDirection, ANGLEVECTOR_UP, fDirection);
            xs_vec_mul_scalar(fDirection, 32.0, fDirection);
            xs_vec_add(fStart, fDirection, fStart);
            iFireBolt = CreateProjectile(CLASS_FIRE_BOLTS, fStart, get_pcvar_float(g_iCvars[CVAR_FIREBOLTS_FORCE]),
                .fDamage=get_pcvar_float(g_iCvars[CVAR_FIREBOLTS_DMG]),
                .iBitsDamage=DMG_BURN, .owner=id, .szProjectileModel=g_szSPRITE_FIRE, .fMinS=Float:{ -1.0, -1.0, -64.0 });
            set_rendering(iFireBolt, .render=kRenderTransAdd, .amount=255);
            set_pev(iFireBolt, pev_gravity, 0.0001);
            set_pev(iFireBolt, pev_scale, 0.3);
            set_pev(iFireBolt, pev_iuser4, MONSTER_L_HAND_ATTACHMENT);
            set_pev(iFireBolt, pev_iuser3, id);
            set_pev(iFireBolt, pev_nextthink, get_gametime() + 0.01 );

            GetAttachmentData(id, MONSTER_R_HAND_ATTACHMENT, fStart, fDirection);

            angle_vector(fDirection, ANGLEVECTOR_UP, fDirection);
            xs_vec_mul_scalar(fDirection, 32.0, fDirection);
            xs_vec_add(fStart, fDirection, fStart);
            iFireBolt = CreateProjectile(CLASS_FIRE_BOLTS, fStart, get_pcvar_float(g_iCvars[CVAR_FIREBOLTS_FORCE]),
                .fDamage=get_pcvar_float(g_iCvars[CVAR_FIREBOLTS_DMG]), .iBitsDamage=DMG_BURN, .owner=id, .szProjectileModel=g_szSPRITE_FIRE, .fMinS=Float:{ -1.0, -1.0, -64.0 });
            set_rendering(iFireBolt, .render=kRenderTransAdd, .amount=255);
            set_pev(iFireBolt, pev_gravity, 0.0001);
            set_pev(iFireBolt, pev_scale, 0.3);
            set_pev(iFireBolt, pev_iuser4, MONSTER_R_HAND_ATTACHMENT);
            set_pev(iFireBolt, pev_iuser3, id);
            set_pev(iFireBolt, pev_nextthink, get_gametime() + 0.01 );
        }
        case EVENT_SHOOT_FIRE_BOLTS:
        {
            new Float:fStart[3], Float:fVAngles[3], Float:fDirection[3], iFireBolt, Float:vOrigin[3], iTarget, Float:fFireBoltForce = get_pcvar_float(g_iCvars[CVAR_FIREBOLTS_FORCE]);

            pev( id, pev_origin, vOrigin );
            pev( id, pev_view_ofs, fStart );
            xs_vec_add(vOrigin, fStart, vOrigin);

            iTarget = pev(id, NPC_TARGET);

            if( iTarget > 0 )
            {
                pev( iTarget, pev_origin, fStart );

                if(IsPlayer(iTarget))
                {
                    fStart[2] -= 36.0;
                }
            }
            else
            {
                pev( id, pev_angles, fStart )
                angle_vector(fStart, ANGLEVECTOR_FORWARD, fStart);
                xs_vec_mul_scalar(fStart, 10.0, fStart);
                xs_vec_add(fStart, vOrigin, fStart);
            }

            xs_vec_sub(fStart, vOrigin, fStart);
            xs_vec_normalize(fStart, fStart);
            vector_to_angle(fStart, fVAngles);
            set_pev( id, pev_v_angle, fVAngles);

            if(equal(Params[EVENT_OPTION], "LEFT"))
            {
                while( (iFireBolt = find_ent_by_class(iFireBolt, CLASS_FIRE_BOLTS)) > 0 )
                {
                    if(pev(iFireBolt, pev_iuser4) == MONSTER_L_HAND_ATTACHMENT && pev(iFireBolt, pev_iuser3) == id)
                    {
                        break;
                    }
                }

                if( !iFireBolt )
                {
                    GetAttachmentData(id, MONSTER_L_HAND_ATTACHMENT, fStart, fDirection);

                    angle_vector(fDirection, ANGLEVECTOR_UP, fDirection);
                    xs_vec_mul_scalar(fDirection, 32.0, fDirection);
                    xs_vec_add(fStart, fDirection, fStart);
                    iFireBolt = CreateProjectile(CLASS_FIRE_BOLTS, fStart, fFireBoltForce,
                        .fDamage=get_pcvar_float(g_iCvars[CVAR_FIREBOLTS_DMG]), .iBitsDamage=DMG_BURN, .owner=id,
                        .szProjectileModel=g_szSPRITE_FIRE, .fMinS=Float:{ -1.0, -1.0, -64.0 });
                    set_rendering(iFireBolt, .render=kRenderTransAdd, .amount=255);
                    set_pev(iFireBolt, pev_gravity, 0.0001);
                    set_pev(iFireBolt, pev_scale, 0.3);
                    set_pev(iFireBolt, pev_iuser4, MONSTER_L_HAND_ATTACHMENT);
                }

                set_pev(iFireBolt, pev_iuser3, 0);
            }
            else if(equal(Params[EVENT_OPTION], "RIGHT"))
            {
                while( (iFireBolt = find_ent_by_class(iFireBolt, CLASS_FIRE_BOLTS)) > 0 )
                {
                    if(pev(iFireBolt, pev_iuser4) == MONSTER_R_HAND_ATTACHMENT && pev(iFireBolt, pev_iuser3) == id)
                    {
                        break;
                    }
                }

                if( !iFireBolt )
                {
                    GetAttachmentData(id, MONSTER_R_HAND_ATTACHMENT, fStart, fDirection);

                    angle_vector(fDirection, ANGLEVECTOR_UP, fDirection);
                    xs_vec_mul_scalar(fDirection, 32.0, fDirection);
                    xs_vec_add(fStart, fDirection, fStart);
                    iFireBolt = CreateProjectile(CLASS_FIRE_BOLTS, fStart, fFireBoltForce,
                        .fDamage=get_pcvar_float(g_iCvars[CVAR_FIREBOLTS_DMG]), .iBitsDamage=DMG_BURN, .owner=id,
                        .szProjectileModel=g_szSPRITE_FIRE, .fMinS=Float:{ -1.0, -1.0, -64.0 });
                    set_rendering(iFireBolt, .render=kRenderTransAdd, .amount=255);
                    set_pev(iFireBolt, pev_gravity, 0.0001);
                    set_pev(iFireBolt, pev_scale, 0.3);
                    set_pev(iFireBolt, pev_iuser4, MONSTER_R_HAND_ATTACHMENT);
                }

                set_pev(iFireBolt, pev_iuser3, 0);
            }

            fVAngles[0] *= -1.0;
            angle_vector(fVAngles, ANGLEVECTOR_FORWARD, fDirection);
            FireProjectile(iFireBolt, fDirection, fFireBoltForce);

            emit_sound(id, CHAN_BODY, NPC_CLAWS_MISS_SOUNDS[random(sizeof NPC_CLAWS_MISS_SOUNDS)], VOL_NORM, ATTN_NORM, 0, PITCH_NORM);

            xs_vec_add(vOrigin, fDirection, fDirection);
            LookAtOrigin(id, fDirection);
        }
        case EVENT_INITIATE_LAVA_ASTEROIDS:
        {
            new Float:fOrigin[3], aParams[4], Array:ArrLocations = Invalid_Array;
            pev(id, pev_origin, fOrigin);
            find_sky(fOrigin, id);
            fOrigin[2] -= 100.0;
            aParams[1] = find_location_around_origin(fOrigin, Float:{ 25.0, 25.0, 1.0 }, Float:{ -25.0, -25.0, -1.0 }, 800.0, .pArrayLocations = ArrLocations);
            aParams[0] = any:ArrLocations;
            aParams[2] = 8;
            aParams[3] = 8;

            task_astroids(aParams, id);
        }
        case EVENT_INITIATE_LAVA_DISK:
        {
            new Float:fStart[3];
            pev(id, pev_origin, fStart);
            NPC_RadiusAttack(id, get_pcvar_float(g_iCvars[CVAR_FIREDESK_RADIUS]), get_pcvar_float(g_iCvars[CVAR_FIREDESK_LIFE]), get_pcvar_float(g_iCvars[CVAR_FIREDESK_DMG]), CLASS_FIRE_DESK);
            EF_BeamCylinder(fStart, g_sprite_shockwave, 500.0, 2.0, .fWidth=3.0, .red=200, .green=0, .blue=0);
        }
        case EVENT_INITIATE_LAVA_SPHERE:
        {
            NPC_RadiusAttack(id, get_pcvar_float(g_iCvars[CVAR_FIREDESK_RADIUS]), get_pcvar_float(g_iCvars[CVAR_FIREDESK_LIFE]), get_pcvar_float(g_iCvars[CVAR_FIREDESK_DMG]), CLASS_FIRE_DESK);

            new Float:fStart[3], Float:fViewOffset[3];
            pev(id, pev_origin, fStart);
            pev(id, pev_view_ofs, fViewOffset);

            EF_BeamCylinder(fStart, g_sprite_shockwave, 500.0, 2.0, .fWidth=3.0, .red=200, .green=0, .blue=0);
            xs_vec_add(fStart, fViewOffset, fStart);
            FireFieldAttack(fStart, 700.0, g_szSPRITE_FIRE_BALL, id, -10.0,
                .fDamage=get_pcvar_float(g_iCvars[CVAR_FIREBOLTS_DMG]), .szClass=CLASS_FIRE_BOLTS);
            FireFieldAttack(fStart, 500.0, g_szSPRITE_FIRE, id, 5.0, .fDamage=get_pcvar_float(g_iCvars[CVAR_FLAME_DMG]), .szClass=CLASS_FIRE_FLAME);
        }
        case EVENT_FOOT_STEP:
        {
            emit_sound(id, CHAN_AUTO, NPC_STEP_SOUNDS[random(sizeof NPC_STEP_SOUNDS)], VOL_NORM, ATTN_NORM, 0, PITCH_NORM);

            new players[32], pnum;
            get_players(players, pnum, "ah");

            for(new i, player; i < pnum; i++)
            {
                player = players[ i ];

                if(NPC_NearPlayer(player, id, .fDistance=500.0))
                {
                    ScreenShake(20, 1, 10, .dest=MSG_ONE_UNRELIABLE, .host=player);
                }
            }
        }
    }
}

ScreenShake(const Amplitude, const Duration, const Frequency, const dest = MSG_BROADCAST, const host=0, const Float:fOrigin[3] = {0.0,0.0,0.0})
{
    engfunc(EngFunc_MessageBegin, dest, get_user_msgid("ScreenShake"), fOrigin, host);
    write_short( min(Amplitude * 4096, 0xFFFF) ); // Amplitude
    write_short( min(Duration * 4096, 0xFFFF) ); // Duration
    write_short( min(Frequency * 4096, 0xFFFF) ); // Frequency
    message_end();
}


public task_astroids(aParams[4], const id)
{
    new Float:fOrigin[3], Float:fAngles[3], Array:ArrLocations = any:aParams[ 0 ];
    pev(id, pev_angles, fAngles);

    new x = aParams[ 1 ];

    if(x > 0)
    {
        new Float:fDirection[3];
        fDirection[0] = 0.25 * -floatsin(fAngles[1], degrees);
        fDirection[1] = 0.25 *  floatcos(fAngles[1], degrees);
        fDirection[2] = -1.0;

        for(new i, iFireBolt, iItemID, maxloop = min(aParams[3], ArraySize(ArrLocations)); i < maxloop; i++)
        {
            iItemID = random(ArraySize(ArrLocations));
            ArrayGetArray(ArrLocations, iItemID, fOrigin);
            ArrayDeleteItem(ArrLocations, iItemID);
            iFireBolt = CreateProjectile(CLASS_FIRE_BOLTS, fOrigin, get_pcvar_float(g_iCvars[CVAR_FIREBOLTS_FORCE]),
                .fDamage=get_pcvar_float(g_iCvars[CVAR_FIREBOLTS_DMG]),
                .iBitsDamage=DMG_BURN, .owner=id, .szProjectileModel=g_szSPRITE_FIRE);
            set_rendering(iFireBolt, .render=kRenderTransAdd, .amount=255);
            set_pev(iFireBolt, pev_gravity, 1.0);
            set_pev(iFireBolt, pev_scale, 0.3);

            FireProjectile(iFireBolt, fDirection, get_pcvar_float(g_iCvars[CVAR_FIREBOLTS_FORCE]));
        }
    }

    if(--aParams[2] > 0)
    {
        set_task(0.5, "task_astroids", id, aParams, sizeof aParams);
    }
    else if( ArrLocations != Invalid_Array )
    {
        ArrayDestroy(ArrLocations);
    }
}

public task_dash_end(const id)
{
    new xArray[ANIMATION_DATA];

    getSequenceData( NPC_BOSS_MODEL, 7, xArray );
    PlayAnimation(id, xArray[ANIMATION_SEQUENCE],
            xArray[ANIMATION_FPS], 1.0, xArray[ANIMATION_FRAMES], ACT_INVALID,
                .bInLOOP=false,
                    .pArrayEvent=Array:xArray[ANIMATION_EVENT_ARRAY],
                        .pArrayEventSize=xArray[ANIMATION_EVENTS]);

    new ent = -1;
    while( (ent = find_ent_by_class(ent, "DashAttack")) > 0 )
    {
        if( pev(ent, pev_aiment) != id )
        {
            continue;
        }

        set_pev(ent, pev_flags, FL_KILLME);
        dllfunc(DLLFunc_Think, ent);
    }

    new Float:fLen = (xArray[ANIMATION_FRAMES] / xArray[ANIMATION_FPS]);
    set_pev(id, PEV_NPC_ACTION_DELAY, get_gametime() + fLen + 1.0 );
    set_task(fLen, "task_play_idle", id);
}

public task_play_idle(const id)
{
    new xArray[ANIMATION_DATA];
    ArrayGetArray(Array:g_animArrays[ACT_IDLE], random(g_sizeAnimArrays[ACT_IDLE]), xArray);
    PlayAnimation(id, xArray[ANIMATION_SEQUENCE],
            xArray[ANIMATION_FPS], 1.0, xArray[ANIMATION_FRAMES], ACT_IDLE,
                .bInLOOP=false,
                    .pArrayEvent=Array:xArray[ANIMATION_EVENT_ARRAY],
                        .pArrayEventSize=xArray[ANIMATION_EVENTS]);
}

public FireBolts_touch(ent, other)
{
    if( (pev(ent, pev_flags) & FL_KILLME) || pev(other, pev_solid) == SOLID_TRIGGER )
    {
        return;
    }

    new Float:fOrigin[3], iProjectileID;
    pev(ent, pev_origin, fOrigin);
    iProjectileID = NPC_RadiusAttack(ent, 100.0, 2.0, 10.0, CLASS_FIRE_DESK);
    set_pev(iProjectileID, pev_vuser4, fOrigin);
    set_pev(iProjectileID, pev_owner, pev(ent, pev_owner));

    emit_sound(iProjectileID, CHAN_BODY, g_szSND_FireBoltExplosion, VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
    EF_BeamCylinder(fOrigin, g_sprite_shockwave, 100.0, 2.0, .fWidth=1.0, .red=200, .green=0, .blue=0);
    EF_Smoke(fOrigin, g_sprite_smoke);

    set_pev(ent, pev_flags, FL_KILLME);
    dllfunc(DLLFunc_Think, ent);
}

public FireBreath_touch(ent, other)
{
    if( (pev(ent, pev_flags) & FL_KILLME) || (other && pev(other, pev_solid) == SOLID_TRIGGER) )
    {
        return;
    }

    if( other > 0 && other != pev(ent, pev_owner) && entity_takedamage_type(other) != DAMAGE_NO )
    {
        new iDamageBits, Float:fDamage;
        pev(ent, pev_dmg, iDamageBits);
        pev(ent, pev_dmg_save, fDamage);
        ExecuteHamB(Ham_TakeDamage, other, ent, pev(ent, pev_owner), fDamage, iDamageBits);
    }

    new Float:fOrigin[3];
    pev(ent, pev_origin, fOrigin);
    EF_Smoke(fOrigin, g_sprite_smoke);

    set_pev(ent, pev_flags, FL_KILLME);
    dllfunc(DLLFunc_Think, ent);
}

GetAttachmentData(const id, const iAttachmentID, Float:fRetOrigin[3], Float:fRetAngles[3])
{
    static szModel[64], xArray[ANIMATION_DATA], Float:fAnimeTime, Float:fFrame;
    pev(id, pev_model, szModel, charsmax(szModel));
    getSequenceData( szModel, pev(id, pev_sequence), xArray );
    pev( id, pev_animtime, fAnimeTime);
    pev( id, pev_frame, fFrame );
    set_pev( id, pev_frame, (get_gametime() - fAnimeTime) * xArray[ANIMATION_FPS] );

    static Float:fStart[3], Float:fVAngles[3], Float:fPrevOrigin[3], Float:fVec[3];
    engfunc(EngFunc_GetAttachment, id, iAttachmentID, fStart, fVAngles);
    pev(id, pev_origin, fPrevOrigin);
    pev(id, pev_angles, fVAngles);
    set_pev( id, pev_frame, fFrame );

    fPrevOrigin[2] = fStart[2];

    xs_vec_sub(fPrevOrigin, fStart, fVec);
    xs_vec_normalize(fVec, fVec);
    vector_to_angle(fVec, fVec);
    xs_vec_add(fVAngles, fVec, fVAngles);

    xs_vec_copy(fStart, fRetOrigin);
    xs_vec_copy(fVAngles, fRetAngles);
}

public FireBolts_think(ent)
{
    if( pev(ent, pev_iuser3) != 0 && pev(ent, pev_owner) > 0 )
    {
        static Float:fStart[3], Float:fDirection[3], Float:fVAngles[3], iNPC;
        iNPC = pev(ent, pev_owner);

        GetAttachmentData(iNPC, pev(ent, pev_iuser4), fStart, fVAngles);

        angle_vector(fVAngles, ANGLEVECTOR_UP, fDirection);
        xs_vec_mul_scalar(fDirection, 32.0, fDirection);
        xs_vec_add(fStart, fDirection, fStart);

        engfunc(EngFunc_SetOrigin, ent, fStart);

        set_pev(ent, pev_nextthink, get_gametime() + 0.01);
    }
}

public Flame_touch(ent, other)
{
    if( (pev(ent, pev_flags) & FL_KILLME) || !other || other == pev(ent, pev_owner) )
    {
        return;
    }

    if( entity_takedamage_type(other) != DAMAGE_NO )
    {
        static iDamageBits, Float:fDamage;
        pev(ent, pev_dmg, iDamageBits);
        pev(ent, pev_dmg_save, fDamage);
        ExecuteHamB(Ham_TakeDamage, other, ent, pev(ent, pev_owner), fDamage, iDamageBits);
    }
}

public Flame_think(ent)
{
    static Float:fLife, Float:fGameTime;
    pev(ent, pev_fuser4, fLife);
    fGameTime = get_gametime();

    if(fLife != 0.0 && fLife < fGameTime)
    {
        new Float:fOrigin[3];
        pev(ent, pev_origin, fOrigin);
        EF_Smoke(fOrigin, g_sprite_smoke);

        set_pev(ent, pev_flags, FL_KILLME);
        dllfunc(DLLFunc_Think, ent);
        return;
    }

    set_pev(ent, pev_nextthink, fGameTime + 0.1);
}

public FireBreath_think(ent)
{
    static Float:fEventOrigin[3], iTarget = 0, iNPC, iDamageBits, Float:fDamage;
    pev(ent, pev_origin, fEventOrigin);
    iNPC = pev(ent, pev_owner);

    while( (iTarget = find_ent_in_sphere(iTarget, fEventOrigin, 200.0)) > 0)
    {
        if(iTarget != iNPC && entity_takedamage_type(iTarget) != DAMAGE_NO)
        {
            pev(ent, pev_dmg, iDamageBits);
            pev(ent, pev_dmg_save, fDamage);
            ExecuteHamB(Ham_TakeDamage, iTarget, ent, iNPC ? iNPC : ent, fDamage, iDamageBits);
        }
    }

    set_pev(ent, pev_nextthink, get_gametime() + 0.01);
}

public FireDesk_think(ent)
{
    static Float:fOrigin[3], Float:fEventOrigin[3], iNPC, iTarget, Float:f2dDistance, Float:fDamage, iDamageBits;
    iNPC = pev(ent, pev_owner);
    pev(ent, pev_origin, fOrigin);
    pev(ent, pev_vuser4, fEventOrigin);

    iTarget = FM_NULLENT;
    f2dDistance = xs_vec_distance_2d(fOrigin, fEventOrigin);

    while( (iTarget = find_ent_in_sphere(iTarget, fEventOrigin, f2dDistance)) > 0)
    {
        if(iTarget != iNPC && entity_takedamage_type(iTarget) != DAMAGE_NO)
        {
            pev(ent, pev_dmg, iDamageBits);
            pev(ent, pev_dmg_save, fDamage);
            ExecuteHamB(Ham_TakeDamage, iTarget, ent, (iNPC > 0) ? iNPC : ent, fDamage, iDamageBits);
        }
    }

    static Float:fMaxRange;
    pev(ent, pev_fuser4, fMaxRange);

    if(f2dDistance > fMaxRange)
    {
        set_pev(ent, pev_flags, FL_KILLME);
        dllfunc(DLLFunc_Think, ent);
    }
    else
    {
        set_pev(ent, pev_nextthink, get_gametime() + 0.1);
    }
}

NPC_RadiusAttack(id, Float:fRadius, Float:fLife, const Float:fDamage, const szClass[])
{
    new Float:fOffset[3];
    pev(id, pev_view_ofs, fOffset);

    new iProjectileID = NPC_RangeAttack1(id, fOffset, fDamage, szClass, (fRadius / fLife), DMG_BURN);
    set_pev(iProjectileID, pev_solid, SOLID_NOT);
    set_pev(iProjectileID, pev_movetype, MOVETYPE_NOCLIP);
    set_pev(iProjectileID, pev_takedamage, DAMAGE_NO);
    set_pev(iProjectileID, pev_fuser4, fRadius);

    new Float:fOrigin[3];
    pev(id, pev_origin, fOrigin);
    set_pev(iProjectileID, pev_vuser4, fOrigin);

    FireProjectile(iProjectileID, Float:{ 1.0, 0.0, 0.0 }, (fRadius / fLife));

    set_pev(iProjectileID, pev_nextthink, get_gametime() + 0.1);

    return iProjectileID;
}

FireFieldAttack( const Float:fStart[3], const Float:fRadius, const szFireSprMdl[],
    const owner=0, const Float:fLife = -10.0, Float:fDamage = 1.0, iDamageBits = DMG_BURN, const szClass[] = CLASS_FIRE_FLAME,
    const Float:fAngOffset = 30.0, const Float:fMaxAng = 360.0, Float:fMaxs[3] = { 8.0, 8.0, 16.0 }, Float:fMins[3]={ -8.0, -8.0, -16.0 } )
{
    for(new iProjectileID, Float:fOrigin[3], Float:fGameTime = get_gametime(), Float:fAng = 0.0, Float:fDirection[3]; fAng < fMaxAng; fAng += fAngOffset)
    {
        fDirection[0] = floatcos(fAng,degrees);
        fDirection[1] = floatsin(fAng,degrees);
        fDirection[2] = random_float(0.5, 1.0);

        fOrigin[0] = fDirection[0] * (fMaxs[0] - fMins[0]);
        fOrigin[1] = fDirection[1] * (fMaxs[1] - fMins[1]);
        fOrigin[2] = 0.0;

        xs_vec_add(fStart, fOrigin, fOrigin);

        iProjectileID = CreateProjectile(szClass, fOrigin, fRadius,
            .fDamage=fDamage, .iBitsDamage=iDamageBits,
            .owner=owner, .szProjectileModel=szFireSprMdl,
            .fMaxS=fMaxs, .fMinS=fMins);
        set_pev(iProjectileID, pev_framerate, random_float(5.0, 10.0));
        set_rendering(iProjectileID, .render=kRenderTransAdd, .amount=255);
        FireProjectile(iProjectileID, fDirection, fRadius);

        if(fLife < 0.0)
        {
            set_pev(iProjectileID, pev_fuser4, fGameTime + random_float(1.0, -fLife));
        }
        else if(fLife > 0.0)
        {
            set_pev(iProjectileID, pev_fuser4, fGameTime + fLife);
        }
        else
        {
            set_pev(iProjectileID, pev_fuser4, 0.0);
        }

        set_pev(iProjectileID, pev_nextthink, fGameTime + 1.0);
    }
}

EF_Smoke(const Float:fStart[3], const iSpriteIndex, const Float:fLife=3.0)
{
    engfunc(EngFunc_MessageBegin, MSG_PVS, SVC_TEMPENTITY, fStart, 0);
    write_byte( TE_FIREFIELD );
    write_coord_f( fStart[ 0 ] );
    write_coord_f( fStart[ 1 ] );
    write_coord_f( fStart[ 2 ] );
    write_short( 0 ); // Distance
    write_short( iSpriteIndex );
    write_byte( 1 );
    write_byte( TEFIRE_FLAG_ALPHA | TEFIRE_FLAG_SOMEFLOAT );
    write_byte(min( floatround(fLife * 10.0), 0xFF));
    message_end( );
}

EF_BeamCylinder(const Float:fStart[3], const iSpriteIndex, const Float:fRadius, const Float:fLife,
    const Float:fFrameRate=1.0, Float:fWidth=1.0, Float:fNoise=0.0,
    const red=255, const green=0, const blue=0, const brightness=200, const Float:fScroll=0.0)
{
    engfunc(EngFunc_MessageBegin, MSG_PVS, SVC_TEMPENTITY, fStart, 0);
    write_byte(TE_BEAMCYLINDER);
    engfunc(EngFunc_WriteCoord, fStart[0]);
    engfunc(EngFunc_WriteCoord, fStart[1]);
    engfunc(EngFunc_WriteCoord, fStart[2]);
    engfunc(EngFunc_WriteCoord, fStart[0]);
    engfunc(EngFunc_WriteCoord, fStart[1]);
    engfunc(EngFunc_WriteCoord, fStart[2] + (fRadius * 0.5) );
    write_short(iSpriteIndex);
    write_byte(1);
    write_byte(min( floatround(fFrameRate * 10.0), 0xFF));
    write_byte(min( floatround(fLife * 10.0), 0xFF));
    write_byte(min( floatround(fWidth * 10.0), 0xFF));
    write_byte(min( floatround(fNoise * 10.0), 0xFF));
    write_byte(red);
    write_byte(green);
    write_byte(blue);
    write_byte(brightness);
    write_byte(min( floatround(fScroll * 10.0), 0xFF));
    message_end();
}
