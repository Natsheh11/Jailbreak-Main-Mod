/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <engine>
#include <hamsandwich>
#include <fakemeta>

#define PLUGIN "jail_blue map enhancer"
#define VERSION "1.0"
#define AUTHOR "*CareFully*"

// Taskids. Change them when other plugins will have conflicts!
#define TASKID 1337
#define DODGE_TASKID 1338

#define DODGE_HITABLE		true	// Change this to false if you don't want players to be able to hit the box with weapons.

#define DODGE_STARTSPEED	300.0	// Speed at which the Dodgeball will start at.
#define DODGE_SPEEDSTEP		100.0	// How much Dodgeball speed will increase every 10 seconds.
#define DODGE_MAXSPEED		800.0	// Speed at which the Dodgeball will not go any faster.

#define MAPNAME		"jail_blue"	// Map name that this plugin will be enabled in.
#define SOCCERBALL_SPAWN	"soccarjam_ballspawn"	// soccerpall spawn location for the dodgebox
#define DODGE_BTN	"btn_crush"	// Button that will enable/disable DodgeBox.
#define DODGE_BOX	"crushbox"	// Box.
#define DODGE_GOALS	"door_goals"	// Football goals.
#define DODGE_WALLS	"door_football"	// Football gate.
#define TTT_RESET_BTN	"btn_ttt"	// Button that will reset tic tac toe. 
#define TTT_WALLPRE	"wall_ttt"	// Prefix of tic tac toe wall entities (ex: wall_ttta1, wall_tttb4 etc)

// Dodge button targets
#define DODGE_ON	"mm_crush"	
#define DODGE_OFF	"door_crush"

// Uncomment to enable debug messages.
//#define DEBUG

new bool:g_bEnabled;
new g_iExplosionSprite;
new g_iBeamSprite;

//new g_iTrainResetBtn; // Reset button entity id.
//new g_iTrainEnts[sizeof(g_szTrainNames)]; // Train entity id's
//new g_iTrainTps[sizeof(g_szTrainTpsNames)]; // Train reset teleporters id's
//new Float:g_vecTrainDefOrigins[sizeof(g_szTrainNames)][3]; // Trains starting positions

new g_bDodgeOn; // If game is active
new g_iDodgeBoxBtn; // Dodge box button entity id.
new g_iDodgeBox; // Dodge box entity id.
new g_iDodgeGoals;
new g_iDodgeWall;
new Float:g_vecDodgeBoxDefOrigin[3]; // Dodge box spawn origin
new Float:g_vecDodgeBoxHideOrigin[3]; // Dodge box hidden origin
new g_nTime; 
new Float:g_flSpeed; // The speed what will be added each cycle.

enum
{
	TTT_BLANK,
	TTT_O,
	TTT_X
}

new g_iTTTResetBtn; // Reset button entity id.
new g_iTTTBoard[3][3];	// Stored game board.
new g_iTTTOOriginEnts[3][3]; // These will be used to show a winner beam.
new g_iTTTXOriginEnts[3][3]; // These will be used to show a winner beam.
new g_bTTTEnded; // True when winner is found.

public plugin_precache()
{
	g_iExplosionSprite = precache_model("sprites/explode1.spr");
	g_iBeamSprite = precache_model("sprites/zbeam4.spr");
	precache_sound("fvox/bell.wav");
}

public plugin_init() 
{
	register_plugin(PLUGIN, VERSION, AUTHOR);
	RegisterHam(Ham_Use, "func_pushable", "Fwd_Use_Pushable", 0);
	RegisterHam(Ham_Use, "func_button", "Fwd_Use_Button", 0);
	RegisterHam(Ham_Use, "func_wall_toggle", "Fwd_Use_Wall");
	RegisterHam(Ham_Touch, "func_pushable", "Fwd_Touch_Pushable");
#if DODGE_HITABLE
	RegisterHam(Ham_TraceAttack, "func_pushable", "Fwd_Attack_Pushable");
#endif
	register_event("HLTV", "Fwd_New_Round", "a", "1=0", "2=0");
}

public plugin_cfg() 
{
	new szMap[32];
	get_mapname(szMap, charsmax(szMap));
	if (equali(szMap, MAPNAME))
	{
		g_bEnabled = true;
#if defined DEBUG
		log_amx("Current map is %s. Plugin enabled!", MAPNAME);
#endif
	}
	else 
	{
#if defined DEBUG
	log_amx("Current map is not %s. Plugin disabled.", MAPNAME);
#endif
		g_bEnabled = false;
		return;
	}
	// ############################################
	// Dodge box game
	// ############################################	
	g_iDodgeBoxBtn = find_ent_by_tname(-1, DODGE_BTN);
	if (g_iDodgeBoxBtn == 0) 
	{
		log_amx("Warning: Dodge box button not found!!!");
	}
	else 
	{
		Util_SetRendering(g_iDodgeBoxBtn, _, _, _, 255.0);
		entity_set_int(g_iDodgeBoxBtn, EV_INT_solid, SOLID_BBOX);
		entity_set_string(g_iDodgeBoxBtn, EV_SZ_target, DODGE_ON);
	}
	
	g_iDodgeBox = find_ent_by_tname(-1, DODGE_BOX);
	if (g_iDodgeBox == 0) 
	{
		log_amx("Warning: Dodge box not found!!!");
	}
	else 
	{
		entity_get_vector(g_iDodgeBox, EV_VEC_origin, g_vecDodgeBoxHideOrigin);
		entity_set_int(g_iDodgeBox, EV_INT_movetype, MOVETYPE_NONE);
	}
	
	g_iDodgeGoals = find_ent_by_tname(-1, DODGE_GOALS);
	if (g_iDodgeGoals == 0) 
	{
		log_amx("Warning: Football goals not found!!!");
	}
	
	g_iDodgeWall = find_ent_by_tname(-1, DODGE_WALLS);
	if (g_iDodgeWall == 0) 
	{
		log_amx("Warning: Football walls not found!!!");
	}
	
	// ############################################
	// Tic Tac Toe
	// ############################################		
	g_iTTTResetBtn = find_ent_by_tname(-1, TTT_RESET_BTN);
	if (g_iTTTResetBtn == 0) 
	{
		log_amx("Warning: Tic Tac Toe reset button not found!!!");
	}
}

public pfn_keyvalue(entid) {

	new classname[32], key[32], value[32];
	copy_keyvalue(classname, 31, key, 31, value, 31);

	if(equal(classname, SOCCERBALL_SPAWN))
	{
		if(equal(key, "origin"))
		{
#if defined DEBUG
			log_amx("%s location: %s", SOCCERBALL_SPAWN, value);
#endif
			new temp_origins[3][10];
			parse(value, temp_origins[0], 9, temp_origins[1], 9, temp_origins[2], 9);
			g_vecDodgeBoxDefOrigin[0] = floatstr(temp_origins[0]);
			g_vecDodgeBoxDefOrigin[1] = floatstr(temp_origins[1]);
			g_vecDodgeBoxDefOrigin[2] = floatstr(temp_origins[2]);
		}
	}
}

public Fwd_New_Round()
{
	if (g_bEnabled)
	{
		if( task_exists(DODGE_TASKID) )
		{
			remove_task(DODGE_TASKID);
		}
		
		entity_set_vector(g_iDodgeBox, EV_VEC_origin, g_vecDodgeBoxHideOrigin);
		entity_set_vector(g_iDodgeBox, EV_VEC_velocity, Float:{0.0,0.0,0.0});	
		entity_set_vector(g_iDodgeBox, EV_VEC_avelocity, Float:{0.0,0.0,0.0});
		entity_set_vector(g_iDodgeBox, EV_VEC_angles, Float:{0.0,0.0,0.0});
		entity_set_int(g_iDodgeBox, EV_INT_movetype, MOVETYPE_NONE);
		entity_set_int(g_iDodgeGoals, EV_INT_solid, SOLID_BSP);
		g_bDodgeOn = false;
		TTT_Reset();
	}
}

public Fwd_Use_Button(this, caller, activator, use_type, Float:value)
{
	if (!g_bEnabled)
	{
		return HAM_IGNORED;
	}
	
	if (entity_get_float(this, EV_FL_nextthink) > 0.0) // Checks if button can be pressed again.
	{
		return HAM_IGNORED;
	}

	if ( g_iDodgeBoxBtn != 0 && g_iDodgeBox != 0 && this == g_iDodgeBoxBtn )
	{	
	
		if(g_bDodgeOn )
		{
			// Change button's target, because we don't want the bell sound when we turn off the Dodgebox
			entity_set_string(g_iDodgeBoxBtn, EV_SZ_target, DODGE_OFF);
			if( task_exists(DODGE_TASKID) )
			{
				remove_task(DODGE_TASKID);
			}
			g_bDodgeOn = false;
			entity_set_vector(g_iDodgeBox, EV_VEC_origin, g_vecDodgeBoxHideOrigin);
			entity_set_vector(g_iDodgeBox, EV_VEC_velocity, Float:{0.0,0.0,0.0});
			entity_set_vector(g_iDodgeBox, EV_VEC_avelocity, Float:{0.0,0.0,0.0});
			entity_set_int(g_iDodgeBox, EV_INT_movetype, MOVETYPE_NONE);
			if(g_iDodgeGoals != 0){
				ExecuteHamB(Ham_Use, g_iDodgeGoals, 0, 0, 0, 1.0);	
				entity_set_int(g_iDodgeGoals, EV_INT_solid, SOLID_BSP);
			}
			if(g_iDodgeWall != 0){
				ExecuteHamB(Ham_Use, g_iDodgeWall, 0, 0, 0, 1.0);	
			}
			
		}
		else
		{	
			new Float:tempOrigin[3];
			tempOrigin[0] = g_vecDodgeBoxDefOrigin[0];
			tempOrigin[1] = g_vecDodgeBoxDefOrigin[1];
			tempOrigin[2] = g_vecDodgeBoxDefOrigin[2] + 500.0;
			entity_set_vector(g_iDodgeBox, EV_VEC_origin, tempOrigin);
			entity_set_vector(g_iDodgeBox, EV_VEC_velocity, Float:{0.0,0.0,0.0});
			entity_set_int(g_iDodgeBox, EV_INT_movetype, MOVETYPE_TOSS);
			// Reset button's target.
			entity_set_string(g_iDodgeBoxBtn, EV_SZ_target, DODGE_ON);
			// Activate dodgebox 3 sec's later, when the bell sound is played.
			set_task(3.0, "Task_DodgeBox_on", DODGE_TASKID);
			if(g_iDodgeGoals != 0)
			{
				ExecuteHamB(Ham_Use, g_iDodgeGoals, 0, 0, 0, 0.0);	
				entity_set_int(g_iDodgeGoals, EV_INT_solid, SOLID_NOT); // To prevent players getting stuck in the goals
			}
			if(g_iDodgeWall != 0)
			{
				ExecuteHamB(Ham_Use, g_iDodgeWall, 0, 0, 0, 0.0);	
			}	
		}
		
		
	}
	else if( g_iTTTResetBtn != 0 && this == g_iTTTResetBtn)
	{
		TTT_Reset();
	}
	
	return HAM_IGNORED;
}

public Fwd_Use_Pushable(this, caller, activator, use_type, Float:value)
{
	if (!g_bEnabled || g_iDodgeBox == 0)
	{
		return HAM_IGNORED;
	}
	
	// We block the player from pushing the dodgebox with Use key.
	if ( this == g_iDodgeBox ) 
	{
		return HAM_SUPERCEDE;
	}
	
	return HAM_IGNORED;
}

public Fwd_Touch_Pushable(const entid, const id) 
{
	if(g_bEnabled && g_bDodgeOn && entid == g_iDodgeBox && is_user_connected(id))
	{
		fakedamage( id, "func_pushable", 800.0, DMG_CRUSH );
		
		// Explosion effect
		new Float:flOrigin[3];
		entity_get_vector(id, EV_VEC_origin, flOrigin);
		TE_Explosion(flOrigin, g_iExplosionSprite);
	}
	
}
public Fwd_Use_Wall(this, caller, activator, use_type, Float:value)
{
	if (g_bEnabled)
	{
		new szClsName[32];
		entity_get_string(this, EV_SZ_targetname, szClsName, charsmax(szClsName));
		if(use_type == 3 && contain(szClsName, TTT_WALLPRE) != -1) // use_type == 3 is on, use_type = 0 is off.
		{
			// Get position coord
			new iPos = str_to_num(szClsName[strlen(szClsName)-1]) - 1;

			new x = iPos % 3;
			new y = iPos / 3;
			
			// Get Player
			new chPlayer = szClsName[strlen(szClsName)-2];
			new player;
			if(chPlayer == 'a')
			{
				player = TTT_O;
			}
			else
			{
				player = TTT_X;
			}
#if defined DEBUG			
			log_amx("TTT Player %c - position: %d | %d (%d)", player == TTT_O ? 'O' : 'X', x, y, iPos);
#endif			
			new startent, endent;
			if(TTT_AddMove(x, y, player, this, startent, endent))
			{
				if(player == TTT_O)
				{
					TE_Laser(startent, endent, 15, 0, 75, 255);
				}
				else
				{
					TE_Laser(startent, endent, 15, 255, 0, 0);
				}
				emit_sound(g_iTTTResetBtn, CHAN_AUTO, "fvox/bell.wav", 1.0, ATTN_NORM, 0, PITCH_NORM);
			}
		}
	}
}

#if DODGE_HITABLE
public Fwd_Attack_Pushable(ent, attacker, Float:damage, Float:direction[3], trace, bits)
{
	if(g_bDodgeOn && g_iDodgeBox != 0 && ent == g_iDodgeBox)
	{
		new Float:vecVelocity[3], Float:vecPlayerAngles[3];
		entity_get_vector(g_iDodgeBox, EV_VEC_velocity, vecVelocity);
		entity_get_vector(attacker, EV_VEC_angles, vecPlayerAngles);
		vecVelocity[0] = floatcos( vecPlayerAngles[1], degrees ) * g_flSpeed;
		vecVelocity[1] = floatsin( vecPlayerAngles[1], degrees ) * g_flSpeed; 
		entity_set_vector(g_iDodgeBox, EV_VEC_velocity, vecVelocity);	
	}
}
#endif

public Task_DodgeBox_on()
{
	g_bDodgeOn = true;
	entity_set_int(g_iDodgeBox, EV_INT_movetype, MOVETYPE_BOUNCE);
	g_nTime = 0;
	g_flSpeed = DODGE_STARTSPEED;
	Task_DodgeBox();
}

public Task_DodgeBox() 
{
	// Increase speed if 10 seconds has passed.
	if (g_nTime == 5 && g_flSpeed < DODGE_MAXSPEED)
	{
		g_flSpeed += DODGE_SPEEDSTEP;
		g_nTime = 0;
	}
	
	// Randomizing
	new Float:flAngle, Float:vecVelocity[3], Float:vecRotation[3];
	flAngle = random_float(0.0, 360.0);
	vecRotation[1] = random_float(-360.0, 360.0);
	vecVelocity[0] = floatcos( flAngle, degrees ) * g_flSpeed;
	vecVelocity[1] = floatsin( flAngle, degrees ) * g_flSpeed; 
	entity_set_vector(g_iDodgeBox, EV_VEC_velocity, vecVelocity);	
	entity_set_vector(g_iDodgeBox, EV_VEC_avelocity, vecRotation);	
	
	g_nTime++;
	set_task(2.0, "Task_DodgeBox", DODGE_TASKID);
}

TTT_AddMove(x, y, player, ent, &retStartEnt, &retEndEnt){
	
	new startCoords[2], endCoords[2];
	g_iTTTBoard[x][y] = player;
	
	// We're storing both, X's and O's entities. Because then 
	// we can use them to hide the laser tempentity later.
	
	// Laser TE will disappear when we hide entities that it's attached to,
	// but will not disappear when the entities were already hidden.
	
	if(player == TTT_O && !g_iTTTOOriginEnts[x][y])
	{
		g_iTTTOOriginEnts[x][y] = ent;
	}
	else if (player == TTT_X && !g_iTTTXOriginEnts[x][y])
	{
		g_iTTTXOriginEnts[x][y] = ent;
	}
	
	if(g_bTTTEnded)
	{
		return false;
	}
	//check col
	for(new i; i < 3; i++)
	{
		if(g_iTTTBoard[i][y] != player)
			break;
		if(i == 2)
		{
			startCoords[0] = 0;
			startCoords[1] = y;
			endCoords[0] = 2;
			endCoords[1] = y;
			g_bTTTEnded = true;
		}
	}

	//check row
	for(new i; i < 3; i++)
	{
		if(g_iTTTBoard[x][i] != player)
			break;
		if(i == 2)
		{
			startCoords[0] = x;
			startCoords[1] = 0;
			endCoords[0] = x;
			endCoords[1] = 2;
			g_bTTTEnded = true;
		}
	}

	//check diag diagonal
	if(x == y)
	{
		for(new i; i < 3; i++)
		{
			if(g_iTTTBoard[i][i] != player)
				break;
			if(i == 2)
			{
				startCoords[0] = 0;
				startCoords[1] = 0;
				endCoords[0] = 2;
				endCoords[1] = 2;
				g_bTTTEnded = true;
			}
		}
	}

	//check anti diag
	for(new i; i < 3; i++)
	{
		if(g_iTTTBoard[2-i][i] != player)
			break;
		if(i == 2)
		{
			startCoords[0] = 2;
			startCoords[1] = 0;
			endCoords[0] = 0;
			endCoords[1] = 2;
			g_bTTTEnded = true;
		}
	}
	
	// If there is a winner, give start and end entities.
	if(g_bTTTEnded)
	{
		if(player == TTT_O)
		{
			retStartEnt = g_iTTTOOriginEnts[startCoords[0]][startCoords[1]];
			retEndEnt = g_iTTTOOriginEnts[endCoords[0]][endCoords[1]];
		}
		else 
		{
			retStartEnt = g_iTTTXOriginEnts[startCoords[0]][startCoords[1]];
			retEndEnt = g_iTTTXOriginEnts[endCoords[0]][endCoords[1]];
		}
		return true;
	}
	
	return false;
	
}

TTT_Reset()
{
	for(new x; x < 3; x++)
	{
		for(new y; y < 3; y++)
		{
			
			g_iTTTBoard[x][y] = TTT_BLANK;
		}
	}
	g_bTTTEnded = false;
	
#if defined DEBUG			
	log_amx("Tic Tac Toe Resetted.");
#endif	
}

TE_Laser(startent, endent, lifeSec, r, g, b){
#if defined DEBUG			
	log_amx("Creating laser: start entity %d, end entity %d", startent, endent);
#endif	
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY);
	write_byte(TE_BEAMENTS);
	write_short(startent);
	write_short(endent);
	write_short(g_iBeamSprite);
	write_byte(0);
	write_byte(10); 
	write_byte(lifeSec*10);
	write_byte(50);
	write_byte(0);
	write_byte(r);
	write_byte(g);
	write_byte(b);
	write_byte(150);
	write_byte(25);
	message_end();
}

TE_Explosion (Float:fvecOrigin[3], sprite)
{
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY);
	write_byte(TE_EXPLOSION);
	write_coord(floatround(fvecOrigin[0]));
	write_coord(floatround(fvecOrigin[1]));
	write_coord(floatround(fvecOrigin[2]));
	write_short(sprite);
	write_byte(30);
	write_byte(30);
	write_byte(0);
	message_end();
}

Util_SetRendering (iEntity, kRenderFx=kRenderFxNone, {Float,_}:fVecColor[3] = {0.0,0.0,0.0}, kRender=kRenderNormal, Float:flAmount=0.0) 
{ 
    set_pev(iEntity, pev_renderfx, kRenderFx); 
    set_pev(iEntity, pev_rendercolor, fVecColor); 
    set_pev(iEntity, pev_rendermode, kRender); 
    set_pev(iEntity, pev_renderamt, flAmount); 
}
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang1061\\ f0\\ fs16 \n\\ par }
*/
