/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <hamsandwich>
#include <jailbreak_core>
#include <fakemeta>
#include <engine>

#define PLUGIN "[JB] Valuables"
#define AUTHOR "Natsheh"

#define PEV_VALUABLE_PRICE pev_iuser3

#define IsPlayer(%1) (1 <= %1 <= MAX_PLAYERS)

enum any:VALUABLES_DATA(+=1)
{
    VALUABLE_CLASS[32],
    VALUABLE_MINIMUM_PRICE,
    VALUABLE_MAXIMUM_PRICE,
    Float:VALUABLE_ENTITY_SIZE[ 6 ]
}

enum any:CVAR_DATA(+=1)
{
    CVAR_NAME[32],
    CVAR_VALUE[32]
}

enum any:VALUABLES_TYPES(+=1)
{
    VALUABLE_MONEY_STACK = 0,
    VALUABLE_BRIEF_CASE,
    VALUABLE_GOLD_INGOT,
    VALUABLE_GOLD_INGOTS
}

new const g_szValuables_CLASSNAMES[][VALUABLES_DATA] = {
    { "Money stack", 5000, 10000, { -1.0, -1.0, -1.0, 1.0, 1.0, 5.0 } },
    { "Money Briefcase", 20000, 80000, { -1.0, -1.0, -1.0, 1.0, 1.0, 5.0 } },
    { "Gold ingot", 200000, 200000, { -1.0, -1.0, -1.0, 1.0, 1.0, 5.0 } },
    { "Gold ingots", 800000, 1000000, { -1.0, -1.0, -1.0, 1.0, 1.0, 5.0 } }
}

new const g_szValuables_dropchances_cvars[][CVAR_DATA] = {
    { "jb_moneystack_drop_chance", "4" },
    { "jb_moneybriefcase_drop_chance", "2" },
    { "jb_goldingot_drop_chance", "2" },
    { "jb_goldingots_drop_chance", "1" }
}

new g_szValuablesMODELS[sizeof g_szValuables_CLASSNAMES][64] = {
    "models/jailbreak/w_valuables.mdl",
    "models/jailbreak/w_valuables.mdl",
    "models/jailbreak/w_valuables.mdl",
    "models/jailbreak/w_valuables.mdl"
    },
    g_iValuableModelBody[sizeof g_szValuables_CLASSNAMES] = { '0', '1', '2', '3' };


new g_pcvar_one, g_pcvar_five, g_pcvar_six, g_pValuablesCVars[ sizeof g_szValuables_dropchances_cvars ];

public plugin_precache()
{
    new szKey[64], szText[16];

    for(new i, maxloop = sizeof g_szValuables_CLASSNAMES; i < maxloop; i++)
    {
        formatex(szKey, charsmax(szKey), "%s_MODEL", g_szValuables_CLASSNAMES[i]);
        replace(szKey, charsmax(szKey), " ", "_");
        strtoupper(szKey);

        jb_ini_get_keyvalue("VALUABLES", szKey, g_szValuablesMODELS[i], charsmax(g_szValuablesMODELS[]));
        PRECACHE_WORLD_ITEM(g_szValuablesMODELS[i]);

        szText[0] = g_iValuableModelBody[i]; szText[1] = EOS;
        add(szKey, charsmax(szKey), "_BODY");
        jb_ini_get_keyvalue("VALUABLES", szKey, szText, charsmax(szText));
        g_iValuableModelBody[i] = str_to_num(szText);
    }
}

public plugin_natives()
{
    register_native("jb_drop_valuable", "native_drop_valuable");
}

// native jb_drop_valuable(const Float:fLocation[3], VALUABLES_TYPES:iValuableType, const iAmount = 1, const iOwner = 0)
public native_drop_valuable(plugin, argc)
{
    new Float:fLocation[3], iValuableType = get_param(2), iAmount = get_param(3), iOwner = get_param(4),
    iValue = random_num(g_szValuables_CLASSNAMES[iValuableType][VALUABLE_MINIMUM_PRICE], g_szValuables_CLASSNAMES[iValuableType][VALUABLE_MAXIMUM_PRICE]);
    get_array_f(1, fLocation, 3);

    return drop_valuable(iOwner,
        fLocation,
        g_szValuables_CLASSNAMES[iValuableType][VALUABLE_CLASS],
        g_szValuablesMODELS[iValuableType],
        g_iValuableModelBody[iValuableType],
        iAmount,
        iValue,
        g_szValuables_CLASSNAMES[iValuableType][VALUABLE_ENTITY_SIZE]);
}

public plugin_init()
{
    register_plugin(PLUGIN, VERSION, AUTHOR)
    
    g_pcvar_one = register_cvar("jb_valuables_drop_amount", "1");

    for(new i, maxloop = sizeof g_szValuables_dropchances_cvars; i < maxloop; i++)
    {
        g_pValuablesCVars[ i ] = register_cvar(g_szValuables_dropchances_cvars[i][CVAR_NAME], g_szValuables_dropchances_cvars[i][CVAR_VALUE]);
    }

    g_pcvar_five = register_cvar("jb_valuables_dropinevents", "0");   // 1 - drop in lr & day events / 2 - lr only / 3 - day only;
    g_pcvar_six = register_cvar("jb_valuables_glow", "0");
    
    RegisterHam(Ham_Killed, "player", "fw_player_killed_post", true);
    
    for(new i, maxloop = sizeof g_szValuables_CLASSNAMES; i < maxloop; i++)
    {
        register_touch(g_szValuables_CLASSNAMES[i][VALUABLE_CLASS], "player", "fw_Touch_post");
    }
}

public fw_Touch_post(ent, id)
{
    if(!pev_valid(ent) || !is_user_alive(id) || (pev(ent, pev_flags) & FL_KILLME))
        return;
    
    money_taken(id, ent);
}

public fw_player_killed_post(iVictim, iKiller, shouldgib)
{
    if( iKiller == iVictim || !IsPlayer(iKiller)
        ) return;

    new iDay = jb_get_current_day(),
    iDuel = jb_get_current_duel();
    
    switch( get_pcvar_num(g_pcvar_five) )
    {
        case 0: if(iDay > DAY_NONE || iDuel > DUEL_NONE) return;
        case 2: if(iDay > DAY_NONE) return; 
        case 3: if(iDuel > DUEL_NONE) return;
    }

    static iChances[ 100 ], sizeOfCvars = sizeof g_szValuables_dropchances_cvars;
    arrayset(iChances, -1, sizeof iChances);

    for(new i, j, maxchance; i < sizeOfCvars; i++)
    {
        maxchance = min(get_pcvar_num(g_pValuablesCVars[i]) + j, 100);

        for( ; j < maxchance; j++ )
        {
            iChances[ j ] = i;
        }
    }

    SortIntegers(iChances, sizeof iChances, Sort_Random);

    new iTemp;
    if(iChances[(iTemp=random(100))] != -1)
    {
        new winner = iChances[iTemp], iValue, iVictimCash = jb_get_user_cash(iVictim),
        szVicName[32], Float:fOrigin[3], iMaxLOOPS = get_pcvar_num(g_pcvar_one);
        get_user_name(iVictim, szVicName, charsmax(szVicName));
        pev(iVictim, pev_origin, fOrigin);

        if(iMaxLOOPS > 0)
        {
            while( iMaxLOOPS-- )
            {
                if(winner != -1)
                {
                    iValue = random_num(g_szValuables_CLASSNAMES[winner][VALUABLE_MINIMUM_PRICE], g_szValuables_CLASSNAMES[winner][VALUABLE_MAXIMUM_PRICE]);

                    if(iValue <= iVictimCash)
                    {
                        if(drop_valuable(iVictim, fOrigin, g_szValuables_CLASSNAMES[winner][VALUABLE_CLASS], g_szValuablesMODELS[winner], g_iValuableModelBody[winner], _, iValue, g_szValuables_CLASSNAMES[winner][VALUABLE_ENTITY_SIZE]))
                        {
                            iVictimCash = jb_get_user_cash(iVictim) - iValue;
                            jb_set_user_cash(iVictim, iVictimCash);

                            log_to_file("jb_valuables.txt", "%s has dropped a valuable %s worth %d$", szVicName, g_szValuables_CLASSNAMES[winner][VALUABLE_CLASS], iValue);
                        }
                    }
                }

                winner = iChances[random(100)];
            }
        }
    }
}

money_taken(taker, ent)
{
    new szValuableClass[32], szName[32], szOwnerName[32], iAmount;
    pev(ent, pev_classname, szValuableClass, charsmax(szValuableClass));
    pev(ent, pev_netname, szOwnerName, charsmax(szOwnerName));
    jb_give_user_cash(taker, (iAmount=pev(ent, PEV_VALUABLE_PRICE)));

    // remove the entity safely.
    set_pev(ent, pev_flags, FL_KILLME);
    dllfunc(DLLFunc_Think, ent);

    get_user_name(taker, szName, charsmax(szName));
    jb_logmessage("'%s' has found a valuable '%s' which is worth '%d'$ belong to '%s'", szName, szValuableClass, iAmount, szOwnerName);
    log_to_file("jb_valuables.txt", "%s has picked a valuable %s worth %d$ belong to %s!", szName, szValuableClass, iAmount, szOwnerName);
}

drop_valuable(const owner, const Float:fOrigin[3], const szClassname[], const szModel[], const iModelbody, const iAmount=1, const iValue=100, const Float:flSize[6]={ -1.0, -1.0, -1.0, 1.0, 1.0, 1.0 })
{
    if(!iValue || !iAmount || pev(owner, pev_deadflag) == DEAD_NO) return 0;

    new szOwnerName[32], Float:fVelo[3], Float:fAngles[3], Float:fColor[3], Float:fHue = get_pcvar_float(g_pcvar_six), ent;
    get_user_name(owner, szOwnerName, charsmax(szOwnerName));

    for(new i, bool:bGlow = bool:(fHue > 0.0 && HSVtoRGB(fHue, 100.0, 100.0, fColor) != 0) ? true : false; i < iAmount; i++)
    {
        ent = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "info_target"));

        if(!ent)
        {
            log_error(AMX_ERR_GENERAL, "Failed to create a valuable entity classname ( %s ) value : '%d' owner : #%d.", szClassname, iValue, owner);
            continue;
        }

        set_pev(ent, pev_netname, szOwnerName);
        pev(ent, pev_angles, fAngles);
        fAngles[1] += random_float(1.0, 360.0);
        set_pev(ent, pev_origin, fOrigin);
        set_pev(ent, pev_angles, fAngles);
        set_pev(ent, pev_owner, owner);
        set_pev(ent, pev_body, iModelbody);
        set_pev(ent, pev_classname, szClassname);
        engfunc(EngFunc_SetModel, ent, szModel);
        set_pev(ent, pev_movetype, MOVETYPE_TOSS);
        set_pev(ent, pev_solid, SOLID_TRIGGER);
        engfunc(EngFunc_SetSize, ent, flSize, flSize[ 3 ]);

        set_pev(ent, PEV_VALUABLE_PRICE, iValue);

        fVelo[0] += random_float(-150.0, 150.0);
        fVelo[1] += random_float(-150.0, 150.0);
        fVelo[2] += random_float(100.0, 150.0);
        set_pev(ent, pev_velocity, fVelo);
        engfunc(EngFunc_DropToFloor, ent);

        if(bGlow == true)
        {
            set_pev(ent, pev_renderfx, kRenderFxGlowShell);
            set_pev(ent, pev_rendercolor, fColor);
            set_pev(ent, pev_renderamt, 20.0);
        }
    }

    return 1;
}

jb_give_user_cash(const id, iAmount)
{
    iAmount += jb_get_user_cash(id);
    jb_set_user_cash(id, iAmount);
    return iAmount;
}

stock Float: floatmod(Float: num, Float: denom)
{
    return num - denom * floatround(num / denom, floatround_floor);
}

stock Float: operator%(Float: oper1, Float: oper2)
{
    return floatmod(oper1, oper2);
}

HSVtoRGB(Float:H, Float:S, Float:V, Float:fColor_RGB[3]) {

    if(H>360.0 || H<0.0 || S>100.0 || S<0.0 || V>100.0 || V<0.0) {
        log_amx("The givem HSV values are not in valid range");
        return 0;
    }

    new Float:s = S / 100.0,
     Float:v = V / 100.0,
     Float:C = s * v,
     Float:X = ( C * ( 1.0 - floatabs( floatmod(( H / 60.0 ), 2.0) - 1.0 ) ) ),
     Float:m = v - C,
     Float:r, Float:g, Float:b;

    switch( floatround(H) )
    {
        case 0..60   : { r = C; g = X; b = 0.0; }
        case 61..120 : { r = X; g = C; b = 0.0; }
        case 121..180: { r = 0.0; g = C; b = X; }
        case 181..240: { r = 0.0; g = X; b = C; }
        case 241..300: { r = X; g = 0.0; b = C; }
        default: { r = C; g = 0.0; b = X; }
    }

    enum (+=1) {
        R = 0, G , B
    }

    fColor_RGB[ R ] = (r+m)*255.0;
    fColor_RGB[ G ] = (g+m)*255.0;
    fColor_RGB[ B ] = (b+m)*255.0;
    return 1;
}
