/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <nvault>
#include <hamsandwich>
#include <jailbreak_core>
#include <cs_player_models_api>
#include <fakemeta>

#define PLUGIN "[JB] Gang System"
#define AUTHOR "Natsheh"

#define MENU_KEYS	(MENU_KEY_0|MENU_KEY_1|MENU_KEY_2|MENU_KEY_3|MENU_KEY_4|MENU_KEY_5|MENU_KEY_6|MENU_KEY_7|MENU_KEY_8|MENU_KEY_9)

#define SHOW_TOP_GANGS	10

#define NO_ACCESS	(1<<26)

#define GANG_UPGRADE_KEY_NVAUTL(%1,%2,%3) formatex(%1,charsmax(%1),"%s_%s",%2,%3);

#if !defined EOS
#define EOS 0
#endif

new const gang_file[] = "jailbreak_gangs.ini";
new const gang_skins_file[] = "jailbreak_gang_skins.ini";

enum (+=1)
{
	NOT_INGANG = 0,
	GANG_MEMBER,
	GANG_LEADER,
	GANG_OWNER
}

new const USER_STATUS[][] = {
	"",
	"Member",
	"Leader",
	"Owner"
}

enum GANG_ACCESS(+=1)
{
	INFO_ACTION[24] = 0,
	INFO_ACCESS,
	INFO_POSITION
}

new const leadermenu_items[][GANG_ACCESS] = {
	{ "Add a leader!",	(1<<GANG_OWNER),	GANG_MEMBER },
	{ "Remove a leader!",	(1<<GANG_OWNER),	GANG_LEADER },
	{ "Kick a member!",	(1<<GANG_OWNER)|(1<<GANG_LEADER), GANG_MEMBER },
	{ "Transfer ownership", (1<<GANG_OWNER), 	GANG_LEADER }
}

enum (+=1)
{
	KEY_SKIN_MDL = 0,
	KEY_BODY_ID,
	KEY_SKIN_ID,
	KEY_SKIN_ACCESS
}

new const szKEYS[][] = {
	"SKIN",
	"BODY_ID",
	"SKIN_ID",
	"ACCESS"
}

enum _:UPGRADE_DATA (+=1)
{
	UPGRADE_NAME[32] = 0,
	UPGRADE_INFO[64],
	UPGRADE_FUNC_ID,
	UPGRADE_PLUGIN_ID,
	UPGRADE_MAX
}

enum USER_GANG_INFO(+=1)
{
	USER_GANG_NAME[32] = 0,
	USER_GANG_SKIN[32],
	USER_GANG_STATUS,
	USER_GANG_ID
}

enum _:GANGS_INFO(+=1)
{
	GANG_NAME[32] = 0,
	GANG_SKIN[32],
	GANG_KILLS,
	Array:GANG_ARRAY_MEMBERS,
	Trie:GANG_TRIE_MSTATUS,
	Trie:GANG_TRIE_NAMES
}

enum _:GANG_SKINS_INFO(+=1)
{
	GANG_SKIN_NAME[32] = 0,
	GANG_SKIN_MDL[32],
	GANG_SKIN_ACCESS,
	GANG_SKIN_BODY_ID,
	GANG_SKIN_ID
}

enum _:GANG_EDITION(+=1)
{
	EDIT_GANG_ID,
	EDIT_GANG_NAME[32]
}

new mm_itemid_gang;

new user_find_members[33][32], g_user_rejected_req[33], g_user_rejected_inv[33], g_userpage[33];
new g_user_ingang_creation, g_user_cant_create_agang, g_user_alive;

new gang_name_edition[33][GANG_EDITION], user_gang_data[33][USER_GANG_INFO];

new Array:garray_gangs, Array:garray_gang_skins, Array:g_array_upgrades, Trie:gtrie_gang_skin_mdls, Trie:gtrie_gang_maxslots, Array:g_array_gangmenu_exrta_items;

new g_cvar_gang_save_method, g_cvar_gang_cost, g_cvar_gang_skin_cost, g_msgStatusText, g_cvar_show_gang_info, cvar_maxmembers_slots, g_upgrades_nvault = INVALID_HANDLE;

new GANGS_FILE[64], GANG_SKINS_FILE[64];

new g_fwd_gang_creating, g_fwd_gang_created, g_fwd_gang_destroying, g_fwd_gang_destroyed, g_fwd_gang_user_leaving, g_fwd_gang_user_left,
g_fwd_gang_user_joining, g_fwd_gang_user_joined;

public plugin_end()
{
	for(new i, maxloop = ArraySize(garray_gangs), xArray[GANGS_INFO]; i < maxloop; i++)
	{
		ArrayGetArray(garray_gangs, i, xArray);
		ArrayDestroy( xArray[GANG_ARRAY_MEMBERS] );
		TrieDestroy( xArray[GANG_TRIE_MSTATUS] );
		TrieDestroy( xArray[GANG_TRIE_NAMES] );
	}

	ArrayDestroy(garray_gangs);
	ArrayDestroy(garray_gang_skins);
	ArrayDestroy(g_array_gangmenu_exrta_items);
	ArrayDestroy(g_array_upgrades);
	TrieDestroy(gtrie_gang_skin_mdls);
	TrieDestroy(gtrie_gang_maxslots);
	
	nvault_close(g_upgrades_nvault);
}

public plugin_precache()
{
	garray_gangs = ArrayCreate(GANGS_INFO, 1);
	garray_gang_skins = ArrayCreate(GANG_SKINS_INFO, 1);
	gtrie_gang_skin_mdls = TrieCreate();
	gtrie_gang_maxslots = TrieCreate();
	
	new sFile[64], fp;
	get_configsdir(sFile, charsmax(sFile));
	formatex(GANG_SKINS_FILE, charsmax(GANG_SKINS_FILE), "%s/%s", sFile, gang_skins_file);
	
	if(!file_exists(GANG_SKINS_FILE))
	{
		write_file(GANG_SKINS_FILE, "; [Very Important Prisoner]");
		write_file(GANG_SKINS_FILE, "; SKIN = ^"viprisoner^"");
		write_file(GANG_SKINS_FILE, "; BODY_ID = ^"0^"");
		write_file(GANG_SKINS_FILE, "; SKIN_ID = ^"0^"");
		write_file(GANG_SKINS_FILE, "; ACCESS = ^"abcdefghijklmnopqrstu^"^n");
	}
	else
	{
		fp = fopen(GANG_SKINS_FILE, "rt");
	}
	
	if(fp)
	{
		new xArray[GANG_SKINS_INFO], sBuffer[256], iItemIndex = -1, szKey[14], iKey;
		
		while( fgets(fp, sBuffer, charsmax(sBuffer)) > 0 )
		{
			trim(sBuffer);
			
			if(sBuffer[0] == EOS || sBuffer[0] == ';' || strlen(sBuffer) <= 3 || (sBuffer[0] == '/' && sBuffer[1] == '/'))
				continue;
			
			if(sBuffer[0] == '[')
			{
				iKey = 0;
				copyc(xArray[GANG_SKIN_NAME], charsmax(xArray[GANG_SKIN_NAME]), sBuffer[1], ']');
				iItemIndex = ArraySize(garray_gang_skins);
				ArrayPushArray(garray_gang_skins, xArray);
				continue;
			}
			
			if(xArray[GANG_SKIN_NAME][0] != EOS && iItemIndex > -1)
			{
				strtok(sBuffer, szKey, charsmax(szKey), sBuffer, charsmax(sBuffer), '=');
				trim(szKey);
				trim(sBuffer);
				remove_quotes(szKey);
				remove_quotes(sBuffer);
				
				if(equali(szKEYS[KEY_SKIN_MDL], szKey, strlen(szKey)) && !(iKey & (1<<KEY_SKIN_MDL)))
				{
					iKey |= (1<<KEY_SKIN_MDL);
					TrieSetString(gtrie_gang_skin_mdls, xArray[GANG_SKIN_NAME], sBuffer);
					formatex(xArray[GANG_SKIN_MDL], charsmax(xArray[GANG_SKIN_MDL]), sBuffer);
					ArraySetArray(garray_gang_skins, iItemIndex, xArray);
					
					formatex(sBuffer, charsmax(sBuffer), "models/player/%s/%s.mdl", xArray[GANG_SKIN_MDL], xArray[GANG_SKIN_MDL]);
					PRECACHE_PLAYER_MODEL(sBuffer);
					formatex(sBuffer, charsmax(sBuffer), "models/player/%s/%sT.mdl", xArray[GANG_SKIN_MDL], xArray[GANG_SKIN_MDL]);
					if(file_exists(sBuffer)) PRECACHE_PLAYER_MODEL(sBuffer);
					continue;
				}
				if(equali(szKEYS[KEY_SKIN_ACCESS], szKey, strlen(szKey)) && !(iKey & (1<<KEY_SKIN_ACCESS)))
				{
					iKey |= (1<<KEY_SKIN_ACCESS);
					xArray[GANG_SKIN_ACCESS] = read_flags(sBuffer);
					ArraySetArray(garray_gang_skins, iItemIndex, xArray);
					continue;
				}
				if(equali(szKEYS[KEY_BODY_ID], szKey, strlen(szKey)) && !(iKey & (1<<KEY_BODY_ID)))
				{
					iKey |= (1<<KEY_BODY_ID);
					xArray[GANG_SKIN_BODY_ID] = str_to_num(sBuffer);
					ArraySetArray(garray_gang_skins, iItemIndex, xArray);

					copy(szKey, charsmax(szKey), sBuffer);
					formatex(sBuffer, charsmax(sBuffer), "%s_BODY", xArray[GANG_SKIN_NAME]);
					TrieSetString(gtrie_gang_skin_mdls, sBuffer, szKey);
					continue;
				}
				if(equali(szKEYS[KEY_SKIN_ID], szKey, strlen(szKey)) && !(iKey & (1<<KEY_SKIN_ID)))
				{
					iKey |= (1<<KEY_SKIN_ID);
					xArray[GANG_SKIN_ID] = str_to_num(sBuffer);
					ArraySetArray(garray_gang_skins, iItemIndex, xArray);

					copy(szKey, charsmax(szKey), sBuffer);
					formatex(sBuffer, charsmax(sBuffer), "%s_SKIN", xArray[GANG_SKIN_NAME]);
					TrieSetString(gtrie_gang_skin_mdls, sBuffer, szKey);
					continue;
				}
			}
		}
		fclose(fp);
	}
	
	fp = 0;
	get_configsdir(sFile, charsmax(sFile));
	formatex(GANGS_FILE, charsmax(GANGS_FILE), "%s/%s", sFile, gang_file);
	
	if(!file_exists(GANGS_FILE))
	{
		write_file(GANGS_FILE, "; [Gang name] ^"Gang Skin^"");
		write_file(GANGS_FILE, "; ^"Member Steamid^" ^"Member ingang status^" ^"Member nickname^"^n");
	}
	else
	{
		fp = fopen(GANGS_FILE, "rt");
	}
	
	if(fp)
	{
		new xArray[GANGS_INFO], sBuffer[256], szAuthid[32], szGangStatus[8], szName[32];
		
		while( fgets(fp, sBuffer, charsmax(sBuffer)) > 0 )
		{
			trim(sBuffer);
			
			if(sBuffer[0] == EOS || sBuffer[0] == ';' || strlen(sBuffer) <= 3 || (sBuffer[0] == '/' && sBuffer[1] == '/'))
				continue;
			
			if(sBuffer[0] == '[')
			{
				copyc(xArray[GANG_NAME], charsmax(xArray[GANG_NAME]), sBuffer[1], ']');
				
				strtok(sBuffer, "", 0, sBuffer, charsmax(sBuffer), ']');
				parse(sBuffer, szName, charsmax(szName), sBuffer, charsmax(sBuffer));
				remove_quotes(szName);
				remove_quotes(sBuffer);
				
				xArray[GANG_KILLS] = str_to_num(sBuffer);
				copy(xArray[GANG_SKIN], charsmax(xArray[GANG_SKIN]), szName);
				
				xArray[GANG_ARRAY_MEMBERS] = _:ArrayCreate(32,1);
				xArray[GANG_TRIE_MSTATUS] = _:TrieCreate();
				xArray[GANG_TRIE_NAMES] = _:TrieCreate();
				
				ArrayPushArray(garray_gangs, xArray);
				continue;
			}
			
			if(xArray[GANG_NAME][0] != EOS)
			{
				if(parse(sBuffer, szAuthid, charsmax(szAuthid), szGangStatus, charsmax(szGangStatus), szName, charsmax(szName)) == 3)
				{
					ArrayPushString(xArray[GANG_ARRAY_MEMBERS], szAuthid);
					TrieSetString(xArray[GANG_TRIE_MSTATUS], szAuthid, szGangStatus)
					TrieSetString(xArray[GANG_TRIE_NAMES], szAuthid, szName)
				}
			}
		}
		fclose(fp);
	}
}

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	g_cvar_gang_save_method = register_cvar("jb_gang_sys_save_method", "steamid");
	g_cvar_gang_cost = register_cvar("jb_gang_creating_cost", "100000");
	g_cvar_gang_skin_cost = register_cvar("jb_gang_skin_cost", "20000");
	g_cvar_show_gang_info = register_cvar("jb_gang_show_info_len", "0");
	
	mm_itemid_gang = register_jailbreak_mmitem("MAIN_MENU_ITEM_GANG", _, TEAM_ANY)
	
	register_event("StatusValue", "fw_statusvalue_target", "bce", "1=2", "2>0");
	register_event("StatusValue", "fw_statusvalue_notarget", "bce", "1=2", "2=0");
	
	register_menucmd(register_menuid("GANG_MAIN_MENU"), MENU_KEYS, "gang_mainmenu_handler")
	
	register_clcmd("enter_gang_name", "clcmd_enter_gang_name")
	register_clcmd("search_for", "clcmd_search_for")
	
	RegisterHam(Ham_Spawn, "player", "fw_player_respawn_post", 1)
	RegisterHam(Ham_Killed, "player", "fw_player_killed_post", 1)
	
	register_clcmd("amx_gangsmenu", "clcmd_gangsmenu", ADMIN_ALL|ADMIN_IMMUNITY, "show all gangs");
	register_clcmd("jb_gangsmenu", "clcmd_gangsmenu", ADMIN_ALL|ADMIN_IMMUNITY, "show all gangs");
	
	cvar_maxmembers_slots = register_cvar("jb_gang_max_memberslots", "5");
	
	g_msgStatusText = get_user_msgid("StatusText");
	
	g_fwd_gang_creating = CreateMultiForward("jb_gang_creating", ET_CONTINUE, FP_STRING, FP_STRING, FP_STRING);
	g_fwd_gang_created = CreateMultiForward("jb_gang_created", ET_IGNORE, FP_STRING, FP_STRING, FP_STRING);
	g_fwd_gang_destroying = CreateMultiForward("jb_gang_destroying", ET_CONTINUE, FP_CELL, FP_STRING);
	g_fwd_gang_destroyed = CreateMultiForward("jb_gang_destroyed", ET_IGNORE, FP_CELL, FP_STRING);
	
	g_fwd_gang_user_leaving = CreateMultiForward("jb_gang_user_leaving", ET_CONTINUE, FP_CELL, FP_STRING, FP_STRING, FP_CELL);
	g_fwd_gang_user_left = CreateMultiForward("jb_gang_user_left", ET_IGNORE, FP_CELL, FP_STRING, FP_STRING, FP_CELL);
	g_fwd_gang_user_joining = CreateMultiForward("jb_gang_user_joining", ET_CONTINUE, FP_CELL, FP_STRING, FP_STRING, FP_CELL);
	g_fwd_gang_user_joined = CreateMultiForward("jb_gang_user_joined", ET_IGNORE, FP_CELL, FP_STRING, FP_STRING, FP_CELL);
}

public plugin_cfg()
{
	new maxslots = get_pcvar_num(cvar_maxmembers_slots);
	
	for(new i, maxloop = ArraySize(garray_gangs), xArray[GANGS_INFO]; i < maxloop; i++)
	{
		ArrayGetArray(garray_gangs, i, xArray);
		TrieSetCell(gtrie_gang_maxslots, xArray[GANG_NAME], maxslots);
	}
	
	g_upgrades_nvault = nvault_open("jb_gang_upgrades");
	if(g_upgrades_nvault == INVALID_HANDLE) set_fail_state("Error opening nvault!");
}

public fw_statusvalue_target(id)
{
	static iTarget;
	iTarget = read_data(2);

	if( (32 >= iTarget >= 1) && user_gang_data[iTarget][USER_GANG_STATUS] != NOT_INGANG && check_flag(g_user_alive,iTarget) ) 
	{
		if(get_user_team(id) == TEAM_PRISONERS && get_user_team(iTarget) == TEAM_PRISONERS)
		{
			show_gang_info(id, iTarget, get_pcvar_num(g_cvar_show_gang_info));
		}
	}
}

public fw_statusvalue_notarget(id)
{
	if(get_user_team(id) == TEAM_PRISONERS)
	{
		show_gang_info(id, id, get_pcvar_num(g_cvar_show_gang_info));
	}
	else{
		show_gang_info(id, 0, 0);
	}
}

public clcmd_gangsmenu(id, level, cid)
{
	if(!cmd_access(id, level, cid, 1))
		return PLUGIN_HANDLED;
	
	new total_gangs;
	if(!(total_gangs=ArraySize(garray_gangs)))
	{
		console_print(id, "No gangs were found!")
		return PLUGIN_HANDLED;
	}

	new szText[64];
	formatex(szText, charsmax(szText), "%L", LANG_PLAYER, "GANG_PANEL_MENU_TITLE");
	new menu = menu_create(szText, "gangsmenu_handler", true);
	
	for(new i, szGangID[10], xArray[GANGS_INFO]; i < total_gangs; i++)
	{
		ArrayGetArray(garray_gangs, i, xArray);
		num_to_str(i, szGangID, charsmax(szGangID));
		menu_additem(menu, xArray[GANG_NAME], szGangID);
	}
	
	menu_display(id, menu);
	return PLUGIN_HANDLED;
}

public gangsmenu_handler(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu)
		return PLUGIN_HANDLED;
	}
	
	new paccess, callback, sData[10];
	menu_item_getinfo(menu, item, paccess, sData, charsmax(sData), "", 0, callback)
	menu_destroy(menu);
	
	apanel_gang_info(id, str_to_num(sData));
	return PLUGIN_HANDLED;
}

apanel_gang_info(id, gangid)
{
	new sText[256], xArray[GANGS_INFO], szOwner[32];
	ArrayGetArray(garray_gangs, gangid, xArray);
	
	gang_name_edition[id][EDIT_GANG_ID] = gangid;
	formatex(gang_name_edition[id][EDIT_GANG_NAME], charsmax(gang_name_edition[][EDIT_GANG_NAME]), xArray[GANG_NAME]);
	
	// seeking for the gang owner name...
	for(new i, szStatus[8], maxloop = ArraySize(xArray[GANG_ARRAY_MEMBERS]); i < maxloop; i++)
	{
		ArrayGetString(xArray[GANG_ARRAY_MEMBERS], i, szOwner, charsmax(szOwner))
		TrieGetString(xArray[GANG_TRIE_MSTATUS], szOwner, szStatus, charsmax(szStatus))
		if(equali(USER_STATUS[GANG_OWNER], szStatus))
		{
			break;
		}
	}

	static szChar[2] = { EOS, EOS };
	if(szChar[0] == EOS)
	{
		get_pcvar_string(g_cvar_gang_save_method, szChar, charsmax(szChar));
		switch( szChar[0] )
		{
			case 's', 'S', 'a', 'A' : szChar[0] = 'c';
			case 'I', 'i' : szChar[0] = 'd';
			case 'n', 'N' : szChar[0] = 'a';
		}
	}
	
	new iOwner; // getting the owner name;
	if((iOwner = find_player(szChar, szOwner)) > 0)
	{
		get_user_name(iOwner, szOwner, charsmax(szOwner));
	}
	else
	{
		TrieGetString(xArray[GANG_TRIE_NAMES], szOwner, szOwner, charsmax(szOwner))
	}
	
	formatex(sText, charsmax(sText), "\
	\y-=[\rGANG INFORMATION\y]=-\
	^n\rGANG-NAME: \y%s^n\
	\rGANG-SKIN: \y%s^n\
	\rGANG-OWNER: \y%s^n\
	\rGANG-MEMBERS: \y%d^n\
	\rGANG-KILLS: \y%d",
	xArray[GANG_NAME], xArray[GANG_SKIN], szOwner, ArraySize(xArray[GANG_ARRAY_MEMBERS]), xArray[GANG_KILLS])
	new menu = menu_create(sText, "apanel_handler")
	
	new szGangID[10]; num_to_str(gangid, szGangID, charsmax(szGangID));
	menu_additem(menu, "Delete the Gang!", szGangID)
	menu_additem(menu, "Reset Gang Kills!", szGangID)
	menu_additem(menu, "Reset Gang Upgrades!", szGangID)
	
	menu_setprop(menu, MPROP_EXITNAME, "Back");
	menu_display(id, menu)
}

public apanel_handler(id, menu, item, iPage)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu);
		if(is_user_connected(id)) client_cmd(id, "amx_gangsmenu");
		return PLUGIN_HANDLED;
	}
	
	new sData[10], paccess, callback;
	
	menu_item_getinfo(menu, item, paccess, sData, charsmax(sData), "", 0, callback);
	menu_destroy(menu);
	
	new iGangID = str_to_num(sData), xArray[GANGS_INFO];
	
	if((0 <= iGangID < ArraySize(garray_gangs)))
	{
		ArrayGetArray(garray_gangs, iGangID, xArray);
	}
	
	if(!equal(gang_name_edition[id][EDIT_GANG_NAME], xArray[GANG_NAME]))
	{
		cprint_chat(id, _, "The !g%s !ygang is not !texisted!g!", gang_name_edition[id][EDIT_GANG_NAME])
		return PLUGIN_HANDLED;
	}
	
	new szAdminName[32], sBuffer[128];
	get_user_name(id, szAdminName, charsmax(szAdminName))
	
	switch( item )
	{
		case 0:
		{
			if(destroy_thegang(iGangID, xArray[GANG_NAME]) == PLUGIN_CONTINUE)
			{
				
				cprint_chat(0, _, "!gADMIN !t%s !yhas deleted the !g%s !tGang!y.", szAdminName, xArray[GANG_NAME]);
				
				formatex(sBuffer, charsmax(sBuffer), "ADMIN %s HAS DELETED THE %s GANG", szAdminName, xArray[GANG_NAME])
				log_amx(sBuffer)
				
				formatex(sBuffer, charsmax(sBuffer), "HAS DELETED THE '%s' GANG", xArray[GANG_NAME])
				jb_logmessage_action(sBuffer, id);
			}
			else
			{
				apanel_gang_info(id, iGangID);
			}

		}
		case 1:
		{
			if(set_gang_kills(iGangID, xArray[GANG_NAME], 0) == PLUGIN_CONTINUE)
			{
				cprint_chat(0, _, "!gAdmin !t%s !yhas reset the !g%s !tGang kills!y.", szAdminName, xArray[GANG_NAME])
				formatex(sBuffer, charsmax(sBuffer), "ADMIN %s HAS RESET THE %s GANG KILLS", szAdminName, xArray[GANG_NAME])
				log_amx(sBuffer);
				
				formatex(sBuffer, charsmax(sBuffer), "Has reset the '%s' gang kills!", xArray[GANG_NAME]);
				jb_logmessage_action(sBuffer, id);
			}
			else
			{
				apanel_gang_info(id, iGangID);
			}
		}
		case 2:
		{
			if(reset_gang_upgrades_menu(id,xArray[GANG_NAME]) >= PLUGIN_HANDLED)
			{
				apanel_gang_info(id, iGangID);
			}
		}
	}
	return PLUGIN_HANDLED;
}

reset_gang_upgrades_menu(id, const gangname[], const iPage=0)
{
	new maxloop = ArraySize(g_array_upgrades)
	if(!maxloop)
	{
		return PLUGIN_HANDLED;
	}
	
	new sBuffer[196], iItems;
	formatex(sBuffer, charsmax(sBuffer), "%L", id, "ADMIN_PANEL_RESET_UPG_TITLE");
	new Xmenu = menu_create(sBuffer, "apanel_reset_upg_handle", true);
	
	for(new xArray[UPGRADE_DATA], szValue[16], szKey[72], iCurUpgrade, iX, i; i < maxloop; i++)
	{
		ArrayGetArray(g_array_upgrades, i, xArray);
		if(xArray[UPGRADE_MAX] <= 0) continue;

		formatex(sBuffer, charsmax(sBuffer), xArray[UPGRADE_NAME]);
		strtoupper(sBuffer);
		GANG_UPGRADE_KEY_NVAUTL(szKey,gangname,sBuffer)
		iCurUpgrade = 0;
		if(nvault_lookup(g_upgrades_nvault, szKey, szValue, charsmax(szValue), iX) > 0)
		{
			iCurUpgrade = min(str_to_num(szValue), xArray[UPGRADE_MAX]);
		}
		formatex(sBuffer, charsmax(sBuffer), "%s   %d/%d", xArray[UPGRADE_NAME], iCurUpgrade, xArray[UPGRADE_MAX]);
		menu_additem(Xmenu, sBuffer, xArray[UPGRADE_NAME]);
		iItems++;
	}
	
	if(!iItems)
	{
		menu_destroy(Xmenu);
		return PLUGIN_HANDLED;
	}

	menu_display(id, Xmenu, iPage);
	return PLUGIN_CONTINUE;
}

set_gang_kills(iGangID, const gangname[], const iGangKills=0)
{
	new fp = fopen(GANGS_FILE, "rt");
	
	if(!fp)
	{
		log_error(AMX_ERR_GENERAL, "failed to create a file '%s'", GANGS_FILE);
		return PLUGIN_HANDLED;
	}

	new sFile2[128];
	formatex(sFile2, charsmax(sFile2), "%s2", GANGS_FILE);
	new fp2 = fopen(sFile2, "wt");

	if(!fp2)
	{
		log_error(AMX_ERR_GENERAL, "failed to create a file '%s'", sFile2);
		return PLUGIN_HANDLED;
	}
	
	new sBuffer[256], xArray[GANGS_INFO];
	ArrayGetArray(garray_gangs, iGangID, xArray);
	fseek(fp, 0, SEEK_SET);
	while( fgets(fp, sBuffer, charsmax(sBuffer)) > 0 )
	{
		trim(sBuffer);
		
		if(sBuffer[0] == EOS || sBuffer[0] == ';' || strlen(sBuffer) <= 3 || (sBuffer[0] == '/' && sBuffer[1] == '/'))
		{
			fputs(fp2, sBuffer);
			fputc(fp2, '^n');
			continue;
		}
		
		if(sBuffer[0] == '[')
		{
			copyc(xArray[GANG_NAME], charsmax(xArray[GANG_NAME]), sBuffer[1], ']')
			if(equal(xArray[GANG_NAME], gangname))
			{
				formatex(sBuffer, charsmax(sBuffer), "[%s] ^"%s^" ^"%d^"", gangname, xArray[GANG_SKIN], iGangKills)
				xArray[GANG_KILLS] = iGangKills;
				ArraySetArray(garray_gangs, iGangID, xArray);
			}
		}
		
		fputs(fp2, sBuffer);
		fputc(fp2, '^n');
	}
	fclose(fp);
	fclose(fp2);
	
	delete_file(GANGS_FILE);
	
	if(!rename_file(sFile2, GANGS_FILE, 1))
	{
		delete_file(sFile2);
	}
	
	return PLUGIN_CONTINUE;
}

destroy_thegang(iGangID, const gangname[])
{
	new fw_return;
	ExecuteForward(g_fwd_gang_destroying, fw_return, iGangID, gangname);
	
	if(fw_return >= JB_HANDLED)
	{
		return PLUGIN_HANDLED;
	}
	
	new fp = fopen(GANGS_FILE, "rt");
	
	if(!fp)
	{
		log_error(AMX_ERR_GENERAL, "Failed to create a file '%s'", GANGS_FILE);
		return PLUGIN_HANDLED;
	}

	new sFile2[128], fp2;
	formatex(sFile2, charsmax(sFile2), "%s2", GANGS_FILE);
	fp2 = fopen(sFile2, "wt");
	
	if(!fp2)
	{
		log_error(AMX_ERR_GENERAL, "Failed to create a file '%s'", sFile2);
		return PLUGIN_HANDLED;
	}
	
	new sBuffer[256], szGangname[32], bool:bRemoval=false;
	fseek(fp, 0, SEEK_SET);
	while( fgets(fp, sBuffer, charsmax(sBuffer)) > 0 )
	{
		trim(sBuffer);
		
		if(sBuffer[0] == EOS || sBuffer[0] == ';' || strlen(sBuffer) <= 3 || (sBuffer[0] == '/' && sBuffer[1] == '/'))
		{
			fputs(fp2, sBuffer);
			fputc(fp2, '^n');
			continue;
		}
		
		if(sBuffer[0] == '[')
		{
			bRemoval = false;
			
			copyc(szGangname, charsmax(szGangname), sBuffer[1], ']');
			if(equal(szGangname, gangname))
			{
				bRemoval = true;
			}
		}
		
		if(bRemoval)
		{
			format(sBuffer, charsmax(sBuffer), "; %s", sBuffer);
			fputs(fp2, sBuffer);
			fputc(fp2, '^n');
			continue;
		}
		
		fputs(fp2, sBuffer);
		fputc(fp2, '^n');
	}
	fclose(fp);
	fclose(fp2);
	
	delete_file(GANGS_FILE);
	
	if(!rename_file(sFile2, GANGS_FILE, 1))
	{
		delete_file(sFile2);
	}
	
	new xArray[GANGS_INFO], GangsCount = ArraySize(garray_gangs);
	ArrayGetArray(garray_gangs, iGangID, xArray);
	ArrayDestroy(xArray[GANG_ARRAY_MEMBERS]);
	TrieDestroy(xArray[GANG_TRIE_MSTATUS]);
	TrieDestroy(xArray[GANG_TRIE_NAMES]);

	if( (--GangsCount) == iGangID )
	{
		ArrayDeleteItem(garray_gangs, iGangID);
	}
	else if( GangsCount )
	{
		ArrayGetArray(garray_gangs, GangsCount, xArray);
		ArraySetArray(garray_gangs, iGangID, xArray);
	}
	
	new players[32], pnum;
	get_players(players, pnum, "ch");
	
	for(new i, szAuthid[32], player; i < pnum; i++)
	{
		player = players[i];
		
		if(equal(gangname, user_gang_data[player][USER_GANG_NAME]))
		{
			get_user_identity(player, szAuthid, charsmax(szAuthid));
			ExecuteForward(g_fwd_gang_user_left, fw_return, iGangID, gangname, szAuthid, user_gang_data[player][USER_GANG_STATUS]);
			user_gang_data[player][USER_GANG_STATUS] = NOT_INGANG;
			user_gang_data[player][USER_GANG_ID] = -1;
			user_gang_data[player][USER_GANG_NAME][0] = EOS;
			user_gang_data[player][USER_GANG_SKIN][0] = EOS;
		}
		else if(user_gang_data[player][USER_GANG_ID] == GangsCount)
		{ // Updating player new gang id.
			user_gang_data[player][USER_GANG_ID] = iGangID;
		}
	}
	
	ExecuteForward(g_fwd_gang_destroyed, fw_return, iGangID, gangname);
	return PLUGIN_CONTINUE;
}

public apanel_reset_upg_handle(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	new iNull, szKey[72], szUpgradeItem[32];
	menu_item_getinfo(menu, item, iNull, szUpgradeItem, charsmax(szUpgradeItem), "", 0, iNull);
	
	new iMenu, iNewmenu, iPage;
	player_menu_info(id, iMenu, iNewmenu, iPage);
	menu_destroy(menu);
	
	new szAdminName[32], szTemp[32];
	get_user_name(id, szAdminName, charsmax(szAdminName));
	copy(szTemp, charsmax(szTemp), szUpgradeItem);
	strtoupper(szTemp);
	
	GANG_UPGRADE_KEY_NVAUTL(szKey,gang_name_edition[id][EDIT_GANG_NAME],szTemp)
	nvault_remove(g_upgrades_nvault, szKey);
	cprint_chat(0, _, "!gAdmin !t%s !yhas reset the !g%s !tGang upgrade: %s!y.", szAdminName, gang_name_edition[id][EDIT_GANG_NAME], szUpgradeItem)
	
	new sBuffer[128];
	formatex(sBuffer, charsmax(sBuffer), "ADMIN '%s' HAS RESET THE '%s' GANG UPGRADE: '%s'", szAdminName, gang_name_edition[id][EDIT_GANG_NAME], szUpgradeItem)
	log_amx(sBuffer);
	jb_logmessage(sBuffer);
	
	reset_gang_upgrades_menu(id, gang_name_edition[id][EDIT_GANG_NAME], iPage)
	return PLUGIN_HANDLED;
}

public fw_player_killed_post(victim, attacker, shouldgib)
{
	// attacker is connected and its not a suicide and the victim is not from the gang...
	if(!is_user_connected(attacker) || victim == attacker) return;
	
	static killer_gang; killer_gang = user_gang_data[attacker][USER_GANG_ID];
	if(killer_gang != user_gang_data[victim][USER_GANG_ID] &&
		  user_gang_data[attacker][USER_GANG_STATUS] != NOT_INGANG)
	{
		static xArray[GANGS_INFO];
		ArrayGetArray(garray_gangs, killer_gang, xArray);
		xArray[GANG_KILLS] ++;
		ArraySetArray(garray_gangs, killer_gang, xArray);
		
		static fp, fp2, sFile2[128];
		fp = fopen(GANGS_FILE, "rt");
		
		if(!fp)
		{
			log_error(AMX_ERR_GENERAL, "Failed to create a file '%s'", GANGS_FILE);
			return;
		}

		formatex(sFile2, charsmax(sFile2), "%s2", GANGS_FILE);
		fp2 = fopen(sFile2, "wt");

		if(!fp2)
		{
			fclose(fp);
			log_error(AMX_ERR_GENERAL, "Failed to create a file '%s'", sFile2);
			return;
		}
		
		static sBuffer[196], szGangname[32];
		
		fseek(fp, 0, SEEK_SET);
		while( fgets(fp, sBuffer, charsmax(sBuffer)) > 0 )
		{
			trim(sBuffer);
			
			if(sBuffer[0] == EOS || sBuffer[0] == ';' || strlen(sBuffer) <= 3 || (sBuffer[0] == '/' && sBuffer[1] == '/'))
			{
				fprintf(fp2, sBuffer);
				fputc(fp2, '^n');
				continue;
			}
			
			if(sBuffer[0] == '[')
			{
				copyc(szGangname, charsmax(szGangname), sBuffer[1], ']');
				if(equal(szGangname, xArray[GANG_NAME]))
				{
					formatex(sBuffer, charsmax(sBuffer), "[%s] ^"%s^" ^"%d^"", xArray[GANG_NAME], xArray[GANG_SKIN], xArray[GANG_KILLS]);
				}
			}
			
			fputs(fp2, sBuffer);
			fputc(fp2, '^n');
		}
		fclose(fp);
		fclose(fp2);
		
		delete_file(GANGS_FILE);
		
		if(!rename_file(sFile2, GANGS_FILE, 1)) delete_file(sFile2);
	}
}

public fw_player_respawn_post(id)
{
	if(!is_user_alive(id)) return;
	
	set_flag(g_user_alive,id);
	
	if(user_gang_data[id][USER_GANG_STATUS] == NOT_INGANG || get_user_team(id) != TEAM_PRISONERS)
	{
		return;
	}
	
	new sString[64];
	copy(sString, charsmax(sString), user_gang_data[id][USER_GANG_SKIN]);
	if(sString[0] != EOS && !equali(sString, "None"))
	{
		new szModel[32], szValue[4], iBody, iSkin;
		TrieGetString(gtrie_gang_skin_mdls, sString, szModel, charsmax(szModel));

		add(sString, charsmax(sString), "_BODY");
		TrieGetString(gtrie_gang_skin_mdls, sString, szValue, charsmax(szValue));
		iBody = str_to_num(szValue);

		// removing _BODY from sString.
		sString[ strlen(sString) - 5 ] = EOS;
		add(sString, charsmax(sString), "_SKIN");
		TrieGetString(gtrie_gang_skin_mdls, sString, szValue, charsmax(szValue));
		iSkin = str_to_num(szValue);

		cs_set_player_model(id, szModel);
		set_pev(id, pev_body, iBody);
		set_pev(id, pev_skin, iSkin);
	}

	// Show user Gang Info :)
	show_gang_info(id, id, get_pcvar_num(g_cvar_show_gang_info));
}

enum _:EXTRA_ITEMS_DATA (+=1)
{
	EXTRA_ITEM_NAME[32] = 0,
	EXTRA_ITEM_PRESELECT_FUNCID,
	EXTRA_ITEM_ONSELECT_FUNCID,
	EXTRA_ITEM_PLUGINID
}

public plugin_natives()
{
	g_array_gangmenu_exrta_items = ArrayCreate(EXTRA_ITEMS_DATA, 1);
	g_array_upgrades = ArrayCreate(UPGRADE_DATA, 1);
	
	register_native("jb_gang_menu_additem", "_gang_menu_additem");
	
	register_native("jb_get_user_gang_status", "_get_user_gang_status");
	register_native("jb_get_user_gang_name", "_get_user_gang_name");
	register_native("jb_get_user_gang_kills", "_get_user_gang_kills");
	register_native("jb_set_user_gang", "_set_user_gang");
	register_native("jb_remove_user_fromgang", "_remove_user_fromgang");
	register_native("jb_set_gang_maxslots", "_set_gang_maxslots")
	register_native("jb_get_gang_maxslots", "_get_gang_maxslots")
	register_native("jb_register_gang_upgrade", "_register_gang_upgrade");
	register_native("jb_get_gang_current_upg_level", "_get_gang_current_upg_level");
	register_native("jb_set_gang_item_upg_level", "_set_gang_item_upg_level");
	register_native("jb_show_user_gang_menu", "_show_user_gang_menu");
}

// native jb_gang_menu_additem(const itemname[], const onitemadd_func[], const onselect_func[])
public _gang_menu_additem(plugin, argc)
{
	new xArray[EXTRA_ITEMS_DATA], szItemname[32], szFunc[2][32];
	
	get_string(1, szItemname, charsmax(szItemname));
	get_string(2, szFunc[0], charsmax(szFunc[]));
	get_string(3, szFunc[1], charsmax(szFunc[]));
	
	copy(xArray[EXTRA_ITEM_NAME], charsmax(xArray[EXTRA_ITEM_NAME]), szItemname);
	xArray[EXTRA_ITEM_PRESELECT_FUNCID] = szFunc[0][0] == EOS ? -1 : get_func_id(szFunc[0], plugin);
	xArray[EXTRA_ITEM_ONSELECT_FUNCID] = szFunc[1][0] == EOS ? -1 : get_func_id(szFunc[1], plugin);
	xArray[EXTRA_ITEM_PLUGINID] = plugin;
	
	ArrayPushArray(g_array_gangmenu_exrta_items, xArray);
	return (ArraySize(g_array_gangmenu_exrta_items) - 1);
}

// native jb_set_gang_item_upg_level(const gangname[], const upgrade_item[], const upg_level)
public _set_gang_item_upg_level(plugin, argc)
{
	new szKey[72], szGangname[32], szUpgradeItem[32], szValue[16];
	get_string(1, szGangname, charsmax(szGangname));
	get_string(2, szUpgradeItem, charsmax(szUpgradeItem));
	strtoupper(szUpgradeItem);
	GANG_UPGRADE_KEY_NVAUTL(szKey,szGangname,szUpgradeItem)
	
	num_to_str(get_param(3), szValue, charsmax(szValue));
	nvault_set(g_upgrades_nvault, szKey, szValue);
}

// native jb_get_gang_current_upg_level(const upgrade_item[], const gangname[])
public _get_gang_current_upg_level(plugin, argc)
{
	new szGangname[32];
	get_string(2, szGangname, charsmax(szGangname));
	
	new szUpgradeItem[32], szValue[16], szKey[72], iTime;
	get_string(1, szUpgradeItem, charsmax(szUpgradeItem));
	strtoupper(szUpgradeItem);
	GANG_UPGRADE_KEY_NVAUTL(szKey,szGangname,szUpgradeItem)
	if(!nvault_lookup(g_upgrades_nvault, szKey, szValue, charsmax(szValue), iTime)) return 0;
	return str_to_num(szValue);
}

// const function_upgrade[] < const id, const gangid, const gangname[], CurrentUpgrade, MaxUpgrade, Upgrade_Index >
// native jb_register_gang_upgrade(const skill_name[], const skill_info[], const max_upgrade, const function_upgrade[])
public _register_gang_upgrade(plugin, argc)
{
	new xArray[UPGRADE_DATA], UpgradeFunction[32];
	get_string(1, xArray[UPGRADE_NAME], charsmax(xArray[UPGRADE_NAME]));
	get_string(2, xArray[UPGRADE_INFO], charsmax(xArray[UPGRADE_INFO]));
	xArray[UPGRADE_MAX] = get_param(3);
	get_string(4, UpgradeFunction, charsmax(UpgradeFunction));
	
	xArray[UPGRADE_FUNC_ID] = get_func_id(UpgradeFunction, plugin);
	xArray[UPGRADE_PLUGIN_ID] = plugin;
	
	ArrayPushArray(g_array_upgrades, xArray);
	return (ArraySize(g_array_upgrades) - 1);
}

public _set_gang_maxslots(plugin, argc)
{
	new iGangID = get_param(1);

	if(!(0 <= iGangID < ArraySize(garray_gangs)))
	{
		log_error(AMX_ERR_NATIVE, "Invalid GANG ID #%d !", iGangID);
		return;
	}

	new xArray[GANGS_INFO];
	ArrayGetArray(garray_gangs, iGangID, xArray);
	TrieSetCell(gtrie_gang_maxslots, xArray[GANG_NAME], get_param(2));
}

public _get_gang_maxslots(plugin, argc)
{
	new iGangID = get_param(1);

	if(!(0 <= iGangID < ArraySize(garray_gangs)))
	{
		log_error(AMX_ERR_NATIVE, "Invalid GANG ID #%d !", iGangID);
		return -1;
	}

	new xArray[GANGS_INFO], iValue;
	ArrayGetArray(garray_gangs, iGangID, xArray);
	TrieGetCell(gtrie_gang_maxslots, xArray[GANG_NAME], iValue);
	return iValue;
}

public _get_user_gang_kills(plugin, argc)
{
	new id = get_param(1);

	if(!is_user_connected(id))
	{
		log_error(AMX_ERR_NATIVE, "Invalid player #%d id or player is not connected!", id);
		return -1;
	}

	new iGangID = user_gang_data[id][USER_GANG_ID];

	if(!(0 <= iGangID < ArraySize(garray_gangs)))
	{
		log_error(AMX_ERR_NATIVE, "Invalid player GANG ID #%d !", iGangID);
		return -1;
	}

	new xArray[GANGS_INFO];
	ArrayGetArray(garray_gangs, iGangID, xArray);
	return xArray[GANG_KILLS];
}

public _get_user_gang_status(plugin, argc)
{
	new id = get_param(1);

	if(!is_user_connected(id))
	{
		log_error(AMX_ERR_NATIVE, "Invalid player #%d id or player is not connected!", id);
		return -1;
	}

	return user_gang_data[id][USER_GANG_STATUS];
}

public _get_user_gang_name(plugin, argc)
{
	new id = get_param(1);

	if(!is_user_connected(id))
	{
		log_error(AMX_ERR_NATIVE, "Invalid player #%d id or player is not connected!", id);
		return;
	}

	set_string(2, user_gang_data[id][USER_GANG_NAME], get_param(3));
}

public _set_user_gang(plugin, argc)
{
	new szAuthid[32];
	get_string(1, szAuthid, charsmax(szAuthid));
	set_user_gang(szAuthid, get_param(2), get_param(3));
}

public _remove_user_fromgang(plugin, argc)
{
	new szAuthid[32];
	get_string(1, szAuthid, charsmax(szAuthid));
	remove_user_fromgang(szAuthid, get_param(2));
}

public _show_user_gang_menu(plugin, argc)
{
	new id = get_param(1);
	if(!is_user_connected(id))
	{
		log_error(AMX_ERR_NATIVE, "Invalid player index #%d is not connected!", id);
		return 0;
	}

	g_userpage[id] = 0;
	gang_mainmenu(id, 0);
	return 1;
}

public client_authorized(id)
{
	load_user_gang(id);
	
	g_user_rejected_inv[id] = 0;
	g_user_rejected_req[id] = 0;
}

#if AMXX_VERSION_NUM > 182
public client_disconnected(id)
#else
public client_disconnect(id)
#endif
{
	remove_flag(g_user_alive,id);
}

load_user_gang(id)
{
	user_gang_data[id][USER_GANG_STATUS] = NOT_INGANG;
	user_gang_data[id][USER_GANG_ID] = -1;
	user_gang_data[id][USER_GANG_NAME][0] = EOS;
	user_gang_data[id][USER_GANG_SKIN][0] = EOS;
	
	new xArray[GANGS_INFO], szAuthid[32];
	get_user_identity(id, szAuthid, charsmax(szAuthid));
	for(new i, maxloop = ArraySize(garray_gangs); i < maxloop; i++)
	{
		ArrayGetArray(garray_gangs, i, xArray);
		if(TrieKeyExists(xArray[GANG_TRIE_MSTATUS], szAuthid))
		{
			new szStatus[10];
			TrieGetString(xArray[GANG_TRIE_MSTATUS], szAuthid, szStatus, charsmax(szStatus));
			user_gang_data[id][USER_GANG_ID] = i;
			copy(user_gang_data[id][USER_GANG_NAME], charsmax(user_gang_data[][USER_GANG_NAME]), xArray[GANG_NAME]);
			copy(user_gang_data[id][USER_GANG_SKIN], charsmax(user_gang_data[][USER_GANG_SKIN]), xArray[GANG_SKIN]);
			
			switch( szStatus[0] )
			{
				case 'm','M': user_gang_data[id][USER_GANG_STATUS] = GANG_MEMBER;
				case 'o','O': user_gang_data[id][USER_GANG_STATUS] = GANG_OWNER;
				case 'l','L': user_gang_data[id][USER_GANG_STATUS] = GANG_LEADER;
			}
			
			break;
		}
	}
}

set_user_gang(const szAuthid[], gang, status)
{
	new xArray[GANGS_INFO], fw_return;
	ArrayGetArray(garray_gangs, gang, xArray);
	ExecuteForward(g_fwd_gang_user_joining, fw_return, gang, xArray[GANG_NAME], szAuthid, status)
	
	if(fw_return >= JB_HANDLED)
	{
		return PLUGIN_HANDLED;
	}
	
	new szName[32];
	if(TrieKeyExists(xArray[GANG_TRIE_NAMES],szAuthid))
	{
		TrieGetString(xArray[GANG_TRIE_NAMES], szAuthid, szName, charsmax(szName))
	}
	
	static szChar[2] = { EOS, EOS };
	if(szChar[0] == EOS)
	{
		get_pcvar_string(g_cvar_gang_save_method, szChar, charsmax(szChar));
		switch( szChar[0] )
		{
			case 's', 'S', 'a', 'A' : szChar[0] = 'c';
			case 'I', 'i' : szChar[0] = 'd';
			case 'n', 'N' : szChar[0] = 'a';
		}
	}

	new id = find_player(szChar, szAuthid);
	if(id > 0) get_user_name(id, szName, charsmax(szName));
	
	remove_user_fromgang(szAuthid, gang);
	
	new fp = fopen(GANGS_FILE, "rt");

	if(!fp) {
		return PLUGIN_HANDLED;
	}

	new sFile2[128], fp2;
	formatex(sFile2, charsmax(sFile2), "%s2", GANGS_FILE);
	fp2 = fopen(sFile2, "wt");

	if(!fp2) {
		return PLUGIN_HANDLED;
	}

	new szGangname[32], sBuffer[256];
	
	while( fgets(fp, sBuffer, charsmax(sBuffer)) > 0 )
	{
		trim(sBuffer);
		
		if(sBuffer[0] == EOS || 
		       sBuffer[0] == ';' || 
		         (sBuffer[0] == '/' && sBuffer[1] == '/') || 
			    strlen(sBuffer) <= 3)
		{
			fputs(fp2, sBuffer);
			fputc(fp2, '^n');
			continue;
		}
		
		if(sBuffer[0] == '[')
		{
			copyc(szGangname, charsmax(szGangname), sBuffer[1], ']');
			
			if(equal(szGangname, xArray[GANG_NAME]))
			{
				format(sBuffer, charsmax(sBuffer), "%s^n\
				^"%s^" ^"%s^" ^"%s^"", sBuffer, szAuthid, USER_STATUS[status], szName);
				
				ArrayPushString(xArray[GANG_ARRAY_MEMBERS], szAuthid);
				TrieSetString(xArray[GANG_TRIE_NAMES], szAuthid, szName);
				TrieSetString(xArray[GANG_TRIE_MSTATUS], szAuthid, USER_STATUS[status]);
				if(id > 0)
				{
					user_gang_data[id][USER_GANG_ID] = gang;
					copy(user_gang_data[id][USER_GANG_NAME], charsmax(user_gang_data[][USER_GANG_NAME]), xArray[GANG_NAME]);
					copy(user_gang_data[id][USER_GANG_SKIN], charsmax(user_gang_data[][USER_GANG_SKIN]), xArray[GANG_SKIN]);
					user_gang_data[id][USER_GANG_STATUS] = status;
					show_gang_info(id, id, get_pcvar_num(g_cvar_show_gang_info));
				}
			}
		}
		
		fputs(fp2, sBuffer);
		fputc(fp2, '^n');
	}
	fclose(fp);
	fclose(fp2);
	
	delete_file(GANGS_FILE)
	
	if(!rename_file(sFile2, GANGS_FILE, 1))
	{
		delete_file(sFile2);
	}
	
	ExecuteForward(g_fwd_gang_user_joined, fw_return, gang, xArray[GANG_NAME], szAuthid, status);
	return PLUGIN_CONTINUE;
}

remove_user_fromgang(const szAuthid[], gangid)
{
	new xArray[GANGS_INFO], fw_return, status[10];
	ArrayGetArray(garray_gangs, gangid, xArray);
	ExecuteForward(g_fwd_gang_user_leaving, fw_return, gangid, xArray[GANG_NAME], szAuthid, get_gang_status_id(status))
	
	if(fw_return >= JB_HANDLED)
	{
		return PLUGIN_HANDLED;
	}
	
	new fp = fopen(GANGS_FILE, "rt");
	
	if(!fp) {
		return PLUGIN_HANDLED;
	}

	new sFile2[128], fp2;
	formatex(sFile2, charsmax(sFile2), "%s2", GANGS_FILE);
	fp2 = fopen(sFile2, "wt");
	
	if(!fp2) {
		return PLUGIN_HANDLED;
	}
	
	new szAuthid2[32], sBuffer[256];
	
	while( fgets(fp, sBuffer, charsmax(sBuffer)) > 0 )
	{
		trim(sBuffer);
		
		if(sBuffer[0] == EOS || 
		       sBuffer[0] == ';' || 
		         (sBuffer[0] == '/' && sBuffer[1] == '/') || 
			    strlen(sBuffer) <= 3)
		{
			fputs(fp2, sBuffer);
			fputc(fp2, '^n');
			continue;
		}
		
		parse(sBuffer, szAuthid2, charsmax(szAuthid2));
		remove_quotes(szAuthid2);
		
		if(equal(szAuthid2, szAuthid))
		{
			format(sBuffer, charsmax(sBuffer), "; %s", sBuffer);
		}
		
		fputs(fp2, sBuffer);
		fputc(fp2, '^n');
	}
	fclose(fp);
	fclose(fp2);
	
	delete_file(GANGS_FILE)
	
	if(!rename_file(sFile2, GANGS_FILE, 1))
	{
		delete_file(sFile2);
	}
	
	for(new i, szString[32], maxloop = ArraySize(xArray[GANG_ARRAY_MEMBERS]); i < maxloop; i++)
	{
		ArrayGetString(xArray[GANG_ARRAY_MEMBERS], i, szString, charsmax(szString))
		if(equal(szString, szAuthid))
		{
			ArrayDeleteItem(xArray[GANG_ARRAY_MEMBERS], i);
			break;
		}
	}
	
	TrieDeleteKey(xArray[GANG_TRIE_NAMES], szAuthid);
	TrieDeleteKey(xArray[GANG_TRIE_MSTATUS], szAuthid);
	
	static szChar[2] = { EOS, EOS };
	if(szChar[0] == EOS)
	{
		get_pcvar_string(g_cvar_gang_save_method, szChar, charsmax(szChar));
		switch( szChar[0] )
		{
			case 's', 'S', 'a', 'A' : szChar[0] = 'c';
			case 'I', 'i' : szChar[0] = 'd';
			case 'n', 'N' : szChar[0] = 'a';
		}
	}

	new id;
	if((id=find_player(szChar,szAuthid)) > 0)
	{
		user_gang_data[id][USER_GANG_ID] = -1;
		user_gang_data[id][USER_GANG_NAME][0] = EOS;
		user_gang_data[id][USER_GANG_SKIN][0] = EOS;
		user_gang_data[id][USER_GANG_STATUS] = NOT_INGANG;
		show_gang_info(id, id, 0);
	}
	
	ExecuteForward(g_fwd_gang_user_left, fw_return, gangid, xArray[GANG_NAME], szAuthid, get_gang_status_id(status));
	return PLUGIN_CONTINUE;
}

public clcmd_search_for(id)
{
	if(user_gang_data[id][USER_GANG_STATUS] == NOT_INGANG) return PLUGIN_HANDLED;
	
	new sString[32];
	read_args(sString, charsmax(sString))
	remove_quotes(sString)
	
	formatex(user_find_members[id], charsmax(user_find_members[]), sString);
	gang_members_menu(id, g_userpage[id])
	return PLUGIN_HANDLED;
}

public clcmd_enter_gang_name(id)
{
	if(!(check_flag(g_user_ingang_creation,id)) || user_gang_data[id][USER_GANG_STATUS] != NOT_INGANG)
	{
		return PLUGIN_HANDLED;
	}
	
	new sString[32];
	read_args(sString, charsmax(sString));
	remove_quotes(sString);
	
	if(strlen(sString) <= 3)
	{
		formatex(user_gang_data[id][USER_GANG_NAME], charsmax(user_gang_data[][USER_GANG_NAME]), "Gang name is too short!");
		set_flag(g_user_cant_create_agang,id);
		gang_creation(id);
		return PLUGIN_HANDLED;
	}
	
	for(new i, xArray[GANGS_INFO], maxloop = ArraySize(garray_gangs); i < maxloop; i++)
	{
		ArrayGetArray(garray_gangs, i, xArray);
		if(equali(xArray[GANG_NAME], sString))
		{
			formatex(user_gang_data[id][USER_GANG_NAME], charsmax(user_gang_data[][USER_GANG_NAME]), "Gang name is not valid!")
			set_flag(g_user_cant_create_agang,id)
			gang_creation(id);
			return PLUGIN_HANDLED;
		}
	}
	
	remove_flag(g_user_cant_create_agang,id);
	formatex(user_gang_data[id][USER_GANG_NAME], charsmax(user_gang_data[][USER_GANG_NAME]), sString);
	gang_creation(id);
	return PLUGIN_HANDLED;
}

show_gang_info(id, target, len)
{
	if(user_gang_data[target][USER_GANG_STATUS] == NOT_INGANG)
	{
		message_begin(MSG_ONE_UNRELIABLE, g_msgStatusText, {0,0,0}, id);
		write_byte(0);
		write_string("");
		message_end();
		return;
	}
	
	new xArray[GANGS_INFO], sString[196];
	ArrayGetArray(garray_gangs, user_gang_data[target][USER_GANG_ID], xArray);
	
	formatex(sString, charsmax(sString), "%s of %s.",
		USER_STATUS[user_gang_data[target][USER_GANG_STATUS]], xArray[GANG_NAME]);
	message_begin(MSG_ONE_UNRELIABLE, g_msgStatusText, {0,0,0}, id);
	write_byte(len);
	write_string(sString);
	message_end();
}

public jb_mm_itemselected(id, itemid)
{
	if(itemid == mm_itemid_gang)
	{
		g_userpage[id] = 0;
		gang_mainmenu(id, 0);
	}
}

public gang_mainmenu(id, page)
{
	new sMenu[512], iLen, iKeys, UserGangStatus;
	
	if((UserGangStatus=user_gang_data[id][USER_GANG_STATUS]) == NOT_INGANG)
	{
		iLen = formatex(sMenu, charsmax(sMenu), "%L", LANG_PLAYER, "GANG_MENU_GANGSTATUS");
		
		if(jb_get_user_cash(id) > get_pcvar_num(g_cvar_gang_cost))
		{
			iKeys |= MENU_KEY_1;
			iLen += formatex(sMenu[iLen], charsmax(sMenu)-iLen, "%L", LANG_PLAYER, "GANG_MENU_CREATEGANG", get_pcvar_num(g_cvar_gang_cost))
		}
		else
			iLen += formatex(sMenu[iLen], charsmax(sMenu)-iLen, "%L", LANG_PLAYER, "GANG_MENU_CREATEGANG_F", get_pcvar_num(g_cvar_gang_cost))
		
		iKeys |= MENU_KEY_3;
		iLen += formatex(sMenu[iLen], charsmax(sMenu)-iLen, "%L", LANG_PLAYER, "GANG_MENU_JOINGANG");
	}
	else
	{
		const GANG_MENU_PER_PAGE = 6;
		const FirstPage = 0;
		
		new iSizeArray, iStart = max(page - 1,0) * GANG_MENU_PER_PAGE;
		new iEnd = min(page * GANG_MENU_PER_PAGE, (iSizeArray=ArraySize(g_array_gangmenu_exrta_items)));
		
		iLen = formatex(sMenu, charsmax(sMenu), "%L", LANG_PLAYER, "GANG_MENU_INGANGSTATUS",
			user_gang_data[id][USER_GANG_NAME], USER_STATUS[user_gang_data[id][USER_GANG_STATUS]]);
		
		
		if( page == FirstPage )
		{
			if(user_gang_data[id][USER_GANG_STATUS] > GANG_MEMBER)
			{
				iKeys |= MENU_KEY_1;
				iLen += formatex(sMenu[iLen], charsmax(sMenu)-iLen, "%L", LANG_PLAYER, "GANG_MENU_MANAGING");
			}
			else iLen += formatex(sMenu[iLen], charsmax(sMenu)-iLen, "%L", LANG_PLAYER, "GANG_MENU_MANAGING_F");
			
			iKeys |= MENU_KEY_2;
			iLen += formatex(sMenu[iLen], charsmax(sMenu)-iLen, "%L", LANG_PLAYER, "GANG_MENU_INVITE");
			
			iKeys |= MENU_KEY_3;
			iLen += formatex(sMenu[iLen], charsmax(sMenu)-iLen, "%L", LANG_PLAYER, "GANG_MENU_MEMBERS");
			
			iKeys |= MENU_KEY_5;
			iLen += formatex(sMenu[iLen], charsmax(sMenu)-iLen, "%L", LANG_PLAYER, "GANG_MENU_LEAVEGANG");
		} 
		else if( page > FirstPage )
		{
			for(new xArray[EXTRA_ITEMS_DATA], i = iStart; i < iEnd; i++)
			{
				ArrayGetArray(g_array_gangmenu_exrta_items, i, xArray);
				
				if(xArray[EXTRA_ITEM_PRESELECT_FUNCID] > -1)
				{
					if( callfunc_begin_i(xArray[EXTRA_ITEM_PRESELECT_FUNCID], xArray[EXTRA_ITEM_PLUGINID]) == 1 )
					{
						callfunc_push_int(id);
						callfunc_push_int(user_gang_data[id][USER_GANG_ID]);
						callfunc_push_str(user_gang_data[id][USER_GANG_NAME],false);
						callfunc_push_str(xArray[EXTRA_ITEM_NAME],true);
						if(callfunc_end() == PLUGIN_HANDLED)
						{
							continue;
						}
					}
				}
				
				iKeys |= (1<<(i%GANG_MENU_PER_PAGE));
				iLen += formatex(sMenu[iLen], charsmax(sMenu)-iLen, "%d. %L^n", ((i - iStart) + 1), LANG_SERVER, xArray[EXTRA_ITEM_NAME]);
			}
		}
		
		if(page > FirstPage)
		{
			iKeys |= MENU_KEY_5;
			iLen += formatex(sMenu[iLen], charsmax(sMenu)-iLen, "%L", LANG_PLAYER, "GANG_MENU_BACK"); // E5.Back
		}
		
		if(iEnd < iSizeArray)
		{
			iKeys |= MENU_KEY_6;
			iLen += formatex(sMenu[iLen], charsmax(sMenu)-iLen, "%L", LANG_PLAYER, "GANG_MENU_NEXT"); // E6.Next
		}
	}
	
	iKeys |= MENU_KEY_7;
	iLen += formatex(sMenu[iLen], charsmax(sMenu)-iLen, "%L", LANG_PLAYER, "GANG_MENU_AVAILABLEGANGS");
	
	iKeys |= MENU_KEY_8;
	iLen += formatex(sMenu[iLen], charsmax(sMenu)-iLen, "%L", LANG_PLAYER, "GANG_MENU_TOPGANGS", SHOW_TOP_GANGS)
	
	if(UserGangStatus != NOT_INGANG)
	{
		iKeys |= MENU_KEY_0;
		iLen += formatex(sMenu[iLen], charsmax(sMenu)-iLen, "%L", LANG_PLAYER, "GANG_MENU_UPGRADES");
	}
	
	iKeys |= MENU_KEY_1;
	iLen += formatex(sMenu[iLen], charsmax(sMenu)-iLen, "%L", LANG_PLAYER, "GANG_MENU_EXIT");
	
	show_menu(id, iKeys, sMenu, _, "GANG_MAIN_MENU")
}

public gang_mainmenu_handler(id, key)
{
	const FirstPage = 0;
	const GANG_MENU_PER_PAGE = 6;
	
	new bool:bUseKey = ((pev(id, pev_button) & IN_USE) > 0) ? true:false;
	new bool:bUserInGang = (user_gang_data[id][USER_GANG_STATUS] == NOT_INGANG) ? false:true;
	
	if( bUserInGang && g_userpage[id] > FirstPage && (GANG_MENU_PER_PAGE > key >= 0) && !bUseKey )
	{
		new xArray[EXTRA_ITEMS_DATA], iItem = (g_userpage[id] - 1) * GANG_MENU_PER_PAGE + key;
		ArrayGetArray(g_array_gangmenu_exrta_items, iItem, xArray);

		if(xArray[EXTRA_ITEM_ONSELECT_FUNCID] > -1)
		{
			if( callfunc_begin_i(xArray[EXTRA_ITEM_ONSELECT_FUNCID], xArray[EXTRA_ITEM_PLUGINID]) == 1 )
			{
				callfunc_push_int(id);
				callfunc_push_int(user_gang_data[id][USER_GANG_ID]);
				callfunc_push_str(user_gang_data[id][USER_GANG_NAME],false);
				callfunc_push_str(xArray[EXTRA_ITEM_NAME],false);
				if(callfunc_end() == PLUGIN_HANDLED)
				{
					return PLUGIN_HANDLED;
				}
			}
		}

		gang_mainmenu(id, g_userpage[id]);
		return PLUGIN_HANDLED;
	}

	switch( key )
	{
		case 0: // key number 1
		{
			// Menu Exit
			if(bUseKey)
			{
				return PLUGIN_HANDLED;
			}
			
			if(bUserInGang)
			{
				leader_menu(id, 0);
			}
			else
			{
				formatex(user_gang_data[id][USER_GANG_SKIN], charsmax(user_gang_data[][USER_GANG_SKIN]), "None");
				formatex(user_gang_data[id][USER_GANG_NAME], charsmax(user_gang_data[][USER_GANG_NAME]), "Type in your gang name!");
				set_flag(g_user_cant_create_agang,id);
				gang_creation(id);
			}
			
			return PLUGIN_HANDLED;
		}
		case 1: // key number 2
		{
			invite_gang_menu(id);
			return PLUGIN_HANDLED;
		}
		case 2: // key number 3
		{
			if(bUserInGang)
			{
				g_userpage[id] = 0;
				formatex(user_find_members[id], charsmax(user_find_members[]), "");
				gang_members_menu(id, 0);
			}
			else
			{
				join_gang_menu(id);
			}
			
			return PLUGIN_HANDLED;
		}
		case 3: // key number 4
		{
			
		}
		case 4: // key number 5
		{
			if(bUseKey) // previous page
			{
				g_userpage[id] = max(--g_userpage[id],FirstPage);
				gang_mainmenu(id, g_userpage[id]);
				return PLUGIN_HANDLED;
			}
			
			confirmation_menu(id, "Are you sure you want to \rleave the gang!?", "player_left_gang")
			return PLUGIN_HANDLED;
		}
		case 5: // key number 6
		{
			if(bUseKey)
			{
				g_userpage[id] = min(++g_userpage[id],((ArraySize(g_array_gangmenu_exrta_items) + GANG_MENU_PER_PAGE) / GANG_MENU_PER_PAGE));
			}
		}
		case 6: // key number 7
		{
			g_userpage[id] = 0;
			available_gangmenu(id, 0);
			return PLUGIN_HANDLED;
		}
		case 7: // key number 8
		{
			show_top_gangs(id);
			return PLUGIN_HANDLED;
		}
		case 9: // key number 0
		{
			gangmenu_upgrades(id);
			return PLUGIN_HANDLED;
		}
	}
	
	gang_mainmenu(id, g_userpage[id]);
	return PLUGIN_HANDLED;
}

gangmenu_upgrades(id, page=0)
{
	if(user_gang_data[id][USER_GANG_STATUS] == NOT_INGANG)
	{
		return;
	}
	
	new maxloop = ArraySize(g_array_upgrades);
	
	if(!maxloop)
	{
		gang_mainmenu(id, g_userpage[id]);
		cprint_chat(id, _, "%L", LANG_PLAYER, "CHAT_GANG_MENU_NO_UPGRADES");
		return;
	}
	
	new menu, szText[196];
	
	formatex(szText, charsmax(szText), "Upgrades!");
	menu = menu_create(szText, "gangmenu_upg_handle", true);
	
	for(new xArray[UPGRADE_DATA], szValue[16], null, szKey[72], iCurUpgrade, sInfo[2], i; i < maxloop; i++)
	{
		ArrayGetArray(g_array_upgrades, i, xArray);
		sInfo[0] = i;

		if(xArray[UPGRADE_MAX] > 0)
		{
			copy(szText, charsmax(szText), xArray[UPGRADE_NAME]);
			strtoupper(szText);
			GANG_UPGRADE_KEY_NVAUTL(szKey,user_gang_data[id][USER_GANG_NAME],szText)
			iCurUpgrade = 0;
			if(nvault_lookup(g_upgrades_nvault, szKey, szValue, charsmax(szValue), null) > 0)
			{
				iCurUpgrade = min(str_to_num(szValue), xArray[UPGRADE_MAX]);
			}
			formatex(szText, charsmax(szText), "%L", LANG_SERVER, "GANG_UPGRADE_MENU_ITEM", xArray[UPGRADE_NAME], xArray[UPGRADE_INFO], iCurUpgrade, xArray[UPGRADE_MAX]);
		}
		else
		{
			formatex(szText, charsmax(szText), "%L", LANG_SERVER, "GANG_UPGRADE_MENU_SUBITEM", xArray[UPGRADE_NAME], xArray[UPGRADE_INFO]);
		}

		menu_additem(menu, szText, sInfo);
	}
	
	menu_setprop(menu, MPROP_PERPAGE, 5);
	menu_display(id, menu, page);
}

public gangmenu_upg_handle(id, menu, item)
{
	if(item == MENU_EXIT || user_gang_data[id][USER_GANG_STATUS] == NOT_INGANG)
	{
		menu_destroy(menu);
		if(is_user_connected(id)) gang_mainmenu(id, g_userpage[id]);
		return PLUGIN_HANDLED;
	}
	new iNull, szData[2], xArray[UPGRADE_DATA];
	menu_item_getinfo(menu, item, iNull, szData, charsmax(szData), "", 0, iNull);
	
	new iMenu, iNewmenu, iPage;
	player_menu_info(id, iMenu, iNewmenu, iPage);
	menu_destroy(menu);
	
	iNull = szData[0];
	ArrayGetArray(g_array_upgrades, iNull, xArray);
	
	if(xArray[UPGRADE_MAX] <= 0)
	{
		// const function_upgrade[] < const id, const gangid, const gangname[], Upgrade_Index >
		if(callfunc_begin_i(xArray[UPGRADE_FUNC_ID], xArray[UPGRADE_PLUGIN_ID]) == 1)
		{
			callfunc_push_int(id);
			callfunc_push_int(user_gang_data[id][USER_GANG_ID]);
			callfunc_push_str(user_gang_data[id][USER_GANG_NAME]);
			callfunc_push_int(iNull);
			callfunc_end();
		}

		return PLUGIN_HANDLED;
	}

	new szKey[72], szValue[16], z;
	strtoupper(xArray[UPGRADE_NAME]);
	GANG_UPGRADE_KEY_NVAUTL(szKey,user_gang_data[id][USER_GANG_NAME],xArray[UPGRADE_NAME])
	num_to_str(min((z=nvault_get(g_upgrades_nvault, szKey)) + 1, xArray[UPGRADE_MAX]), szValue, charsmax(szValue));
	
	// const function_upgrade[] < const id, const gangid, const gangname[], CurrentUpgrade, maxupgrade, Upgrade_Index >
	if(callfunc_begin_i(xArray[UPGRADE_FUNC_ID], xArray[UPGRADE_PLUGIN_ID]) == 1)
	{
		callfunc_push_int(id);
		callfunc_push_int(user_gang_data[id][USER_GANG_ID]);
		callfunc_push_str(user_gang_data[id][USER_GANG_NAME]);
		callfunc_push_int(z);
		callfunc_push_int(xArray[UPGRADE_MAX]);
		callfunc_push_int(iNull);
		if(callfunc_end() == PLUGIN_CONTINUE)
		{
			nvault_set(g_upgrades_nvault, szKey, szValue);
			gangmenu_upgrades(id,iPage);
		}
	}
	
	return PLUGIN_HANDLED;
}

show_top_gangs(id)
{
	new maxloop = ArraySize(garray_gangs);
	if(!maxloop)
	{
		cprint_chat(id, _, "There're no gangs available yet!")
		return;
	}
	
	new Array:array_topgangs = ArrayCreate(GANGS_INFO,1), xArray[GANGS_INFO], count = SHOW_TOP_GANGS;
	
	if(maxloop < SHOW_TOP_GANGS) count = maxloop;
	
	for(new i; i < maxloop; i++)
	{
		ArrayGetArray(garray_gangs, i, xArray);
		ArrayPushArray(array_topgangs, xArray);
	}
	
	ArraySort(array_topgangs, "SortTopGangs");
	
	new sBuffer[1536], iLen;
	
	iLen = formatex(sBuffer, charsmax(sBuffer), "<html><head><style>.TITLES {color:black;font-size:8pt;font-weight:600;text-align:center;vertical-align:middle;background:#EFC929;}")
	iLen += formatex(sBuffer[iLen], charsmax(sBuffer)-iLen, "tr{color:black;font-size:8pt;font-weight:400;text-align:center;vertical-align:middle;}")
	iLen += formatex(sBuffer[iLen], charsmax(sBuffer)-iLen, "tr:nth-child(even){background-color: #C2D69A;}tr:nth-child(odd){background-color: #B6DDE8;}</style></head>")
	iLen += formatex(sBuffer[iLen], charsmax(sBuffer)-iLen, "<body><table align=center border='3' width=^"100%%^" style=^"border-collapse:collapse;^">")
	iLen += formatex(sBuffer[iLen], charsmax(sBuffer)-iLen, "<tr><td class=TITLES width=16px>ID</td><td class=TITLES>GANG NAME</td><td class=TITLES>GANG MEMBERS</td><td class=TITLES>GANG KILLS</td></tr>")
	
	for(new i; i < count; i++)
	{
		ArrayGetArray(array_topgangs, i, xArray);
		iLen += formatex(sBuffer[iLen], charsmax(sBuffer)-iLen, "<tr><td>%d</td><td>%s</td><td>%d</td><td>%d</td></tr>",
			(i+1), xArray[GANG_NAME], ArraySize(xArray[GANG_ARRAY_MEMBERS]), xArray[GANG_KILLS])
	}
	
	iLen += formatex(sBuffer[iLen], charsmax(sBuffer)-iLen, "</table></body></html>");
	
	new sTitle[32]; formatex(sTitle, charsmax(sTitle), "TOP %d GANG!", count);
	show_motd(id, sBuffer, sTitle);
	
	ArrayDestroy(array_topgangs);
}

public SortTopGangs(Array:array, item1, item2, const data[], data_size)
{
	new xArray[GANGS_INFO], xArray2[GANGS_INFO];
	ArrayGetArray(array,item1,xArray)
	ArrayGetArray(array,item2,xArray2)
	
	if(xArray[GANG_KILLS] > xArray2[GANG_KILLS])
		return -1;
	
	if(xArray[GANG_KILLS] < xArray2[GANG_KILLS])
		return 1;
	
	return 0;
}

public player_left_gang(id)
{
	new iGangStatus;
	if((iGangStatus=user_gang_data[id][USER_GANG_STATUS]) == NOT_INGANG)
	{
		return PLUGIN_HANDLED;
	}
	
	new sBuffer[128], szGangname[32], iGangID = user_gang_data[id][USER_GANG_ID];
	copy(szGangname, charsmax(szGangname), user_gang_data[id][USER_GANG_NAME]);
	
	new szName[32];
	get_user_name(id, szName, charsmax(szName));
	
	if(iGangStatus == GANG_OWNER)
	{
		if(iGangStatus == GANG_OWNER)
		{
			cprint_chat(id, _, "You have to transfer the ownership of the gang inorder to leave!");
			return PLUGIN_HANDLED;
		}
		
		if(destroy_thegang(iGangID, szGangname) != PLUGIN_CONTINUE)
		{
			return PLUGIN_HANDLED;
		}
		
		cprint_chat(0, _, "!g%s !tGang !yhas been !gdestroyed!", szGangname)
		formatex(sBuffer, charsmax(sBuffer), "OWNER %s HAS LEFT THE %s GANG AND THEREFORE ITS BEEN REMOVED!", szName, szGangname)
		log_amx(sBuffer);
		
		formatex(sBuffer, charsmax(sBuffer), "OWNER LEFT '%s' GANG AND THEREFORE ITS BEEN REMOVED!", szGangname)
		jb_logmessage_action(sBuffer, id);
		return PLUGIN_HANDLED;
	}
	
	cprint_chat(0, _, "^4%s ^1has ^3left the ^4%s ^1gang^3!", szName, szGangname);
	
	get_user_identity(id, szName, charsmax(szName));
	remove_user_fromgang(szName, iGangID);
	
	formatex(sBuffer, charsmax(sBuffer), "LEFT '%s' GANG AND THEREFORE ITS BEEN REMOVED!", szGangname)
	jb_logmessage_action(sBuffer, id);
	return PLUGIN_HANDLED;
}

confirmation_menu(id, const reason[], const function[])
{
	new zmenu = menu_create(reason, "confirm_respone")
	
	menu_additem(zmenu, "\yYes!", function)
	menu_additem(zmenu, "\rNo!", "")
	
	menu_display(id, zmenu)
}

public confirm_respone(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu)
		return;
	}
	
	if(item == 0) // key 1(yes)..
	{
		new sData[32], paccess, callback;
		menu_item_getinfo(menu, item, paccess, sData, charsmax(sData), "", 0, callback);
		
		if( callfunc_begin(sData) == 1 )
		{
			callfunc_push_int(id);
			callfunc_end();
		}
	}
	
	menu_destroy(menu);
}

public gang_creation(id)
{
	set_flag(g_user_ingang_creation,id);
	
	new sText[98], menu = menu_create("Fill out the blanks!", "gang_creation_handle"),
	sInfo[20], gang_skin_cost = get_pcvar_num(g_cvar_gang_skin_cost), szSkin[32];
	copy(szSkin, charsmax(szSkin), user_gang_data[id][USER_GANG_SKIN]);
	
	new total_costs = get_pcvar_num(g_cvar_gang_cost) + (equali(szSkin, "None") ? 0:gang_skin_cost);
	
	formatex(sText, charsmax(sText), "\r[GANG NAME]: \y%s", user_gang_data[id][USER_GANG_NAME]);
	menu_additem(menu, sText, "-1");
	
	if(ArraySize(garray_gang_skins) && jb_get_user_cash(id) >= total_costs)
	{
		formatex(sText, charsmax(sText), "\r[GANG SKIN]: \y%s^nSkin Cost: \r%d$", szSkin, gang_skin_cost);
		menu_additem(menu, sText, "-2");
	}
	else
	{
		formatex(sText, charsmax(sText), "\d[GANG SKIN]: %s^n\rSkin Cost: \d%d$", szSkin, gang_skin_cost);
		menu_additem(menu, sText, "-3", NO_ACCESS);
	}
	
	num_to_str(total_costs, sInfo, charsmax(sInfo))
	formatex(sText, charsmax(sText), "%sSubmit!^n\wTotal \yCosts: \r%d$", check_flag(g_user_cant_create_agang,id) ? "\d":"\r", total_costs);
	menu_additem(menu, sText, sInfo, check_flag(g_user_cant_create_agang,id) ? NO_ACCESS:0);
	
	menu_display(id, menu);
}

public gang_creation_handle(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		remove_flag(g_user_ingang_creation,id)
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	new sData[15], paccess, iCallback
	menu_item_getinfo(menu, item, paccess, sData, charsmax(sData), "", 0, iCallback)
	
	menu_destroy(menu);
	
	new iValue = str_to_num(sData);
	
	switch( iValue )
	{
		case -1:
		{
			client_cmd(id, "messagemode enter_gang_name")
			return PLUGIN_HANDLED;
		}
		case -2:
		{
			skins_menu(id);
			return PLUGIN_HANDLED;
		}
		case -3:
		{
			gang_creation(id)
			return PLUGIN_HANDLED;
		}
	}
	
	if(check_flag(g_user_cant_create_agang,id))
	{
		gang_creation(id)
		return PLUGIN_HANDLED;
	}
	
	new szGangname[32], szGangSkin[32];
	copy(szGangname, charsmax(szGangname), user_gang_data[id][USER_GANG_NAME]);
	copy(szGangSkin, charsmax(szGangSkin), user_gang_data[id][USER_GANG_SKIN]);
	
	if(!equal(szGangSkin,"None"))
	{
		for(new i, j, maxloop = ArraySize(garray_gangs), 
				xArray[GANGS_INFO]; i < maxloop; i++)
		{
			ArrayGetArray(garray_gangs, j, xArray);
			if(equal(xArray[GANG_SKIN_MDL], szGangSkin))
			{
				iValue -= get_pcvar_num(g_cvar_gang_skin_cost);
				copy(user_gang_data[id][USER_GANG_SKIN], charsmax(user_gang_data[][USER_GANG_SKIN]), "None");
				gang_creation(id);
				return PLUGIN_HANDLED;
			}
		}
	}
	
	if(jb_get_user_cash(id) < iValue)
	{
		cprint_chat(id, _, "You don't have enough cash to create a gang!")
		return PLUGIN_HANDLED;
	}
	
	jb_set_user_cash(id, (jb_get_user_cash(id)-iValue));
	
	new sAuthid[32], sName[32];
	get_user_name(id, sName, charsmax(sName));
	get_user_identity(id, sAuthid, charsmax(sAuthid));
	
	create_gang(szGangname, sAuthid, sName, szGangSkin, get_pcvar_num(cvar_maxmembers_slots));
	
	log_amx("[JB GANG SYSTEM] a new gang has been registered with name '%s' belong to '%s' and '%s' as its gang skin!", szGangname, sName, szGangSkin);
	cprint_chat(id, _, "your gang has been successfully created, you're now the owner of ^4%s^3!", szGangname);
	cprint_chat(0, _, "^3new gang has been created ^4(%s)^3, by ^4%s^3.", szGangname, sName);
	return PLUGIN_HANDLED;
}

create_gang(const gangname[], const gangownerAUTHID[], const gangownerNAME[], const gangskin[], const gangmaxslots)
{
	new fw_return;
	ExecuteForward(g_fwd_gang_creating, fw_return, gangname, gangskin, gangownerAUTHID);
	
	if(fw_return >= JB_HANDLED)
	{
		return PLUGIN_HANDLED;
	}
	
	new ilen, sBuffer[256];
	ilen = formatex(sBuffer, charsmax(sBuffer), "^n[%s] ^"%s^" ^"0^"^n", 
			gangname, gangskin);
	ilen += formatex(sBuffer[ilen], charsmax(sBuffer)-ilen, "^"%s^" ^"%s^" ^"%s^"", gangownerAUTHID, USER_STATUS[GANG_OWNER], gangownerNAME);
	write_file(GANGS_FILE, sBuffer)
	
	static szChar[2] = { EOS, EOS };
	if(szChar[0] == EOS)
	{
		get_pcvar_string(g_cvar_gang_save_method, szChar, charsmax(szChar));
		switch( szChar[0] )
		{
			case 's', 'S', 'a', 'A' : szChar[0] = 'c';
			case 'I', 'i' : szChar[0] = 'd';
			case 'n', 'N' : szChar[0] = 'a';
		}
	}

	new id = find_player(szChar, gangownerAUTHID);
	
	if(id > 0)
	{
		user_gang_data[id][USER_GANG_ID] = ArraySize(garray_gangs);
		user_gang_data[id][USER_GANG_STATUS] = GANG_OWNER;
		copy(user_gang_data[id][USER_GANG_NAME], charsmax(user_gang_data[][USER_GANG_NAME]), gangname);
		copy(user_gang_data[id][USER_GANG_SKIN], charsmax(user_gang_data[][USER_GANG_SKIN]), gangskin);
	}
	
	new xArray[GANGS_INFO];
	copy(xArray[GANG_NAME], charsmax(xArray[GANG_NAME]), gangname);
	copy(xArray[GANG_SKIN], charsmax(xArray[GANG_SKIN]), gangskin);
	xArray[GANG_KILLS] = 0;
	ArrayPushString((xArray[GANG_ARRAY_MEMBERS] = _:ArrayCreate(32,1)), gangownerAUTHID);
	TrieSetString((xArray[GANG_TRIE_MSTATUS] = _:TrieCreate()), gangownerAUTHID, USER_STATUS[GANG_OWNER]);
	TrieSetString((xArray[GANG_TRIE_NAMES] = _:TrieCreate()), gangownerAUTHID, gangownerNAME);
	ArrayPushArray(garray_gangs, xArray);
	
	TrieSetCell(gtrie_gang_maxslots, gangname, gangmaxslots);
	
	ExecuteForward(g_fwd_gang_created, fw_return, gangname, gangskin, gangownerAUTHID);
	return PLUGIN_CONTINUE;
}

skins_menu(id)
{
	if(!check_flag(g_user_ingang_creation,id))
	{
		return;
	}
	
	new sText[64], menu = menu_create("Choose out your gang skin!", "skins_menu_handle"),
	szSkin[32]; copy(szSkin, charsmax(szSkin), user_gang_data[id][USER_GANG_SKIN]);
	
	formatex(sText, charsmax(sText), "%sNone", equal(szSkin, "None") ? "\y":"\r")
	menu_additem(menu, sText, "None")
	
	for(new i, j, maxloop2 = ArraySize(garray_gangs),
		maxloop = ArraySize(garray_gang_skins), 
			xArray2[GANGS_INFO], xArray[GANG_SKINS_INFO]; i < maxloop; i++)
	{
		ArrayGetArray(garray_gang_skins, i, xArray)
		
		for(j = 0; j < maxloop2; j++)
		{
			ArrayGetArray(garray_gangs, j, xArray2);
			if(equal(xArray2[GANG_SKIN], xArray[GANG_SKIN_NAME]))
			{
				xArray[GANG_SKIN_ACCESS] = NO_ACCESS;
				j = maxloop2;
			}
		}
		
		formatex(sText, charsmax(sText), xArray[GANG_SKIN_NAME]);
		if((get_user_flags(id) & xArray[GANG_SKIN_ACCESS]) || !xArray[GANG_SKIN_ACCESS])
			formatex(sText, charsmax(sText), "%s%s", equal(szSkin, xArray[GANG_SKIN_NAME]) ? "\y":"\r", xArray[GANG_SKIN_NAME]);
		menu_additem(menu, sText, xArray[GANG_SKIN_NAME], 
			((get_user_flags(id) & xArray[GANG_SKIN_ACCESS]) || !xArray[GANG_SKIN_ACCESS]) ? 0:NO_ACCESS)
	}
	
	menu_display(id, menu)
}

public skins_menu_handle(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	new sData[32], paccess, iCallback
	menu_item_getinfo(menu, item, paccess, sData, charsmax(sData), "", 0, iCallback)
	menu_destroy(menu);
	
	copy(user_gang_data[id][USER_GANG_SKIN], charsmax(user_gang_data[][USER_GANG_SKIN]), sData)
	gang_creation(id)
	return PLUGIN_HANDLED;
}

available_gangmenu(const id, const page)
{
	new total_gangs;
	if(!(total_gangs=ArraySize(garray_gangs)))
	{
		cprint_chat(id, _, "^3There're no available gangs!")
		return;
	}
	
	new pages = floatround((total_gangs / 10.0), floatround_ceil);
	
	new sText[64];
	
	formatex(sText, charsmax(sText), "\yCurrent \wpage : \r%d\y/\r%d", (page + 1), pages)
	new menu = menu_create(sText, "available_gmenu_handler")
	
	menu_additem(menu, "\rShow !^n^n")
	
	menu_additem(menu, "Next page", _, ((page + 1 ) < pages) ? 0:NO_ACCESS)
	menu_additem(menu, "Previous page", _, !page ? NO_ACCESS:0)
	
	menu_setprop(menu, MPROP_NOCOLORS, "\w")
	menu_setprop(menu, MPROP_EXITNAME, "Return")
	
	menu_display(id, menu)
}

public available_gmenu_handler(id, menu, item)
{
	menu_destroy(menu);

	switch( item )
	{
		case 0: available_gangs(id, g_userpage[id]);
		case 1: available_gangmenu(id, ++g_userpage[id]);
		case 2: available_gangmenu(id, --g_userpage[id]);
		case MENU_EXIT:
		{
			g_userpage[id] = 0;
			if(is_user_connected(id)) gang_mainmenu(id,0);
		}
	}
	
	return PLUGIN_HANDLED;
}

available_gangs(const id, const page)
{
	new total_gangs = ArraySize(garray_gangs);
	if(!total_gangs || (floatround((total_gangs / 10.0), floatround_ceil)) <= page)
	{
		return;
	}
	
	new sBuffer[1536], iLen;
	
	iLen = formatex(sBuffer, charsmax(sBuffer), "<html><head><style id=^"XXX_12835_Styles^">")
	iLen += formatex(sBuffer[iLen], charsmax(sBuffer)-iLen, "tr {padding-top:1px;padding-right:1px;padding-left:1px;mso-ignore:padding;color:black;font-size:12.0pt;")
	iLen += formatex(sBuffer[iLen], charsmax(sBuffer)-iLen, "font-weight:700;font-family:Calibri, sans-serif;text-align:center;vertical-align:bottom;border-top:1.0pt solid windowtext;")
	iLen += formatex(sBuffer[iLen], charsmax(sBuffer)-iLen, "border-right:.5pt solid windowtext;border-bottom:none;border-left:1.0pt solid windowtext;background:#FFC819;")
	iLen += formatex(sBuffer[iLen], charsmax(sBuffer)-iLen, "mso-pattern:black none;white-space:nowrap;}")
	iLen += formatex(sBuffer[iLen], charsmax(sBuffer)-iLen, "td {width:100pt;} .xID {width:30pt;height:15.0pt;}</style></head>")
	iLen += formatex(sBuffer[iLen], charsmax(sBuffer)-iLen, "<body><div id=^"XXX_12835^" align=^"center^"><table border=^"1^" style=^"border-collapse:collapse;table-layout:fixed; width:100%;^">")
	iLen += formatex(sBuffer[iLen], charsmax(sBuffer)-iLen, "<tr><td class=^"xID^">ID</td><td>GANG NAME</td><td>MEMBERS</td><td>GANG SKIN</td><td>OWNER</td></tr>")
	
	static szChar[2] = { EOS, EOS };
	if(szChar[0] == EOS)
	{
		get_pcvar_string(g_cvar_gang_save_method, szChar, charsmax(szChar));
		switch( szChar[0] )
		{
			case 's', 'S', 'a', 'A' : szChar[0] = 'c';
			case 'I', 'i' : szChar[0] = 'd';
			case 'n', 'N' : szChar[0] = 'a';
		}
	}

	new count;
	for(new i = (page * 10), xArray[GANGS_INFO], iOwner, j, szOwner[32], szStatus[8], maxloop; i < total_gangs && count < 10; i++)
	{
		ArrayGetArray(garray_gangs, i, xArray);
		
		// seeking for the gang owner name...
		for(j = 0, maxloop = ArraySize(xArray[GANG_ARRAY_MEMBERS]); j < maxloop; j++)
		{
			ArrayGetString(xArray[GANG_ARRAY_MEMBERS], j, szOwner, charsmax(szOwner))
			TrieGetString(xArray[GANG_TRIE_MSTATUS], szOwner, szStatus, charsmax(szStatus))
			if(equali(USER_STATUS[GANG_OWNER], szStatus))
			{
				if((iOwner = find_player(szChar, szOwner)) > 0)
				{
					get_user_name(iOwner, szOwner, charsmax(szOwner));
					j = maxloop; continue;
				}
				
				TrieGetString(xArray[GANG_TRIE_NAMES], szOwner, szOwner, charsmax(szOwner))
				j = maxloop;
			}
		}
		
		iLen += formatex(sBuffer[iLen], charsmax(sBuffer)-iLen, "<tr><td>%d</td><td>%s</td><td>%d</td><td>%s</td><td>%s</td></tr>", 
			(i+1), xArray[GANG_NAME], ArraySize(xArray[GANG_ARRAY_MEMBERS]), xArray[GANG_SKIN], szOwner)
		count++;
	}
	
	iLen += formatex(sBuffer[iLen], charsmax(sBuffer)-iLen, "</table></div></body></html>")
	
	show_motd(id, sBuffer, "Available Gangs.")
}

gang_members_menu(const id, page)
{
	if(user_gang_data[id][USER_GANG_STATUS] == NOT_INGANG) return;
	
	new menu = menu_create("\r~(\yGang Members\r)~", "gmembers_menu_handler"), szText[196], sInfo[8];
	
	formatex(szText, charsmax(szText), "Search for: %s", user_find_members[id])
	menu_additem(menu, szText, "1")
	
	new xArray[GANGS_INFO], found;
	ArrayGetArray(garray_gangs, user_gang_data[id][USER_GANG_ID], xArray)
	
	static szChar[2] = { EOS, EOS };
	if(szChar[0] == EOS)
	{
		get_pcvar_string(g_cvar_gang_save_method, szChar, charsmax(szChar));
		switch( szChar[0] )
		{
			case 's', 'S', 'a', 'A' : szChar[0] = 'c';
			case 'I', 'i' : szChar[0] = 'd';
			case 'n', 'N' : szChar[0] = 'a';
		}
	}

	for(new i, player, szAuthid[32], szStatus[10], count,
		szName[32], maxloop = ArraySize(xArray[GANG_ARRAY_MEMBERS]); i < maxloop; i++)
	{
		ArrayGetString(xArray[GANG_ARRAY_MEMBERS], i, szAuthid, charsmax(szAuthid));
		TrieGetString(xArray[GANG_TRIE_MSTATUS], szAuthid, szStatus, charsmax(szStatus))
		TrieGetString(xArray[GANG_TRIE_NAMES], szAuthid, szName, charsmax(szName))
		
		if((player=find_player(szChar, szAuthid)) > 0)
		{
			get_user_name(player, szName, charsmax(szName));
		}
		
		// not match...!
		if(user_find_members[id][0] != EOS &&
			containi(szName,user_find_members[id]) == -1)
				continue;
		
		if(page * 7 <= found && count < 7)
		{
			formatex(szText, charsmax(szText), "\r%s \w(\y%s\w) \w[%s\w]", szName, szStatus, !player ? "\rOffline":"\yOnline")
			menu_addtext(menu, szText, 0)
			count++;
		}
		
		found++;
	}
	
	new maxpages = clamp(floatround((found / 7.0), floatround_ceil), 1, 999999);
	
	num_to_str(page + 1, sInfo, charsmax(sInfo));
	formatex(szText, charsmax(szText), "Next Page!")
	menu_additem(menu, szText, sInfo, (page + 1) < maxpages ? 0:NO_ACCESS)
	
	num_to_str(page - 1, sInfo, charsmax(sInfo));
	formatex(szText, charsmax(szText), "Previous Page!^n\rPage: (%d/%d)", page+1, maxpages)
	menu_additem(menu, szText, sInfo, !page ? NO_ACCESS:0)
	
	menu_setprop(menu, MPROP_EXITNAME, "Return")
	menu_display(id, menu)
}

public gmembers_menu_handler(id, menu, item)
{
	menu_destroy(menu);

	switch( item )
	{
		case 1: gang_members_menu( id, ++g_userpage[id]);
		case 2: gang_members_menu( id, --g_userpage[id]);
		case 0: client_cmd(id, "messagemode search_for");
		case MENU_EXIT:
		{
			g_userpage[id] = 0;
			if(is_user_connected(id)) gang_mainmenu(id,0);
		}
	}
	
	return PLUGIN_HANDLED;
}

join_gang_menu(const id)
{
	if(user_gang_data[id][USER_GANG_STATUS] != NOT_INGANG)
	{
		return;
	}
	
	new sText[96];
	new menu = menu_create("\rRequest to join a gang...",  "jgang_menu_handler")
	
	new players[32], pnum, sInfo[32], sName[32], g_items;
	get_players(players, pnum, "ch")
	
	for(new i, xArray[GANGS_INFO], maxslots, player; i < pnum; i++)
	{
		player = players[i];
		
		if(user_gang_data[player][USER_GANG_STATUS] <= GANG_MEMBER ||
			check_flag(g_user_rejected_req[player],id))
		{
			continue;
		}
		
		ArrayGetArray(garray_gangs, user_gang_data[player][USER_GANG_ID], xArray)
		TrieGetCell(gtrie_gang_maxslots, xArray[GANG_NAME], maxslots);
		if(ArraySize(xArray[GANG_ARRAY_MEMBERS]) >= maxslots) continue;
		
		num_to_str(get_user_userid(player), sInfo, charsmax(sInfo));
		get_user_name(player, sName, charsmax(sName))
		formatex(sText, charsmax(sText), "\w%s \r%s of \y%s \rGang",
		sName, USER_STATUS[user_gang_data[player][USER_GANG_STATUS]], user_gang_data[player][USER_GANG_NAME]);
		menu_additem(menu, sText, sInfo);
		g_items++;
	}
	
	if(!g_items)
	{
		menu_destroy(menu);
		return;
	}
	
	menu_display(id, menu);
}

public jgang_menu_handler(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu)
		return PLUGIN_HANDLED;
	}
	
	new sData[32], sName[32], paccess, icallback;
	menu_item_getinfo(menu, item, paccess, sData, charsmax(sData), "", 0, icallback);
	menu_destroy(menu);
	
	new player = find_player("k", str_to_num(sData));
	if(!player || user_gang_data[player][USER_GANG_STATUS] <= GANG_MEMBER)
	{
		join_gang_menu(id);
		return PLUGIN_HANDLED;
	}
	
	new xArray[GANGS_INFO], maxslots;
	ArrayGetArray(garray_gangs, user_gang_data[player][USER_GANG_ID], xArray);
	TrieGetCell(gtrie_gang_maxslots, user_gang_data[player][USER_GANG_NAME], maxslots);
	if(ArraySize(xArray[GANG_ARRAY_MEMBERS]) >= maxslots)
	{
		join_gang_menu(id);
		return PLUGIN_HANDLED;
	}
	
	get_user_name(id, sName, charsmax(sName))
	gang_jrequest_menu(player, get_user_userid(id))
	
	cprint_chat(id, _, "^4The request ^1has been ^3sent!")
	cprint_chat(player, _, "^3[^1WARNING^3] ^4: ^3%s ^1wants to ^4join ^1the ^3gang^4!", sName)
	client_cmd(player, "spk warning")
	return PLUGIN_HANDLED;
}

gang_jrequest_menu(const id, const requesterUID)
{
	new requester = find_player("k", requesterUID);
	
	if(!requester ||
	   user_gang_data[requester][USER_GANG_STATUS] != NOT_INGANG ||
               user_gang_data[id][USER_GANG_STATUS] <= GANG_MEMBER)
	      {
		return;
	      }
	
	new sName[32], sText[64]; get_user_name(requester, sName, charsmax(sName));
	formatex(sText, charsmax(sText), "\r%s \yRequest to join the gang\r!", sName)
	new menu = menu_create(sText, "gang_jrequest_menu_handler")
	
	num_to_str(requesterUID, sName, charsmax(sName))
	menu_additem(menu, "\yAccept!", sName)
	menu_additem(menu, "\rReject!", sName)
	
	menu_display(id, menu)
}

public gang_jrequest_menu_handler(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu)
		return PLUGIN_HANDLED;
	}
	
	new sData[32], paccess, icallback;
	menu_item_getinfo(menu, item, paccess, sData, charsmax(sData), "", 0, icallback);
	
	menu_destroy(menu);
	
	new uid = find_player("k", str_to_num(sData));
	if(!uid || user_gang_data[uid][USER_GANG_STATUS] != NOT_INGANG ||
		user_gang_data[id][USER_GANG_STATUS] <= GANG_MEMBER)
	{
		return PLUGIN_HANDLED;
	}
	
	new xArray[GANGS_INFO], maxslots, currentslots;
	ArrayGetArray(garray_gangs, user_gang_data[id][USER_GANG_ID], xArray);
	TrieGetCell(gtrie_gang_maxslots, user_gang_data[id][USER_GANG_NAME], maxslots);
	if((currentslots=ArraySize(xArray[GANG_ARRAY_MEMBERS])) >= maxslots)
	{
		cprint_chat(id, _, "the gang have reached the !tmaximum members !gslots(%d/%d)! ", currentslots, maxslots)
		return PLUGIN_HANDLED;
	}
	
	get_user_identity(uid, sData, charsmax(sData));
	
	switch( item )
	{
		case 0:  // Accept!
		{
			set_user_gang(sData, user_gang_data[id][USER_GANG_ID], GANG_MEMBER);
			get_user_name(uid, sData, charsmax(sData))
			cprint_chat(0, _, "!t%s !yhas joined the !g%s !tgang!g!", sData, user_gang_data[id][USER_GANG_NAME])
		}
		case 1:  // Reject!
		{
			set_flag(g_user_rejected_req[id],uid)
			get_user_name(id, sData, charsmax(sData))
			cprint_chat(uid, _, "^4%s ^1has ^3Rejected ^1your request!", sData)
		}
	}
	
	return PLUGIN_HANDLED;
}

invite_gang_menu(const id)
{
	if(user_gang_data[id][USER_GANG_STATUS] == NOT_INGANG) return;
	if(user_gang_data[id][USER_GANG_STATUS] < GANG_LEADER)
	{
		cprint_chat(id, _, "You have to be a leader or higher inorder to invite players to the gang!")
		return;
	}
	
	new xArray[GANGS_INFO], maxslots, currentslots;
	ArrayGetArray(garray_gangs, user_gang_data[id][USER_GANG_ID], xArray);
	TrieGetCell(gtrie_gang_maxslots, xArray[GANG_NAME], maxslots);
	if((currentslots=ArraySize(xArray[GANG_ARRAY_MEMBERS])) >= maxslots)
	{
		cprint_chat(id, _, "Your gang have reached the !tmaximum members !gslots(%d/%d)! ", currentslots, maxslots)
		return;
	}
	
	new menu = menu_create("Invite a player to the gang!", "invgang_menu")
	
	new players[32], pnum, sInfo[32], sName[32], g_items;
	get_players(players, pnum, "ch")
	
	for(new i, uid; i < pnum; i++)
	{
		uid = players[i];
		
		if(user_gang_data[uid][USER_GANG_STATUS] != NOT_INGANG || uid == id|| check_flag(g_user_rejected_inv[uid],id))
		{
			continue;
		}
		
		num_to_str(get_user_userid(uid), sInfo, charsmax(sInfo))
		get_user_name(uid, sName, charsmax(sName))
		menu_additem(menu, sName, sInfo)
		g_items ++;
	}
	
	if(!g_items)
	{
		menu_destroy(menu)
		return;
	}
	
	menu_display(id, menu);
}

public invgang_menu(id, menu, item)
{
	if(item == MENU_EXIT || (user_gang_data[id][USER_GANG_STATUS] < GANG_LEADER))
	{
		menu_destroy(menu)
		return PLUGIN_HANDLED;
	}
	
	new sData[32], icallback, paccess;
	menu_item_getinfo(menu, item, paccess, sData, charsmax(sData), "", 0, icallback);
	
	menu_destroy(menu);
	
	new player = find_player("k", str_to_num(sData));
	if(!player || user_gang_data[player][USER_GANG_STATUS] != NOT_INGANG)
	{
		invite_gang_menu(id)
		return PLUGIN_HANDLED;
	}
	
	new xArray[GANGS_INFO], maxslots, currentslots;
	ArrayGetArray(garray_gangs, user_gang_data[id][USER_GANG_ID], xArray);
	TrieGetCell(gtrie_gang_maxslots, user_gang_data[id][USER_GANG_NAME], maxslots);
	if((currentslots=ArraySize(xArray[GANG_ARRAY_MEMBERS])) >= maxslots)
	{
		cprint_chat(id, _, "the gang have reached the !tmaximum members !gslots(%d/%d)! ", currentslots, maxslots)
		return PLUGIN_HANDLED;
	}
	
	gang_invitation_menu(player, get_user_userid(id));
	
	cprint_chat(id, _, "^4Gang Invitation ^1has been ^3sent!")
	cprint_chat(player, _, "^3[^1WARNING^3] ^4: ^1You received a ^4gang ^3invitation!")
	client_cmd(player, "spk warning")
	return PLUGIN_HANDLED;
}

leader_menu(const id, const page)
{
	if(user_gang_data[id][USER_GANG_STATUS] < GANG_LEADER)
	{
		g_userpage[id] = 0;
		gang_mainmenu(id,0);
		return;
	}
	
	new menu = menu_create("\r~(\yLeader Menu\r)~", "leadermenu_handler");
	
	new sText[64], status = user_gang_data[id][USER_GANG_STATUS], sPName[32], g_items;
	formatex(sText, charsmax(sText), leadermenu_items[page][INFO_ACTION])
	menu_additem(menu, sText, "#")
	
	new xArray[GANGS_INFO], player;
	ArrayGetArray(garray_gangs, user_gang_data[id][USER_GANG_ID], xArray);
	
	static szChar[2] = { EOS, EOS };
	if(szChar[0] == EOS)
	{
		get_pcvar_string(g_cvar_gang_save_method, szChar, charsmax(szChar));
		switch( szChar[0] )
		{
			case 's', 'S', 'a', 'A' : szChar[0] = 'c';
			case 'I', 'i' : szChar[0] = 'd';
			case 'n', 'N' : szChar[0] = 'a';
		}
	}

	for(new i, paccess, szString[32],
		szPStatus[32], maxloop = ArraySize(xArray[GANG_ARRAY_MEMBERS]); i < maxloop; i++)
	{
		paccess = 0;
		ArrayGetString(xArray[GANG_ARRAY_MEMBERS], i, szString, charsmax(szString));
		TrieGetString(xArray[GANG_TRIE_MSTATUS], szString, szPStatus, charsmax(szPStatus));
		TrieGetString(xArray[GANG_TRIE_NAMES], szString, sPName, charsmax(sPName))
		
		if(!((1<<status) & leadermenu_items[page][INFO_ACCESS]) ||
				!equal(szPStatus, USER_STATUS[leadermenu_items[page][INFO_POSITION]]))
		{
			paccess = NO_ACCESS;
		}

		if((player=find_player(szChar, szString)) > 0)
		{
			get_user_name(player, sPName, charsmax(sPName));
		}
		
		formatex(sText, charsmax(sText), "\r%s \w- \yPosition: \r%s", sPName, szPStatus);
		if(paccess == NO_ACCESS)
		{
			formatex(sText, charsmax(sText), "%s - Position: %s", sPName, szPStatus);
		}
		
		menu_additem(menu, sText, szString, paccess);
		g_items ++;
	}
	
	if(!g_items)
	{
		menu_destroy(menu);
		return;
	}
	
	menu_display(id, menu);
}

public leadermenu_handler(id, menu, item)
{
	if(item == MENU_EXIT || user_gang_data[id][USER_GANG_STATUS] < GANG_LEADER)
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	new sData[32], paccess, icallback;
	menu_item_getinfo(menu, item, paccess, sData, charsmax(sData), "", 0, icallback);
	
	menu_destroy(menu);
	
	static szChar[2] = { EOS, EOS };

	if(szChar[0] == EOS)
	{
		get_pcvar_string(g_cvar_gang_save_method, szChar, charsmax(szChar));

		switch( szChar[0] )
		{
			case 's', 'S', 'a', 'A' : szChar[0] = 'c';
			case 'I', 'i' : szChar[0] = 'd';
			case 'n', 'N' : szChar[0] = 'a';
		}
	}

	new xID = find_player(szChar, str_to_num(sData));
	
	if(sData[0] == '#')
	{
		if(g_userpage[id] < sizeof leadermenu_items-1)
			g_userpage[id] ++;
		else
			g_userpage[id] = 0;
		
		leader_menu(id, g_userpage[id]);
		return PLUGIN_HANDLED;
	}
	
	new sName[32], sName2[32];
	get_user_name(id, sName2, charsmax(sName2));
	
	new xArray[GANGS_INFO], iGangID = user_gang_data[id][USER_GANG_ID];
	ArrayGetArray(garray_gangs, iGangID, xArray);
	TrieGetString(xArray[GANG_TRIE_NAMES], sData, sName, charsmax(sName));
	
	if(xID > 0) get_user_name(xID, sName, charsmax(sName));
	
	switch( g_userpage[id] )
	{
		case 0:
		{
			set_user_gang(sData, iGangID, GANG_LEADER);
			if(xID > 0) cprint_chat(xID, _, "^4You have been promoted to a gang leader position by ^3%s^4!", sName2);
			cprint_chat(id, _, "You have successfully promoted ^4%s^3!", sName);
		}
		case 1:
		{
			set_user_gang(sData, iGangID, GANG_MEMBER);
			if(xID > 0) cprint_chat(xID, _, "^3You have been demoted to a gang member position by ^4%s^3!", sName2);
			cprint_chat(id, _, "You have successfully demoted ^4%s^3!", sName);
		}
		case 2:
		{
			if(xID > 0) cprint_chat(xID, _, "^3You have been kicked out of the gang by ^4%s^3!", sName2);
			cprint_chat(id, _, "You have successfully kicked ^4%s ^1out of the gang^3!", sName);
			remove_user_fromgang(sData, iGangID);
		}
		case 3:
		{
			if(xID > 0) cprint_chat(xID, _, "^3You have claimed the ownership of the ^4%s !ygang^3!", xArray[GANG_NAME]);
			cprint_chat(id, _, "You have successfully transfered the ownership of the gang to %s^3!", sName);
			set_user_gang(sData, iGangID, GANG_OWNER);
			
			get_user_identity(id, sData, charsmax(sData));
			set_user_gang(sData, iGangID, GANG_LEADER);
		}
	}
	
	leader_menu(id, g_userpage[id]);
	return PLUGIN_HANDLED;
}

gang_invitation_menu(const id, const iUID)
{
	new sText[64], uid = find_player("k", iUID);
	
	new name[32]; get_user_name(uid, name, charsmax(name));
	formatex(sText, charsmax(sText), "\r[GANG Invitation] \wSent from \y%s^n\wto join \r%s \ygang!", 
	name, user_gang_data[uid][USER_GANG_NAME])
	new menu = menu_create(sText, "ginvitation_menu_handler")
	
	new szUID[32]; num_to_str(iUID, szUID, charsmax(szUID));
	menu_additem(menu, "\yAccept!", szUID);
	menu_additem(menu, "\rReject!", szUID);
	
	menu_display(id, menu)
}

public ginvitation_menu_handler(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	new sData[32], paccess, icallback;
	menu_item_getinfo(menu, item, paccess, sData, charsmax(sData), "", 0, icallback);
	menu_destroy(menu);
	
	new uid = find_player("k", str_to_num(sData));
	if(!uid || user_gang_data[uid][USER_GANG_STATUS] < GANG_LEADER || user_gang_data[id][USER_GANG_STATUS] != NOT_INGANG)
	{
		return PLUGIN_HANDLED;
	}
	
	new xArray[GANGS_INFO], maxslots, currentslots;
	ArrayGetArray(garray_gangs, user_gang_data[uid][USER_GANG_ID], xArray);
	TrieGetCell(gtrie_gang_maxslots, user_gang_data[uid][USER_GANG_NAME], maxslots);
	if((currentslots=ArraySize(xArray[GANG_ARRAY_MEMBERS])) >= maxslots)
	{
		cprint_chat(id, _, "the gang have reached the !tmaximum members !gslots(%d/%d)! ", currentslots, maxslots)
		return PLUGIN_HANDLED;
	}
	
	get_user_identity(id, sData, charsmax(sData))
	
	switch( item )
	{
		case 0:  // Accept!
		{
			set_user_gang(sData, user_gang_data[uid][USER_GANG_ID], GANG_MEMBER);
			get_user_name(id, sData, charsmax(sData))
			cprint_chat(0, _, "!t%s !yhas joined the !g%s !tgang!g!", sData, user_gang_data[uid][USER_GANG_NAME])
		}
		case 1:  // Reject!
		{
			set_flag(g_user_rejected_inv[id],uid)
			get_user_name(id, sData, charsmax(sData))
			cprint_chat(uid, _, "^4%s ^1has ^3Rejected ^1the gang ^4invitation!", sData)
		}
	}
	
	return PLUGIN_HANDLED;
}

get_gang_status_id(const szString[])
{
	for(new i, maxloop=sizeof USER_STATUS; i < maxloop; i++)
	{
		if(equali(USER_STATUS[i], szString)) return i;
	}
	
	return -1;
}

get_user_identity(index, szAuthID[], len)
{
	static szChar[2];
	get_pcvar_string(g_cvar_gang_save_method, szChar, charsmax(szChar));

	switch( szChar[0] )
	{
		case 's', 'S', 'a', 'A' : get_user_authid(index, szAuthID, len);
		case 'I', 'i' : get_user_ip(index, szAuthID, len, true);
		case 'n', 'N' : get_user_name(index, szAuthID, len);
	}
}

/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ ansicpg1252\\ deff0{\\ fonttbl{\\ f0\\ fnil\\ fcharset0 Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang1033\\ f0\\ fs16 \n\\ par }
*/
