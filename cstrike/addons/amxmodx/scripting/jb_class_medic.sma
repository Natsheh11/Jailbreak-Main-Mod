/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <fakemeta>
#include <engine>
#include <hamsandwich>
#include <jailbreak_core>
#include <xs>

#define PLUGIN "[JB] Class: Medic"
#define AUTHOR "Natsheh"

#define VICTIM_ID pev_iuser1
#define SERIAL_KEY pev_iuser2
#define CORPSE_REVIVER pev_iuser4
#define CORPSE_DECAYED pev_fuser4
#define SERIAL_NUMBER 4550
#define CORPSE_THINK_LEN 0.3

#if !defined IsPlayer
#define IsPlayer(%1) (1 <= %1 <= 32)
#endif

#define Mask(%1) (1<<(%1&31))
#define WORLD_DIMENSION 0xFFFFFFFF
#define CORPSE_DIMENSION Mask(5)

#define Invalid_Message_Handle INVALID_HANDLE

new g_class_id, g_iMaxplayers, g_Flesh_gibs, bool:g_bMedicActive=true, g_iOLDMSG_BLOCK_SET, g_pcvar_corpse_decay;

new HamHook:HamHook_One, HamHook:HamHook_Two, HamHook:HamHook_Three, iMsg_ClCorpse, g_user_body[MAX_PLAYERS+1] = { 0,0,...};

new const CORPSE_CLASSNAME[] = "player_corpse";

public jb_class_creation()
{
	new const szVKnife[] = "models/jailbreak/v_defibrillator.mdl";
	new const szPKnife[] = "models/jailbreak/p_defibrillator.mdl";
	new const szKSounds[] = "jailbreak/defib/defib";
	g_class_id = register_jailbreak_class("Medic", "gign", "mp5navy,famas,galil", "glock18,usp,deagle", 0, TEAM_GUARDS, szVKnife, szPKnife, szKSounds);
}

public plugin_precache()
{
	g_Flesh_gibs = PRECACHE_WORLD_ITEM_I("models/hgibs.mdl");
}

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR);
	
	HamHook_One = RegisterHam(Ham_TakeDamage, "info_target", "fw_infotarget_takedmg_pre", false);
	HamHook_Two = RegisterHam(Ham_Killed, "info_target", "fw_infotarget_killed_pre", false);
	HamHook_Three = RegisterHam(Ham_Spawn, "player", "fw_player_spawn_post", true);
	
	iMsg_ClCorpse = get_user_msgid("ClCorpse");
	g_iMaxplayers = get_maxplayers();
	
	register_think(CORPSE_CLASSNAME, "fw_corpse_think");
	register_event("ClCorpse", "Event_ClCorpse", "a");

	g_pcvar_corpse_decay = register_cvar("jb_corpse_decay_time", "10");
}

public fw_corpse_think(corpse)
{
	if(!pev_valid(corpse)) return;
	
	if(pev(corpse, SERIAL_KEY) != SERIAL_NUMBER) return;
	
	static players[32], pnum;
	get_players(players, pnum, "ach");
	
	if(pnum > 0)
	{
		static szName[32], Float:fOrigin[3], ent, target; ent = -1;
		get_user_name(pev(corpse, pev_owner), szName, charsmax(szName));
		pev(corpse, pev_origin, fOrigin);
		while((ent=find_ent_in_sphere(ent, fOrigin, 300.0)) > 0)
		{
			if(is_user_alive(ent) && !is_user_bot(ent))
			{
				#if AMXX_VERSION_NUM > 182
				get_user_aiming(ent, target);
				#else
				new null;
				get_user_aiming(ent, target, null);
				#endif
				
				if(corpse == target)
				{
					client_print(ent, print_center, "%s Corpse!", szName);
				}
			}
		}
	}
	
	static Float:fCorpseDecayedTime;
	pev(corpse, CORPSE_DECAYED, fCorpseDecayedTime);
	if( (get_gametime() - fCorpseDecayedTime) >= get_pcvar_float(g_pcvar_corpse_decay) )
	{
		ExecuteHamB(Ham_Killed, corpse, pev(corpse, pev_owner), 0);
	}

	set_pev(corpse, pev_nextthink, get_gametime() + CORPSE_THINK_LEN);
}

public jb_day_start(iDayid)
{
	g_iOLDMSG_BLOCK_SET = get_msg_block(iMsg_ClCorpse);
}

public jb_day_started(iDayid)
{
	g_bMedicActive = false;
	DisableHamForward(HamHook_One);
	DisableHamForward(HamHook_Two);
	DisableHamForward(HamHook_Three);
	set_msg_block(iMsg_ClCorpse, g_iOLDMSG_BLOCK_SET);

	new ent = -1, iOwner;
	while( (ent = engfunc(EngFunc_FindEntityByString, ent, "classname", "info_target")) > 0)
	{
		if(pev(ent, SERIAL_KEY) == SERIAL_NUMBER)
		{
			iOwner = pev(ent, VICTIM_ID);

			if(IsPlayer(iOwner))
			{
				g_user_body[iOwner] = 0;
				set_pev(ent, pev_flags, FL_KILLME);
				dllfunc(DLLFunc_Think, ent);
			}
		}
	}
}

public jb_round_end()
{
	g_bMedicActive = false;
	DisableHamForward(HamHook_One);
	DisableHamForward(HamHook_Two);
	DisableHamForward(HamHook_Three);
	set_msg_block(iMsg_ClCorpse, BLOCK_NOT);

	new ent = -1, iOwner;
	while( (ent = engfunc(EngFunc_FindEntityByString, ent, "classname", "info_target")) > 0)
	{
		if(pev(ent, SERIAL_KEY) == SERIAL_NUMBER)
		{
			iOwner = pev(ent, VICTIM_ID);

			if(IsPlayer(iOwner))
			{
				g_user_body[iOwner] = 0;
				set_pev(ent, pev_flags, FL_KILLME);
				dllfunc(DLLFunc_Think, ent);
			}
		}
	}
}

public jb_round_start_pre()
{
	g_bMedicActive = true;
	EnableHamForward(HamHook_One);
	EnableHamForward(HamHook_Two);
	EnableHamForward(HamHook_Three);

	set_msg_block(iMsg_ClCorpse, BLOCK_SET);
}

public jb_day_ended(iDayid)
{
	g_bMedicActive = true;
	EnableHamForward(HamHook_One);
	EnableHamForward(HamHook_Two);
	EnableHamForward(HamHook_Three);
	set_msg_block(iMsg_ClCorpse, BLOCK_SET);
}

public fw_player_spawn_post(id)
{
	if(!g_bMedicActive)
	{
		return;
	}

	if(!is_user_alive(id)) return;
	
	new ent;
	if(pev_valid((ent=g_user_body[id])) > 0)
	{
		set_pev(ent, pev_flags, FL_KILLME);
		dllfunc(DLLFunc_Think, ent);
		g_user_body[id] = 0;
	}
	
	set_pev(id, pev_groupinfo, (pev(id, pev_groupinfo) | WORLD_DIMENSION));
	if(jb_get_user_classid(id) != g_class_id)
	{
		set_pev(id, pev_groupinfo, (pev(id, pev_groupinfo) & ~CORPSE_DIMENSION));
	}
}

has_defibrillator(id)
{
	if(get_user_weapon(id) != CSW_KNIFE)
	{
		return false;
	}

	static szVModel[64], szCurrVModel[64];
	jb_get_classdata(.classid=g_class_id, .vknifemdl=szVModel, .vKLen=charsmax(szVModel));

	pev(id, pev_viewmodel2, szCurrVModel, charsmax(szCurrVModel));

	if(equal(szVModel, szCurrVModel))
	{
		return true;
	}

	return false;
}

public fw_infotarget_takedmg_pre(target, inflictor, attacker, Float:Damage, DamageBits)
{
	if(!g_bMedicActive)
	{
		return HAM_IGNORED;
	}

	if( pev(target, SERIAL_KEY) != SERIAL_NUMBER ) return HAM_IGNORED;
	
	set_pev(target, pev_velocity, Float:{0.0,0.0,0.0});

	if( ( g_iMaxplayers >= attacker >= 1 ) )
	{
		if(inflictor == attacker && has_defibrillator(attacker))
		{
			set_pev(target, CORPSE_REVIVER, attacker);
			reviving_attempt_effects( pev(target, VICTIM_ID), target );
			return HAM_IGNORED;
		}
	}

	static Float:fOrigin[3];
	pev(target, pev_origin, fOrigin);
	fOrigin[2] += 5.0;
	gib(fOrigin);

	set_pev(target, CORPSE_REVIVER, 0);
	return HAM_IGNORED;
}

#if AMXX_VERSION_NUM > 182
public client_disconnected(id)
#else
public client_disconnect(id)
#endif
{
	new ent;
	if(pev_valid((ent=g_user_body[id])) > 0)
	{
		set_pev(ent, pev_flags, FL_KILLME);
		dllfunc(DLLFunc_Think, ent);
		g_user_body[id] = 0;
	}
}

public fw_infotarget_killed_pre(target, killer, ShouldGib)
{
	if(!g_bMedicActive)
	{
		return HAM_IGNORED;
	}

	if(pev(target, SERIAL_KEY) != SERIAL_NUMBER) return HAM_IGNORED;

	set_pev(target, pev_solid, SOLID_NOT);

	new Float:fOrigin[3];
	new victim = pev(target, VICTIM_ID);

	// the killer was the medic :)
	if(killer != 0 && target != killer && pev(target, CORPSE_REVIVER) == killer)
	{
		if( (g_iMaxplayers >= victim >= 1) )
		{
			ExecuteHamB(Ham_CS_RoundRespawn, victim);
			pev(target, pev_origin, fOrigin);
			fOrigin[2] += 1.0;

			if(pev(target, pev_bInDuck))
			{
				static const Float:VEC_DUCK_HULL_MIN[3]    = {-16.0, -16.0, -18.0 };
				static const Float:VEC_DUCK_HULL_MAX[3]    = { 16.0,  16.0,  18.0 };

				set_pev(victim, pev_flags, pev(victim, pev_flags) | FL_DUCKING);
				engfunc(EngFunc_SetSize, victim, VEC_DUCK_HULL_MIN, VEC_DUCK_HULL_MAX);
	    	}

			engfunc(EngFunc_SetOrigin, victim, fOrigin);
			reviving_attempt_effects( victim, target );
		}
	}
	else
	{
		pev(target, pev_origin, fOrigin);
		fOrigin[2] += 5.0;
		gib(fOrigin);
	}

	g_user_body[victim] = 0;
	return HAM_IGNORED;
}

public Event_ClCorpse( )
{
	if( !g_bMedicActive ) return;

	new szPlayerModel[64], Float:fOrigin[3], Float:fAngles[3];
	read_data(1, szPlayerModel, charsmax(szPlayerModel));
	format(szPlayerModel, charsmax(szPlayerModel), "models/player/%s/%s.mdl", szPlayerModel, szPlayerModel);

	fOrigin[0] = read_data(2) / 128.0;
	fOrigin[1] = read_data(3) / 128.0;
	fOrigin[2] = (read_data(4) / 128.0) + 2.0;

	fAngles[0] = 0.0; // read_data(5);
	fAngles[1] = float( read_data(6) );
	fAngles[2] = 0.0; // read_data(7);

	CreateCorpse( .victim=read_data(12), .szModel=szPlayerModel, .fOrigin=fOrigin, .fAngles=fAngles, .iDeathSequence=read_data(9))
}

CreateCorpse( const victim, const szModel[], const Float:fOrigin[3], const Float:fAngles[3], const iDeathSequence)
{
	if(!IsPlayer(victim) || g_user_body[victim] > 0 || !(TEAM_GUARDS >= get_user_team(victim) >= TEAM_PRISONERS) || is_user_alive(victim)) return PLUGIN_CONTINUE;
	
	new ent = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "info_target"));
	
	if(!ent) return PLUGIN_CONTINUE;

	g_user_body[victim] = ent;
	
	set_pev(ent, pev_classname, CORPSE_CLASSNAME);
	
	new Float:Mins[3], Float:Maxs[3], Float:fYaw = fAngles[1];
	if(pev(victim, pev_flags) & FL_DUCKING)
	{
		Mins = Float:{ -16.0, -1.0, -18.0 };
		Maxs = Float:{ 16.0, 72.0, -12.0 };
		set_pev(ent, pev_bInDuck, true);
	}
	else
	{
		Mins = Float:{ -16.0, -1.0, -36.0 };
		Maxs = Float:{ 16.0, 72.0, -30.0 };
		set_pev(ent, pev_bInDuck, false);
	}

	if( fYaw != 0.0 )
	{
		new Float:fvTemp[2];
		fvTemp[0] = Maxs[0] * floatcos(fYaw,degrees) - Maxs[1] * floatsin(fYaw,degrees);
		fvTemp[1] = Mins[0] * floatcos(fYaw,degrees) - Mins[1] * floatsin(fYaw,degrees);
		Maxs[0] = fvTemp[0];
		Mins[0] = fvTemp[1];

		if( Maxs[0] < Mins[0] )
		{
			Maxs[0] = fvTemp[1];
			Mins[0] = fvTemp[0];
		}

		fvTemp[0] = Maxs[0] * floatsin(fYaw,degrees) + Maxs[1] * floatcos(fYaw,degrees);
		fvTemp[1] = Mins[0] * floatsin(fYaw,degrees) + Mins[1] * floatcos(fYaw,degrees);
		Maxs[1] = fvTemp[0];
		Mins[1] = fvTemp[1];

		if( Maxs[1] < Mins[1] )
		{
			Maxs[1] = fvTemp[1];
			Mins[1] = fvTemp[0];
		}
	}
	
	set_pev(ent, pev_origin, fOrigin);
	set_pev(ent, pev_angles, fAngles);

	set_pev(ent, VICTIM_ID, victim);

	set_pev(ent, pev_owner, victim);
	set_pev(ent, pev_movetype, MOVETYPE_TOSS);
	set_pev(ent, pev_groupinfo, CORPSE_DIMENSION);

	engfunc(EngFunc_SetModel, ent, szModel);
	set_pev(ent, pev_solid, SOLID_BBOX);
	engfunc(EngFunc_SetSize, ent, Mins, Maxs);

	set_pev(ent, pev_modelindex, engfunc(EngFunc_ModelIndex, szModel));
	
	set_pev(ent, pev_body, pev(victim, pev_body));
	set_pev(ent, pev_skin, pev(victim, pev_skin));

	set_pev(ent, pev_health, 100.0);
	set_pev(ent, pev_takedamage, DAMAGE_AIM);
	
	set_pev(ent, SERIAL_KEY, SERIAL_NUMBER)
	
	set_pev(ent, pev_frame, 255.0);
	set_pev(ent, pev_sequence, iDeathSequence);
	
	set_pev(ent, pev_nextthink, get_gametime() + CORPSE_THINK_LEN);
	set_pev(ent, CORPSE_DECAYED, get_gametime());
	
	engfunc(EngFunc_DropToFloor, ent);
	
	return PLUGIN_CONTINUE;
}

gib(const Float:f_v_Origin[3])
{
	engfunc(EngFunc_MessageBegin, MSG_PVS, SVC_TEMPENTITY, f_v_Origin, 0);
	write_byte(TE_BREAKMODEL);

	engfunc(EngFunc_WriteCoord, f_v_Origin[0]);
	engfunc(EngFunc_WriteCoord, f_v_Origin[1]);
	engfunc(EngFunc_WriteCoord, f_v_Origin[2]);

	write_coord(32);
	write_coord(32);
	write_coord(32);

	write_coord(0);
	write_coord(0);
	write_coord(15);

	write_byte(20);

	write_short(g_Flesh_gibs);

	write_byte(8);
	write_byte(30);
	const BREAK_FLESH   =    0x04;
	write_byte(BREAK_FLESH);
	message_end();
}

reviving_attempt_effects(id, corpse)
{
	static iMsgDAMAGE = 0; iMsgDAMAGE = !iMsgDAMAGE ? get_user_msgid("Damage") : iMsgDAMAGE;

	static Float:fCoord[3];
	pev(id, pev_origin, fCoord);

	message_begin(MSG_ONE, iMsgDAMAGE, _, id);
	write_byte(	0 );
	write_byte(	0 );
	write_long( DMG_SHOCK | DMG_BURN | DMG_PARALYZE | DMG_ENERGYBEAM );
	engfunc(EngFunc_WriteCoord, fCoord[0]);
	engfunc(EngFunc_WriteCoord, fCoord[1]);
	engfunc(EngFunc_WriteCoord, fCoord[2]);
	message_end();

	pev(corpse, pev_origin, fCoord);

	// Sparks
	engfunc(EngFunc_MessageBegin, MSG_PVS, SVC_TEMPENTITY, fCoord, 0);
	write_byte(TE_SPARKS);
	engfunc(EngFunc_WriteCoord, fCoord[0]);
	engfunc(EngFunc_WriteCoord, fCoord[1]);
	engfunc(EngFunc_WriteCoord, fCoord[2] + 5.0);
	message_end();
}
