/* Plugin generated by AMXX-Studio */

#define REGAMEDLL 1

#include <amxmodx>
#include <rog>
#include <xs>
#include <cstrike>
#include <jailbreak_core>
#include <hamsandwich>
#include <fakemeta>
#include <engine>
#include <fun>
#include <nvault>

#if defined REGAMEDLL
#include <reapi>
#define ReturnIgnored FMRES_IGNORED
#define ReturnSupercede FMRES_SUPERCEDE
#else

#include <orpheu>
#include <orpheu_stocks>

#define ReturnIgnored OrpheuIgnored
#define ReturnSupercede OrpheuSupercede
#endif

#define PLUGIN "[JB] Death Realm"
#define AUTHOR "Natsheh"

//#pragma dynamic 4096

#define MODEL_MAX_PVS 128

#define IsPlayer(%1) (1 <= %1 <= 32)
#define Mask(%1) (1<<(%1&31))
#define ALL_REALMS 0xFFFFFFFF
#define MAX_REALMS 32
new WORLD_REALM = ALL_REALMS;
#define DEATH_REALM Mask(0)

#define MAX_ROG_SPAWNS 50

#define DEAD_REALMS 5

new const g_szUnitedEntities[][] = {
	"func_wall",
	"func_ladder",
	"func_water",
	"func_illusionary",
	"trigger_teleport",
	"trigger_hurt",
	"trigger_push",
	"trigger_gravity",
	"info_teleport_destination",
	"cycler_sprite"
}

enum (+=1000)
{
	TASK_DEATH_REALM_ARMOURY = 1000
}

#if !defined MAX_PLAYERS
#define MAX_PLAYERS 32
#endif

#if AMXX_VERSION_NUM > 182
#define client_disconnect client_disconnected
#endif

stock const PDATA_OFFSET_SAFE = 2;
#if !defined REGAMEDLL
stock const m_fDeadTime = 354;
stock const m_iRespawnFrames = 445;

stock const m_rgpPlayerItems = 367;
stock const m_pActiveItem = 373;
stock const MAX_ITEMS_TYPES = 6;
#endif
enum any:ENGINE_FUNCTIONS_SUB_MSGS(+=1)
{
	ENGINE_MESSAGE_WRITE_BYTE = 0,
	ENGINE_MESSAGE_WRITE_CHAR,
	ENGINE_MESSAGE_WRITE_SHORT,
	ENGINE_MESSAGE_WRITE_LONG,
	ENGINE_MESSAGE_WRITE_ANGLE,
	ENGINE_MESSAGE_WRITE_COORD,
	ENGINE_MESSAGE_WRITE_STRING,
	ENGINE_MESSAGE_WRITE_ENTITY,
	ENGINE_MESSAGE_END,
	ENGINE_MESSAGE_END_POST
}

new 	g_iREALMS_MENU = INVALID_HANDLE,
		g_iMSGID_CLCORPSE,
		g_iMSGID_DEATHMSG,
        Array:g_API_REALMS_ARRAY=Invalid_Array,
        g_API_REALMS_COUNT,
        g_FW_REALM_PLAYER_RESPAWN,
        g_FW_MENU_SELECT_REALM_PRE,
        g_FW_MENU_SELECT_REALM_POST,
        g_rog_count,
		any:g_pSubMessages_EngineFunctions[ENGINE_FUNCTIONS_SUB_MSGS],
		any:g_pSubMessages_Hook[ENGINE_FUNCTIONS_SUB_MSGS],
		g_szMapName[MAX_MAPNAME_LENGTH],
		g_nVault_spawns,

		g_iPlayer_Realm[MAX_PLAYERS+1],
		g_iPlayer_bitsEnemies[MAX_PLAYERS+1],
		g_iPlayer_bitsAllies[MAX_PLAYERS+1],
		g_bFirstSpawn[MAX_PLAYERS+1] = { true, true, ... };

enum any:MESSAGE_DATA(+=1)
{
	MSG_DEST = 0,
	MSG_TYPE,
	Float:MSG_ORIGIN[3],
	MSG_TARGET,
	Array:MSG_BYTE,
	Array:MSG_CHAR,
	Array:MSG_SHORT,
	Array:MSG_LONG,
	Array:MSG_ANGLE,
	Array:MSG_COORD,
	Array:MSG_STRING,
	Array:MSG_ENTITY,
	Array:MSG_ORDER
}

enum any:REALM_DATA
{
	REALM_NAME[32],
	REALM_ACCESS,
	REALM_MASK
}

new any:g_aMessage[MESSAGE_DATA],
		g_iTeamInfoMsgID = 0,
		g_iScoreAttribMsgID = 0,
		g_iSayTextMsgID = 0;

public plugin_end()
{
	if(g_iREALMS_MENU != INVALID_HANDLE) menu_destroy(g_iREALMS_MENU);
	if(g_API_REALMS_ARRAY != Invalid_Array)
    {
    	ArrayDestroy(g_API_REALMS_ARRAY);
        g_API_REALMS_COUNT = 0;
	}

	for(new i = MSG_BYTE; i <= MSG_ORDER; i++)
	{
		if(g_aMessage[ i ] != Invalid_Array)
		{
			ArrayDestroy(g_aMessage[ i ]);
			g_aMessage[ i ] = Invalid_Array;
		}
	}

	remove_task(TASK_DEATH_REALM_ARMOURY);

	ROGFree();
}

public plugin_natives()
{
	g_API_REALMS_ARRAY = ArrayCreate(REALM_DATA,1);

	if(g_API_REALMS_ARRAY != Invalid_Array)
	{
		new xArray[REALM_DATA];
		copy(xArray[REALM_NAME], charsmax(xArray[REALM_NAME]), "Death Realm");
		xArray[REALM_ACCESS] = 0;
		xArray[REALM_MASK] = DEATH_REALM;
		WORLD_REALM &= ~DEATH_REALM;
		g_API_REALMS_COUNT++;
		ArrayPushArray(g_API_REALMS_ARRAY, xArray);

		register_native("register_realm", "_reg_realm");
	}

	register_native("realm_get_world_mask", "_get_world_mask");
}

// native realm_get_world_mask();
public _get_world_mask(plugin, argc)
{
	return WORLD_REALM;
}

// register_realm(const realm_name[], iAccess);
public _reg_realm(plugin, argc)
{
	if(MAX_REALMS <= g_API_REALMS_COUNT)
    {
    	log_error(AMX_ERR_NATIVE, "Cannot register more realms (%d/%d)!", g_API_REALMS_COUNT, MAX_REALMS);
        return -1;
    }

	enum (+=1)
    {
    	PARAM_REALM_NAME = 1,
        PARAM_REALM_ACCESS
    }
    
	if(g_API_REALMS_ARRAY != Invalid_Array)
	{
		new xArray[REALM_DATA];
		get_string(PARAM_REALM_NAME, xArray[REALM_NAME], charsmax(xArray[REALM_NAME]));
		xArray[REALM_ACCESS] = get_param(PARAM_REALM_ACCESS);
		xArray[REALM_MASK] = Mask(g_API_REALMS_COUNT);
		WORLD_REALM &= ~Mask(g_API_REALMS_COUNT);
		ArrayPushArray(g_API_REALMS_ARRAY, xArray);
		g_API_REALMS_COUNT++;
		return xArray[REALM_MASK];
	}

	return 0; // invalid array id.
}

public plugin_cfg()
{
	create_realms_menu(g_iREALMS_MENU, "realms_menu_handler");

	new Trie:iTempTrie = TrieCreate();

	for(new i, maxloop = sizeof g_szUnitedEntities; i < maxloop; i++)
	{
		TrieSetString(iTempTrie, g_szUnitedEntities[i], "1");
	}

	for(new szClass[32], i = MAX_PLAYERS+1, iMaxEntities = global_get(glb_maxEntities); i <= iMaxEntities; i++)
	{
		if(pev_valid( i ))
		{
			pev(i, pev_classname, szClass, charsmax(szClass));

			if(TrieKeyExists(iTempTrie, szClass))
			{
				set_pev( i, pev_groupinfo, ALL_REALMS );
				continue;
			}

			set_pev( i, pev_groupinfo, WORLD_REALM );
		}
	}

	TrieDestroy(iTempTrie);

	arrayset(g_iPlayer_Realm, WORLD_REALM, sizeof g_iPlayer_Realm);
}

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR);

	RegisterHam(Ham_Spawn, "player", "fw_player_spawn_pre", false);
	RegisterHam(Ham_Spawn, "player", "fw_player_spawn_post", true);

	RegisterHam(Ham_TraceAttack, "player", "fw_player_traceattack_pre");
	RegisterHam(Ham_TraceAttack, "player", "fw_player_traceattack_post", true);

	RegisterHam(Ham_TakeDamage, "info_target", "fw_entity_takedamage_pre");
	RegisterHam(Ham_TakeDamage, "func_breakable", "fw_entity_takedamage_pre");
	RegisterHam(Ham_TakeDamage, "func_recharge", "fw_entity_takedamage_pre");
	RegisterHam(Ham_TakeDamage, "func_healthcharger", "fw_entity_takedamage_pre");

	RegisterHam(Ham_TakeDamage, "player", "fw_player_takedamage_pre");
	RegisterHam(Ham_TakeDamage, "player", "fw_player_takedamage_post", true);

	RegisterHam(Ham_Killed, "player", "fw_player_killed_pre");
	RegisterHam(Ham_Killed, "player", "fw_player_killed_post", true);

	RegisterHam(Ham_Use, "button_target", "fw_Use_Button_pre");
	RegisterHam(Ham_Use, "func_button", "fw_Use_Button_pre");
	RegisterHam(Ham_Use, "func_rot_button", "fw_Use_Button_pre");
	RegisterHam(Ham_Use, "func_healthcharger", "fw_Use_Button_pre");
	RegisterHam(Ham_Use, "func_recharge", "fw_Use_Button_pre");

	register_forward(FM_PlayerPreThink, "fw_player_postthink_pre", false);
	register_forward(FM_PlayerPreThink, "fw_player_postthink_post", true);

	register_forward(FM_PlayerPostThink, "fw_player_postthink_pre", false);
	register_forward(FM_PlayerPostThink, "fw_player_postthink_post", true);

	register_clcmd("say /realm", "clcmd_realm");
	register_clcmd("drop", "clcmd_drop");

	g_iMSGID_CLCORPSE = get_user_msgid("ClCorpse");
	g_iMSGID_DEATHMSG = get_user_msgid("DeathMsg");

#if defined REGAMEDLL
	RegisterHookChain( RG_CSGameRules_DeadPlayerWeapons, "fw_PackDeadPlayerItems_Pre", .post=false );
	RegisterHookChain( RG_CBasePlayer_StartDeathCam, "fw_StartDeathCam_Pre", .post=false );

	RegisterHookChain( RH_ED_Alloc, "fw_ED_Alloc_Post", .post=true );

	register_forward(FM_Touch, "fw_fm_touch_pre", 		0);
	register_forward(FM_Touch, "fw_fm_touch_post", 		1);
#else
	OrpheuRegisterHook( OrpheuGetDLLFunction("pfnTouch", "pfnTouch"), "fw_pfnTouch_pre", OrpheuHookPre );
	OrpheuRegisterHook( OrpheuGetDLLFunction("pfnTouch", "pfnTouch"), "fw_pfnTouch_post", OrpheuHookPost );
	OrpheuRegisterHook( OrpheuGetDLLFunction("pfnSpawn", "pfnSpawn"), "fw_pfnSpawn_Post", OrpheuHookPost );

	OrpheuRegisterHook( OrpheuGetEngineFunction("pfnSetModel", "pfnSetModel"), "fw_SetModel_post", OrpheuHookPost );
	OrpheuRegisterHook( OrpheuGetFunction("PlayerDeathThink", "CBasePlayer"), "fw_PlayerDeathThink_Pre" );

	OrpheuRegisterHook( OrpheuGetFunction("PackDeadPlayerItems", "CBasePlayer"), "fw_PackDeadPlayerItems_Pre", OrpheuHookPre);
#endif
	g_iTeamInfoMsgID = get_user_msgid("TeamInfo");
	g_iScoreAttribMsgID = get_user_msgid("ScoreAttrib");
	g_iSayTextMsgID = get_user_msgid("SayText");

	OrpheuRegisterHook( OrpheuGetEngineFunction("pfnMessageBegin", "pfnMessageBegin"), "fw_pfnMessageBegin_Pre", OrpheuHookPre );
	g_pSubMessages_EngineFunctions[ENGINE_MESSAGE_END] = g_pSubMessages_EngineFunctions[ENGINE_MESSAGE_END_POST] = OrpheuGetEngineFunction("pfnMessageEnd", "pfnMessageEnd");
	g_pSubMessages_EngineFunctions[ENGINE_MESSAGE_WRITE_BYTE] = OrpheuGetEngineFunction("pfnWriteByte", "pfnWriteByte");
	g_pSubMessages_EngineFunctions[ENGINE_MESSAGE_WRITE_CHAR] = OrpheuGetEngineFunction("pfnWriteChar", "pfnWriteChar");
	g_pSubMessages_EngineFunctions[ENGINE_MESSAGE_WRITE_SHORT] = OrpheuGetEngineFunction("pfnWriteShort", "pfnWriteShort");
	g_pSubMessages_EngineFunctions[ENGINE_MESSAGE_WRITE_LONG] = OrpheuGetEngineFunction("pfnWriteLong", "pfnWriteLong");
	g_pSubMessages_EngineFunctions[ENGINE_MESSAGE_WRITE_ANGLE] = OrpheuGetEngineFunction("pfnWriteAngle", "pfnWriteAngle");
	g_pSubMessages_EngineFunctions[ENGINE_MESSAGE_WRITE_COORD] = OrpheuGetEngineFunction("pfnWriteCoord", "pfnWriteCoord");
	g_pSubMessages_EngineFunctions[ENGINE_MESSAGE_WRITE_STRING] = OrpheuGetEngineFunction("pfnWriteString", "pfnWriteString");
	g_pSubMessages_EngineFunctions[ENGINE_MESSAGE_WRITE_ENTITY] = OrpheuGetEngineFunction("pfnWriteEntity", "pfnWriteEntity");
    
	g_FW_MENU_SELECT_REALM_PRE = CreateMultiForward("realm_menu_select_pre", ET_CONTINUE, FP_CELL, FP_CELL, FP_STRING, FP_STRING);
	g_FW_MENU_SELECT_REALM_POST = CreateMultiForward("realm_menu_select_post", ET_IGNORE, FP_CELL, FP_CELL, FP_STRING, FP_STRING);
	g_FW_REALM_PLAYER_RESPAWN = CreateMultiForward("realm_player_respawn", ET_IGNORE, FP_CELL, FP_CELL);

	g_nVault_spawns = nvault_open("realm_spawns");

	get_mapname(g_szMapName, charsmax(g_szMapName));

	new szKey[MAX_MAPNAME_LENGTH + 16]
	formatex(szKey, charsmax(szKey), "%s_MAX_SPAWNS", g_szMapName);
	new iSpawns = nvault_get(g_nVault_spawns, szKey);

	if(iSpawns > 0)
	{
	    FoundOriginsArray = ArrayCreate(3);
	    LoadSpawns(g_nVault_spawns, iSpawns);
	    g_rog_count = iSpawns;
	}
	else
	{
	    ROGInitialize(1000.0, "ROG_SpawnCheck");
	}

	nvault_close(g_nVault_spawns);

	set_task(1.0, "DeathRealm_Spawn_Armoury", TASK_DEATH_REALM_ARMOURY, _, _, "a", g_rog_count);
}

new const Float:PLAYER_SIZE[] = { -16.0, -16.0, -36.0, 16.0, 16.0, 36.0 };

public ROG_SpawnCheck(Float:fOrigin[3])
{
	if(!check_spawn_valid(fOrigin, PLAYER_SIZE) || (g_rog_count >= MAX_ROG_SPAWNS))
		return 0;

	if(g_nVault_spawns != INVALID_HANDLE)
	{
	    static iMaxSpawns = 0, szKey[MAX_MAPNAME_LENGTH + 16], szValue[68];

	    formatex(szKey, charsmax(szKey), "%s_#%d", g_szMapName, ++iMaxSpawns);
	    formatex(szValue, charsmax(szValue), "^"%.14f^" ^"%.14f^" ^"%.14f^"", fOrigin[0], fOrigin[1], fOrigin[2]);
	    nvault_set(g_nVault_spawns, szKey, szValue);

	    formatex(szKey, charsmax(szKey), "%s_MAX_SPAWNS", g_szMapName);
	    num_to_str(iMaxSpawns, szValue, charsmax(szValue));
	    nvault_set(g_nVault_spawns, szKey, szValue);
	}

	g_rog_count++;
	return 1;
}

LoadSpawns(nvault, iMaxSpawns)
{
    if(nvault != INVALID_HANDLE)
    {
        new szKey[MAX_MAPNAME_LENGTH + 16], szValue[68], szfOrigin[3][16], Float:fOrigin[3], iTimestamp;
        for(new i; i < iMaxSpawns; i++)
        {
            formatex(szKey, charsmax(szKey), "%s_#%d", g_szMapName, i + 1);
            if(nvault_lookup(nvault, szKey, szValue, charsmax(szValue), iTimestamp))
            {
                parse(szValue, szfOrigin[0], charsmax(szfOrigin[]), szfOrigin[1], charsmax(szfOrigin[]), szfOrigin[2], charsmax(szfOrigin[]));
                remove_quotes(szfOrigin[0]);
                remove_quotes(szfOrigin[1]);
                remove_quotes(szfOrigin[2]);

                fOrigin[0] = floatstr(szfOrigin[0]);
                fOrigin[1] = floatstr(szfOrigin[1]);
                fOrigin[2] = floatstr(szfOrigin[2]);

                ArrayPushArray(FoundOriginsArray, fOrigin);
            }
        }
    }
}

check_spawn_valid(Float:fOrigin[3], const Float:SIZE[6], const ignore_ent = 0)
{
	static ent = 0, Float:fMaxs[2][3], Float:fMins[2][3], Float:fDamage;

	fMaxs[0][0] = fOrigin[0] + SIZE[3];
	fMaxs[0][1] = fOrigin[1] + SIZE[4];
	fMaxs[0][2] = fOrigin[2] + SIZE[5];
	fMins[0][0] = fOrigin[0] + SIZE[0];
	fMins[0][1] = fOrigin[1] + SIZE[1];
	fMins[0][2] = fOrigin[2] + SIZE[2];

	while( (ent = find_ent_by_class(ent, "func_water")) )
	{
		pev(ent, pev_dmg, fDamage);
		if(fDamage <= 0.0) continue;

		pev(ent, pev_absmax, fMaxs[1]);
		pev(ent, pev_absmin, fMins[1]);

		if ( check_collision(fMaxs[0], fMins[0], fMaxs[1], fMins[1]) ) {
			return false;
		}

	}

	while( (ent = find_ent_by_class(ent, "trigger_hurt")) )
	{
		pev(ent, pev_dmg, fDamage);
		if(fDamage < 0.0) continue;

		pev(ent, pev_absmax, fMaxs[1]);
		pev(ent, pev_absmin, fMins[1]);

		if ( check_collision(fMaxs[0], fMins[0], fMaxs[1], fMins[1]) ) {
			return false;
		}

	}

	while( (ent = find_ent_by_class(ent, "trigger_push")) )
	{
		pev(ent, pev_absmax, fMaxs[1]);
		pev(ent, pev_absmin, fMins[1]);

		if ( check_collision(fMaxs[0], fMins[0], fMaxs[1], fMins[1]) ) {
			return false;
		}

	}

	while( (ent = find_ent_by_class(ent, "trigger_teleport")) )
	{
		pev(ent, pev_absmax, fMaxs[1]);
		pev(ent, pev_absmin, fMins[1]);

		if ( check_collision(fMaxs[0], fMins[0], fMaxs[1], fMins[1]) ) {
			return false;
		}

	}

	new OLD_SOLID, bValid;
	if( ignore_ent )
	{
		OLD_SOLID = pev(ignore_ent, pev_solid);
		set_pev(ignore_ent, pev_solid, SOLID_NOT);
	}

	bValid = ValidSpotFound(fOrigin);
	if( ignore_ent ) set_pev(ignore_ent, pev_solid, OLD_SOLID);

	return bValid;
}

check_collision( Float:absmax1[3], Float:absmin1[3], Float:absmax2[3], Float:absmin2[3] ) {

	if( (absmin1[0] > absmax2[0]) ||
		(absmin1[1] > absmax2[1]) ||
		(absmin1[2] > absmax2[2]) ||
		(absmin2[0] > absmax1[0]) ||
		(absmin2[1] > absmax1[1]) ||
		(absmin2[2] > absmax1[2]) ) return false;

	return true;
}

public DeathRealm_Spawn_Armoury(taskid)
{
	new Float:fOrigin[3];
	ROGGetOrigin(fOrigin);

	ArmourySpawn(fOrigin, random_num(CSA_MP5NAVY, CSA_M249));
	ArmourySpawn(fOrigin, CSA_HEGRENADE);
	ArmourySpawn(fOrigin, CSA_FLASHBANG);
}

ArmourySpawn(const Float:fOrigin[3], const iWeaponType, const iCount = 1)
{
	new ent = create_entity("armoury_entity");

	if(!ent) return;

	set_ent_data(ent, "CArmoury", "m_iItem", iWeaponType);
	set_ent_data(ent, "CArmoury", "m_iCount", max(iCount, 1));
	set_ent_data(ent, "CArmoury", "m_iInitialCount", max(iCount, 1));

	engfunc(EngFunc_SetModel, ent, "models/w_weaponbox.mdl");
	engfunc(EngFunc_SetSize, ent, Float:{ -16.0, -16.0, -0.0 }, Float:{ 16.0, 16.0, 16.0 });
	engfunc(EngFunc_SetOrigin, ent, fOrigin);

	set_pev(ent, pev_solid, SOLID_TRIGGER);
	set_pev(ent, pev_movetype, MOVETYPE_TOSS);

	dllfunc(DLLFunc_Spawn, ent);

	set_pev(ent, pev_groupinfo, DEATH_REALM);
}

AddMessageSubStrData(const MESSAGE_DATA:iMsgDataType, const szValue[], const iMsgDataTypeArgument)
{
	if(g_aMessage[ iMsgDataType ] == Invalid_Array)
	{
		g_aMessage[ iMsgDataType ] = ArrayCreate(512,1);
	}

	ArrayPushCell(g_aMessage[ MSG_ORDER ], iMsgDataTypeArgument);
	ArrayPushString(g_aMessage[ iMsgDataType ], szValue);
}

AddMessageSubData(const MESSAGE_DATA:iMsgDataType, any:value, const iMsgDataTypeArgument)
{
	if(g_aMessage[ iMsgDataType ] == Invalid_Array)
	{
		g_aMessage[ iMsgDataType ] = ArrayCreate(1,1);
	}

	ArrayPushCell(g_aMessage[ MSG_ORDER ], iMsgDataTypeArgument);
	ArrayPushCell(g_aMessage[ iMsgDataType ], value);
}

public any:fw_pfnMessageBegin_Pre( const dest, const type, Float:fOrigin[3], const player_edict )
{
	switch( dest )
	{
		case MSG_ALL, MSG_BROADCAST, MSG_PVS, MSG_PVS_R, MSG_PAS, MSG_PAS_R:
		{
			if(type == g_iTeamInfoMsgID || type == g_iScoreAttribMsgID || type == g_iSayTextMsgID)
			{
				g_aMessage[ MSG_DEST ] = -1;
				return ReturnIgnored;
			}

			g_aMessage[ MSG_DEST ] = dest;

			g_pSubMessages_Hook[ ENGINE_MESSAGE_WRITE_BYTE ] = OrpheuRegisterHook( OrpheuFunction:g_pSubMessages_EngineFunctions[ENGINE_MESSAGE_WRITE_BYTE], "fw_pfnWriteByte_Pre", OrpheuHookPre );
			g_pSubMessages_Hook[ ENGINE_MESSAGE_WRITE_CHAR ] = OrpheuRegisterHook( OrpheuFunction:g_pSubMessages_EngineFunctions[ENGINE_MESSAGE_WRITE_CHAR], "fw_pfnWriteChar_Pre", OrpheuHookPre );
			g_pSubMessages_Hook[ ENGINE_MESSAGE_WRITE_SHORT ] = OrpheuRegisterHook( OrpheuFunction:g_pSubMessages_EngineFunctions[ENGINE_MESSAGE_WRITE_SHORT], "fw_pfnWriteShort_Pre", OrpheuHookPre );
			g_pSubMessages_Hook[ ENGINE_MESSAGE_WRITE_LONG ] = OrpheuRegisterHook( OrpheuFunction:g_pSubMessages_EngineFunctions[ENGINE_MESSAGE_WRITE_LONG], "fw_pfnWriteLong_Pre", OrpheuHookPre );
			g_pSubMessages_Hook[ ENGINE_MESSAGE_WRITE_ANGLE ] = OrpheuRegisterHook( OrpheuFunction:g_pSubMessages_EngineFunctions[ENGINE_MESSAGE_WRITE_ANGLE], "fw_pfnWriteAngle_Pre", OrpheuHookPre );
			g_pSubMessages_Hook[ ENGINE_MESSAGE_WRITE_COORD ] = OrpheuRegisterHook( OrpheuFunction:g_pSubMessages_EngineFunctions[ENGINE_MESSAGE_WRITE_COORD], "fw_pfnWriteCoord_Pre", OrpheuHookPre );
			g_pSubMessages_Hook[ ENGINE_MESSAGE_WRITE_STRING ] = OrpheuRegisterHook( OrpheuFunction:g_pSubMessages_EngineFunctions[ENGINE_MESSAGE_WRITE_STRING], "fw_pfnWriteString_Pre", OrpheuHookPre );
			g_pSubMessages_Hook[ ENGINE_MESSAGE_WRITE_ENTITY ] = OrpheuRegisterHook( OrpheuFunction:g_pSubMessages_EngineFunctions[ENGINE_MESSAGE_WRITE_ENTITY], "fw_pfnWriteEntity_Pre", OrpheuHookPre );
			g_pSubMessages_Hook[ ENGINE_MESSAGE_END ] = OrpheuRegisterHook( OrpheuFunction:g_pSubMessages_EngineFunctions[ENGINE_MESSAGE_END], "fw_pfnMessageEnd_Pre", OrpheuHookPre );
			g_pSubMessages_Hook[ ENGINE_MESSAGE_END_POST ] = OrpheuRegisterHook( OrpheuFunction:g_pSubMessages_EngineFunctions[ENGINE_MESSAGE_END_POST], "fw_pfnMessageEnd_Post", OrpheuHookPost );
		}
		default:
		{
			g_aMessage[ MSG_DEST ] = -1;
			return ReturnIgnored;
		}
	}

	if(g_aMessage[ MSG_ORDER ] == Invalid_Array)
	{
		g_aMessage[ MSG_ORDER ] = ArrayCreate(1,1);
	}

	g_aMessage[ MSG_TYPE ] = type;
	g_aMessage[ MSG_ORIGIN ][0] = fOrigin[0];
	g_aMessage[ MSG_ORIGIN ][1] = fOrigin[1];
	g_aMessage[ MSG_ORIGIN ][2] = fOrigin[2];
#if defined REGAMEDLL
	g_aMessage[ MSG_TARGET ] = player_edict;
#else
	g_aMessage[ MSG_TARGET ] = !player_edict ? 0 : ENTINDEX(player_edict);
#endif
	return ReturnSupercede;
}

public any:fw_pfnMessageEnd_Post( )
{
	OrpheuUnregisterHook( OrpheuHook:g_pSubMessages_Hook[ENGINE_MESSAGE_END_POST] );
	OrpheuUnregisterHook( OrpheuHook:g_pSubMessages_Hook[ENGINE_MESSAGE_END] );
	OrpheuUnregisterHook( OrpheuHook:g_pSubMessages_Hook[ENGINE_MESSAGE_WRITE_BYTE] );
	OrpheuUnregisterHook( OrpheuHook:g_pSubMessages_Hook[ENGINE_MESSAGE_WRITE_CHAR] );
	OrpheuUnregisterHook( OrpheuHook:g_pSubMessages_Hook[ENGINE_MESSAGE_WRITE_SHORT] );
	OrpheuUnregisterHook( OrpheuHook:g_pSubMessages_Hook[ENGINE_MESSAGE_WRITE_LONG] );
	OrpheuUnregisterHook( OrpheuHook:g_pSubMessages_Hook[ENGINE_MESSAGE_WRITE_ANGLE] );
	OrpheuUnregisterHook( OrpheuHook:g_pSubMessages_Hook[ENGINE_MESSAGE_WRITE_COORD] );
	OrpheuUnregisterHook( OrpheuHook:g_pSubMessages_Hook[ENGINE_MESSAGE_WRITE_STRING] );
	OrpheuUnregisterHook( OrpheuHook:g_pSubMessages_Hook[ENGINE_MESSAGE_WRITE_ENTITY] );

	static iDest;
	switch( g_aMessage[ MSG_DEST ] )
	{
		case MSG_ALL, MSG_PAS_R, MSG_PVS_R: iDest = MSG_ONE;
		case MSG_BROADCAST, MSG_PAS, MSG_PVS: iDest = MSG_ONE_UNRELIABLE;
		default: return ReturnIgnored;
	}

	static szString[512], players[MAX_PLAYERS], Float:fOrigin[3], pnum, target, i, iOrderSize, iCurrentOrder,
		iByte=0, iChar=0, iShort=0, iLong=0, iAngle=0, iCoord=0, iEntity=0, iString=0,
		iMsgDest, iMsgType, iRealm;

	iRealm = WORLD_REALM;

	if(IsPlayer(g_aMessage[ MSG_TARGET ]))
	{
		iRealm = g_iPlayer_Realm[ g_aMessage[ MSG_TARGET ] ];
	}
	else {

		switch( g_aMessage[ MSG_TYPE ] )
		{
			case SVC_TEMPENTITY:
			{
				switch( (iMsgType=ArrayGetCell(g_aMessage[ MSG_BYTE ], 0)) )
				{
					case TE_BEAMENTS, TE_BEAMFOLLOW, TE_BEAMRING,
					  TE_ELIGHT, TE_KILLBEAM, TE_DECAL, TE_FIZZ,
					  TE_GUNSHOTDECAL, TE_PLAYERDECAL,
					  TE_DECALHIGH : if(g_aMessage[ MSG_SHORT ] != Invalid_Array) iRealm = pev( ArrayGetCell(g_aMessage[ MSG_SHORT ], 0), pev_groupinfo );
					case TE_PLAYERATTACHMENT, TE_KILLPLAYERATTACHMENTS : if(g_aMessage[ MSG_BYTE ] != Invalid_Array) iRealm = pev( ArrayGetCell(g_aMessage[ MSG_BYTE ], 1), pev_groupinfo );
					default:
					{
						if(g_aMessage[ MSG_COORD ] != Invalid_Array && ArraySize(g_aMessage[ MSG_COORD ]) >= 3)
						{
							fOrigin[0] = ArrayGetCell(g_aMessage[ MSG_COORD ], 0);
							fOrigin[1] = ArrayGetCell(g_aMessage[ MSG_COORD ], 1);
							fOrigin[2] = ArrayGetCell(g_aMessage[ MSG_COORD ], 2);
							target = -1;

							static Float:fEntOrigin[3], szBrushModel[2];

							// player here's in not just an actual player entity but rather an any entity.
							while( (target = find_ent_in_sphere(target, fOrigin, 300.0)) > 0 )
							{
								if(pev_valid(target) == PDATA_OFFSET_SAFE)
								{
									// Brush entity ?
									pev(target, pev_model, szBrushModel, 1);

									if(szBrushModel[0] == '*')
									{
										get_brush_entity_origin(target, fEntOrigin);

										if(fEntOrigin[0] == fOrigin[0] && fEntOrigin[1] == fOrigin[1])
										{
											iRealm = pev(target, pev_groupinfo);
											break;
										}
									}
									else
									{
										pev(target, pev_origin, fEntOrigin);

										if(fEntOrigin[0] == fOrigin[0] && fEntOrigin[1] == fOrigin[1])
										{
											iRealm = pev(target, pev_groupinfo);
											break;
										}
									}
								}
							}
						}
					}
				}
			}
			default:
			{
				if(g_aMessage[ MSG_TYPE ] == g_iMSGID_CLCORPSE)
				{
					if(g_aMessage[ MSG_BYTE ] != Invalid_Array)
					{
						i = ArrayGetCell(g_aMessage[ MSG_BYTE ], 3);

						if( IsPlayer(i) )
						{
							iRealm = g_iPlayer_Realm[ i ];
						}
					}
				}
				else if(g_aMessage[ MSG_TYPE ] == g_iMSGID_DEATHMSG)
				{
					if(g_aMessage[ MSG_BYTE ] != Invalid_Array)
					{
						i = ArrayGetCell(g_aMessage[ MSG_BYTE ], 1);

						if( IsPlayer(i) )
						{
							iRealm = g_iPlayer_Realm[ i ];
						}
					}
				}
			}
		}
	}

	iMsgDest = g_aMessage[ MSG_DEST ];
	iMsgType = g_aMessage[ MSG_TYPE ];

	g_aMessage[ MSG_DEST ] = -1;
	g_aMessage[ MSG_TYPE ] = SVC_BAD;
	g_aMessage[ MSG_TARGET ] = 0;

	fOrigin[0] = g_aMessage[ MSG_ORIGIN ][0];
	fOrigin[1] = g_aMessage[ MSG_ORIGIN ][1];
	fOrigin[2] = g_aMessage[ MSG_ORIGIN ][2];

	iOrderSize = ArraySize(g_aMessage[ MSG_ORDER ]);

	get_players(players, pnum, "c");

	for(iCurrentOrder = i = 0; i < pnum; i++)
	{
		target = players[ i ];

		if(iRealm != 0 && g_iPlayer_Realm[ target ] != iRealm)
		{
			continue;
		}

		if(iMsgDest == MSG_PVS || iMsgDest == MSG_PVS_R)
		{
			if(!IsOriginInPlayerPVS(target, fOrigin))
			{
				continue;
			}
		}
		else if(iMsgDest == MSG_PAS || iMsgDest == MSG_PAS_R)
		{
			if(!IsOriginInPlayerPVS(target, fOrigin))
			{
				continue;
			}
		}

		engfunc(EngFunc_MessageBegin, iDest, iMsgType, fOrigin, target);
		while( iCurrentOrder < iOrderSize )
		{
			switch(ArrayGetCell(g_aMessage[ MSG_ORDER ], iCurrentOrder++) )
			{
				case ARG_BYTE: write_byte( ArrayGetCell(g_aMessage[ MSG_BYTE ], iByte++) );
				case ARG_CHAR: write_char( ArrayGetCell(g_aMessage[ MSG_CHAR ], iChar++) );
				case ARG_SHORT: write_short( ArrayGetCell(g_aMessage[ MSG_SHORT ], iShort++) );
				case ARG_LONG: write_long( ArrayGetCell(g_aMessage[ MSG_LONG ], iLong++) );
				case ARG_ANGLE: write_angle_f( ArrayGetCell(g_aMessage[ MSG_ANGLE ], iAngle++) );
				case ARG_COORD: write_coord_f( ArrayGetCell(g_aMessage[ MSG_COORD ], iCoord++) );
				case ARG_ENTITY: write_entity( ArrayGetCell(g_aMessage[ MSG_ENTITY ], iEntity++) );
				case ARG_STRING:
				{
					ArrayGetString(g_aMessage[ MSG_STRING ], iString++, szString, charsmax(szString));
					write_string( szString );
				}
			}
		}
		message_end();

		iCurrentOrder = iByte = iChar = iShort = iLong = iAngle = iCoord = iEntity = iString = 0;
	}

	for(i = MSG_BYTE; i <= MSG_ORDER; i++)
	{
		if(g_aMessage[ i ] != Invalid_Array)
		{
			ArrayDestroy(g_aMessage[ i ]);
			g_aMessage[ i ] = Invalid_Array;
		}
	}

	return ReturnIgnored;
}

public any:fw_pfnMessageEnd_Pre( )
{
	if(g_aMessage[ MSG_DEST ] == -1) return ReturnIgnored;
	return ReturnSupercede;
}

public any:fw_pfnWriteByte_Pre( const value )
{
	if(g_aMessage[ MSG_DEST ] == -1) return ReturnIgnored;

	AddMessageSubData(MSG_BYTE, value, ARG_BYTE);
	return ReturnSupercede;
}

public any:fw_pfnWriteChar_Pre( const value )
{
	if(g_aMessage[ MSG_DEST ] == -1) return ReturnIgnored;

	AddMessageSubData(MSG_CHAR, value, ARG_CHAR);
	return ReturnSupercede;
}

public any:fw_pfnWriteShort_Pre( const value )
{
	if(g_aMessage[ MSG_DEST ] == -1) return ReturnIgnored;

	AddMessageSubData(MSG_SHORT, value, ARG_SHORT);
	return ReturnSupercede;
}

public any:fw_pfnWriteLong_Pre( const value )
{
	if(g_aMessage[ MSG_DEST ] == -1) return ReturnIgnored;

	AddMessageSubData(MSG_LONG, value, ARG_LONG);
	return ReturnSupercede;
}

public any:fw_pfnWriteAngle_Pre( const Float:fValue )
{
	if(g_aMessage[ MSG_DEST ] == -1) return ReturnIgnored;

	AddMessageSubData(MSG_ANGLE, fValue, ARG_ANGLE);
	return ReturnSupercede;
}

public any:fw_pfnWriteCoord_Pre( const Float:fValue )
{
	if(g_aMessage[ MSG_DEST ] == -1) return ReturnIgnored;

	AddMessageSubData(MSG_COORD, fValue, ARG_COORD);
	return ReturnSupercede;
}

public any:fw_pfnWriteString_Pre( const szValue[] )
{
	if(g_aMessage[ MSG_DEST ] == -1) return ReturnIgnored;

	AddMessageSubStrData(MSG_STRING, szValue, ARG_STRING);
	return ReturnSupercede;
}

public any:fw_pfnWriteEntity_Pre( const value )
{
	if(g_aMessage[ MSG_DEST ] == -1) return ReturnIgnored;

	AddMessageSubData(MSG_ENTITY, value, ARG_ENTITY);
	return ReturnSupercede;
}

public fw_Use_Button_pre(ent, caller)
{
	if( IsPlayer(caller) && g_iPlayer_Realm[ caller ] !=  WORLD_REALM )
	{
		return HAM_SUPERCEDE;
	}

	return HAM_IGNORED;
}

public client_command(id)
{
	if( is_user_alive(id) ||  g_iPlayer_Realm[ id ] ==  WORLD_REALM ) return PLUGIN_CONTINUE;

	static szCmd[24];
	read_argv(0, szCmd, charsmax(szCmd));

	remove_quotes(szCmd);
	trim(szCmd);

	if( equal(szCmd, "weapon_", 7) )
	{
		new ent = find_ent_by_owner(-1, szCmd, id);

		if(pev_valid(ent))
		{
			set_pev(id, pev_deadflag, DEAD_NO);
			engclient_cmd(id, szCmd);
			set_pev(id, pev_deadflag, DEAD_REALMS);
			return PLUGIN_HANDLED_MAIN;
		}
	}
	else if( equal(szCmd, "lastinv") )
	{
		set_pev(id, pev_deadflag, DEAD_NO);
		engclient_cmd(id, szCmd);
		set_pev(id, pev_deadflag, DEAD_REALMS);
		return PLUGIN_HANDLED_MAIN;
	}

	return PLUGIN_CONTINUE;
}

public clcmd_drop(id)
{
	if( is_user_alive(id) ||  g_iPlayer_Realm[ id ] ==  WORLD_REALM ) return PLUGIN_CONTINUE;

	new szWeaponClassname[24], ent;
	read_argv(1, szWeaponClassname, charsmax(szWeaponClassname));

	remove_quotes(szWeaponClassname);
	trim(szWeaponClassname);

	if(!szWeaponClassname[0])
	{
		if( (ent = get_ent_data_entity(id, "CBasePlayer", "m_pActiveItem")) > 0 )
		{
			pev(ent, pev_classname, szWeaponClassname, charsmax(szWeaponClassname));
		}
	}
	else
	{
		ent = find_ent_by_owner(-1, szWeaponClassname, id);
	}

	if(pev_valid(ent))
	{
		set_pev(id, pev_deadflag, DEAD_NO);
		engclient_cmd(id, "drop", szWeaponClassname);
		set_pev(id, pev_deadflag, DEAD_REALMS);
		return PLUGIN_HANDLED_MAIN;
	}

	return PLUGIN_CONTINUE;
}

UpdateEntityRealm(const ent)
{
	if(IsPlayer(ent) || !pev_valid(ent)) return;

	static iOwner;
	iOwner = pev( ent, pev_owner );

	if(IsPlayer(iOwner))
	{
		set_pev(ent, pev_groupinfo, g_iPlayer_Realm[ iOwner ]);
	}
	else
	{
		if(pev_valid(iOwner))
		{
			new iGroup = pev(iOwner, pev_groupinfo);
			set_pev(ent, pev_groupinfo, !iGroup ? WORLD_REALM : iGroup);
		}
		else /* Belongs to the world ? */ {
			set_pev(ent, pev_groupinfo, WORLD_REALM);
		}

		if( pev(ent, pev_spawnflags) & SF_NORESPAWN )
		{
			static players[32], pnum, i;
			get_players(players, pnum, "h");
			for( i = 0; i < pnum; i++ )
			{
				iOwner = players[ i ];

				if(entity_range( iOwner, ent ) <= 1.0)
				{
					set_pev(ent, pev_groupinfo, g_iPlayer_Realm[ iOwner ]);
					break;
				}
			}
		}
	}
}

ENTINDEX(const edict)
{
	static OrpheuFunction:function;

	if (!function)
    {
        function = OrpheuGetEngineFunction("pfnIndexOfEdict", "IndexOfEdict");
    }

	return OrpheuCall(function, edict);
}

#if !defined REGAMEDLL
public OrpheuHookReturn:fw_SetModel_post(const edict, const szModel[])
{
	UpdateEntityRealm( ENTINDEX(edict) );
}

public fw_pfnSpawn_Post(const edict_ent)
{
	UpdateEntityRealm( ENTINDEX(edict_ent) );
}

public any:fw_pfnTouch_pre( const edict_this, const edict_toucher )
{
	if(!edict_toucher)
		return ReturnIgnored;

	static toucher;
	toucher = ENTINDEX(edict_toucher);

	if(!IsPlayer(toucher))
		return ReturnIgnored;

	if( g_iPlayer_Realm[ toucher ] !=  WORLD_REALM )
	{
		set_pev(toucher, pev_deadflag, DEAD_NO);
		return ReturnIgnored;
	}

	return ReturnIgnored;
}

public any:fw_pfnTouch_post( const edict_this, const edict_toucher )
{
	if(!edict_toucher)
		return ReturnIgnored;

	static toucher;
	toucher = ENTINDEX(edict_toucher);

	if(!IsPlayer(toucher))
		return ReturnIgnored;

	if( g_iPlayer_Realm[ toucher ] !=  WORLD_REALM )
	{
		set_pev(toucher, pev_deadflag, DEAD_REALMS);
		return ReturnIgnored;
	}

	return ReturnIgnored;
}
#else
public fw_ED_Alloc_Post()
{
	new ent = GetHookChainReturn(ATYPE_EDICT);
	UpdateEntityRealm( ent );
	server_print("ent: %d, Owner: %d", ent, pev(ent, pev_owner))
}

public RealmPlayerDeathThink( const id )
{
	// Nothing :)
}

public pfn_spawn( ent )
{
	UpdateEntityRealm( ent );
}

public fw_fm_touch_pre( this, toucher )
{
	if(!IsPlayer(toucher))
		return ReturnIgnored;

	if( g_iPlayer_Realm[ toucher ] !=  WORLD_REALM )
	{
		set_pev(toucher, pev_deadflag, DEAD_NO);
		return ReturnIgnored;
	}

	return ReturnIgnored;
}

public fw_fm_touch_post( this, toucher )
{
	if(!IsPlayer(toucher))
		return ReturnIgnored;

	if( g_iPlayer_Realm[ toucher ] !=  WORLD_REALM )
	{
		set_pev(toucher, pev_deadflag, DEAD_REALMS);
		return ReturnIgnored;
	}

	return ReturnIgnored;
}
#endif

public fw_player_postthink_pre(id)
{
	if( g_iPlayer_Realm[ id ] !=  WORLD_REALM )
	{
		set_pev(id, pev_deadflag, DEAD_NO);
	}
}

public fw_player_postthink_post(id)
{
	if( g_iPlayer_Realm[ id ] !=  WORLD_REALM )
	{
		set_pev(id, pev_deadflag, DEAD_REALMS);
	}
}

#if defined REGAMEDLL
public any:fw_StartDeathCam_Pre(const id)
#else
public any:fw_PlayerDeathThink_Pre(const id)
#endif
{
	if( IsPlayer(id) && g_iPlayer_Realm[ id ] !=  WORLD_REALM )
	{
		#if defined REGAMEDLL
		return HC_SUPERCEDE;
		#else
		return ReturnSupercede;
		#endif
	}

	#if defined REGAMEDLL
	return HC_CONTINUE;
	#else
	return ReturnIgnored;
	#endif

}

public any:fw_PackDeadPlayerItems_Pre(const id)
{
	if( IsPlayer(id) && g_iPlayer_Realm[ id ] !=  WORLD_REALM )
	{
#if defined REGAMEDLL
		SetHookChainReturn(ATYPE_INTEGER, 0);
		return HC_SUPERCEDE;
#else
		return ReturnSupercede;
#endif
	}

#if defined REGAMEDLL
	SetHookChainReturn(ATYPE_INTEGER, 1);
	return HC_CONTINUE;
#else
	return ReturnIgnored;
#endif
}

public fw_player_traceattack_pre(victim, attacker, Float:fDamage, DamageBits, iTr)
{
	if( g_iPlayer_Realm[ victim ] !=  WORLD_REALM )
	{
		set_pev(victim, pev_deadflag, DEAD_NO);
	}

	if(attacker == victim || g_iPlayer_Realm[ victim ] == 0) return HAM_IGNORED;

	if(!IsPlayer(attacker) && pev_valid(attacker))
	{
		attacker = pev_valid( pev(attacker, pev_owner) ) ? pev(attacker, pev_owner) : attacker;
	}

	if( (IsPlayer(attacker) && !(g_iPlayer_Realm[ victim ] & g_iPlayer_Realm[ attacker ])) ||
		(pev_valid(attacker) && !(g_iPlayer_Realm[ victim ] & pev(attacker, pev_groupinfo))) )
	{
		SetHamParamFloat(3, 0.0);
		return HAM_SUPERCEDE;
	}

	return HAM_IGNORED;
}

public fw_player_traceattack_post(victim, attacker, Float:fDamage, DamageBits, iTr)
{
	if( g_iPlayer_Realm[ victim ] !=  WORLD_REALM )
	{
		set_pev(victim, pev_deadflag, DEAD_REALMS);
	}

	return HAM_IGNORED;
}

public fw_entity_takedamage_pre(victim, inflictor, attacker, Float:fDamage, DamageBits)
{
	if(!IsPlayer(attacker) && pev_valid(attacker))
	{
		attacker = pev_valid( pev(attacker, pev_owner) ) ? pev(attacker, pev_owner) : attacker;
	}

	static iBitsVicGroupInfo;
	iBitsVicGroupInfo = pev(victim, pev_groupinfo);

	if(iBitsVicGroupInfo == 0)
	{
		return HAM_IGNORED;
	}

	if( IsPlayer(attacker) )
	{
		if(!(g_iPlayer_Realm[ attacker ] & iBitsVicGroupInfo))
		{
			SetHamParamFloat(4, 0.0);
			return HAM_SUPERCEDE;
		}
	}
	else if( pev_valid(attacker) && !(pev(attacker, pev_groupinfo) & iBitsVicGroupInfo) ) {
			SetHamParamFloat(4, 0.0);
			return HAM_SUPERCEDE;
	}

	return HAM_IGNORED;
}

public fw_player_takedamage_pre(victim, inflictor, attacker, Float:fDamage, DamageBits)
{
	if( g_iPlayer_Realm[ victim ] !=  WORLD_REALM )
	{
		set_pev(victim, pev_deadflag, DEAD_NO);
	}

	if(attacker == victim || g_iPlayer_Realm[ victim ] == 0) return HAM_IGNORED;

	if(!IsPlayer(attacker) && pev_valid(attacker))
	{
		attacker = pev_valid( pev(attacker, pev_owner) ) ? pev(attacker, pev_owner) : attacker;
	}

	if( (IsPlayer(attacker) && !(g_iPlayer_Realm[ victim ] & g_iPlayer_Realm[ attacker ])) ||
		(pev_valid(attacker) && !(g_iPlayer_Realm[ victim ] & pev(attacker, pev_groupinfo))) )
	{
		SetHamParamFloat(4, 0.0);
		return HAM_SUPERCEDE;
	}

	return HAM_IGNORED;
}

public fw_player_takedamage_post(victim, inflictor, attacker, Float:fDamage, DamageBits)
{
	if( g_iPlayer_Realm[ victim ] !=  WORLD_REALM )
	{
		set_pev(victim, pev_deadflag, DEAD_REALMS);
	}

	return HAM_IGNORED;
}

public fw_player_killed_pre(victim, killer, shouldgib)
{
	if( g_iPlayer_Realm[ victim ] !=  WORLD_REALM )
	{
		new szWeaponName[32], iWeapon, iInflictor = pev(victim, pev_dmg_inflictor);

		if(pev_valid(iInflictor))
		{
			if(IsPlayer(killer) && iInflictor == killer)
			{
				iWeapon = get_ent_data_entity(killer, "CBasePlayer", "m_pActiveItem");
			}

			if(iWeapon > 0)
			{
				pev(iWeapon, pev_classname, szWeaponName, charsmax(szWeaponName));
			}
			else
			{
				pev(iInflictor, pev_classname, szWeaponName, charsmax(szWeaponName));
			}
		}

		message_begin(MSG_ALL, g_iMSGID_DEATHMSG, {0,0,0}, 0);
		write_byte(!IsPlayer(killer) ? 0 : killer);
		write_byte(victim);
		write_byte(bool:get_ent_data(victim, "CBasePlayer", "m_bHeadshotKilled"));
		write_string(szWeaponName[7]);
		message_end();

		set_pev(victim, pev_effects, pev(victim, pev_effects) | EF_NODRAW);
		set_pev(victim, pev_deadflag, DEAD_NO);
		set_pev(victim, pev_solid, SOLID_NOT);
		SetHamParamInteger(3, GIB_ALWAYS);
		return HAM_SUPERCEDE;
	}

	return HAM_IGNORED;
}

public fw_player_killed_post(victim, killer, shouldgib)
{
	if(g_iPlayer_Realm[ victim ] == WORLD_REALM)
	{
		remove_task(victim);
		cprint_chat(victim, _, "You can play in another realm by typing !g/realm !tin the chat!");
	}
	else
	{
#if defined REGAMEDLL
		new Float:flGlobalTime;
		SetThink(victim, "RealmPlayerDeathThink");
		global_get(glb_time, flGlobalTime);
		set_pev(victim, pev_nextthink, flGlobalTime + 0.1);
#endif
		set_pev(victim, pev_deadflag, DEAD_REALMS);
		set_task(1.0, "task_player_spawndead", victim);
	}

	return HAM_IGNORED;
}

public client_putinserver(id)
{
	g_iPlayer_Realm[ id ] = WORLD_REALM;
}

public client_disconnect(id)
{
	g_bFirstSpawn[id] = true;
	remove_task(id);
}

create_realms_menu(&p_iMenu, const mhandler[])
{
	p_iMenu = menu_create("Join a realm!", mhandler);

	new iItemsCount;

	menu_additem(p_iMenu, "\rThe Real World Realm^n^n", "-1");
	iItemsCount++;
    
	new iCallback = menu_makecallback("realm_menu_item_callback");
	
	menu_additem(p_iMenu, "Death Realm", "0", 0, iCallback);
	iItemsCount++;

	if(g_API_REALMS_COUNT > 1)
	{
		for(new i = 1, xArray[REALM_DATA], szItemID[16]; i < g_API_REALMS_COUNT; i++)
		{
			num_to_str(i, szItemID, charsmax(szItemID));
			ArrayGetArray(g_API_REALMS_ARRAY, i, xArray);
			menu_additem(p_iMenu, xArray[REALM_NAME], szItemID, 0, iCallback);
			iItemsCount++;
		}
	}

	return iItemsCount;
}

public realm_menu_item_callback(id, menu, item)
{
	if(item > 0)
	{
		new xArray[REALM_DATA];
		ArrayGetArray(g_API_REALMS_ARRAY, item-1, xArray);
		return (!xArray[REALM_ACCESS] || (get_user_flags(id) & xArray[REALM_ACCESS])) ? ITEM_ENABLED : ITEM_DISABLED;
	}
	
	return ITEM_IGNORE;
}

public realms_menu_handler(const id, const menu, item)
{
	if(item == MENU_EXIT || item < 0 || is_user_alive(id))
	{
		return PLUGIN_HANDLED;
	}

	new Wanted_Realm, szWantedRealm[32];

	// First item in the menu which is ( Real World Realm ).
	if(item == 0)
	{
		Wanted_Realm = WORLD_REALM;
		copy(szWantedRealm, charsmax(szWantedRealm), "Real World");
	}
	else
	{
		item --;

		new xArray[REALM_DATA];
		ArrayGetArray(g_API_REALMS_ARRAY, item, xArray);
		copy(szWantedRealm, charsmax(szWantedRealm), xArray[REALM_NAME]);

		Wanted_Realm = xArray[REALM_MASK];
	}

	if(g_iPlayer_Realm[ id ] == Wanted_Realm)
	{
		client_print(id, print_center, "You're already in this realm!");
		menu_display(id, menu);
		return PLUGIN_HANDLED;
	}
	
	new iReturn, szCurrRealm[32];

	if(g_iPlayer_Realm[ id ] == WORLD_REALM)
	{
		copy(szCurrRealm, charsmax(szCurrRealm), "Real World");
		g_iPlayer_bitsEnemies[id] = jb_get_user_enemies(id);
		g_iPlayer_bitsAllies[id] = jb_get_user_allies(id);
	}
	else
	{
		for(new i, xArray[REALM_DATA]; i < g_API_REALMS_COUNT; i++)
		{
 			if(Mask(i) == g_iPlayer_Realm[ id ])
 			{
				ArrayGetArray(g_API_REALMS_ARRAY, i, xArray);
				copy(szCurrRealm, charsmax(szCurrRealm), xArray[REALM_NAME]);
				break;
			}
		}
	}

	// realm_menu_select_pre(id, mask_realm, const newrealm_name[], const oldrealm_name[]);
	ExecuteForward(g_FW_MENU_SELECT_REALM_PRE, iReturn, id, Wanted_Realm, szWantedRealm, szCurrRealm);

	if(iReturn >= PLUGIN_HANDLED) return PLUGIN_HANDLED;

	set_player_realm(Wanted_Realm, id);

	// realm_menu_select_post(id, mask_realm, const newrealm_name[], const oldrealm_name[]);
	ExecuteForward(g_FW_MENU_SELECT_REALM_POST, iReturn, id, Wanted_Realm, szWantedRealm, szCurrRealm);

	return PLUGIN_HANDLED;
}

public jb_day_ended(iDayid)
{
	arrayset(g_iPlayer_bitsEnemies, JB_ENEMIES_DEFAULT, sizeof g_iPlayer_bitsEnemies);
	arrayset(g_iPlayer_bitsAllies, JB_ALLIES_DEFAULT, sizeof g_iPlayer_bitsAllies);
}

public clcmd_realm(id)
{
	if(is_user_alive(id))
	{
		cprint_chat(id, _, "You must be dead inorder to change !trealms!g!");
		return PLUGIN_HANDLED;
	}

	menu_display(id, g_iREALMS_MENU);
	return PLUGIN_HANDLED;
}

public fw_player_spawn_pre(id)
{
	if(g_bFirstSpawn[id])
	{
		return;
	}

	if(g_iPlayer_Realm[ id ] != WORLD_REALM)
	{
		new szCurrRealm[32];
		for(new i, xArray[REALM_DATA]; i < g_API_REALMS_COUNT; i++)
		{
			if(Mask(i) == g_iPlayer_Realm[ id ])
			{
				ArrayGetArray(g_API_REALMS_ARRAY, i, xArray);
				copy(szCurrRealm, charsmax(szCurrRealm), xArray[REALM_NAME]);
				break;
			}
		}

		new iReturn;
		// realm_menu_select_pre(id, mask_realm, const newrealm_name[], const oldrealm_name[]);
		ExecuteForward(g_FW_MENU_SELECT_REALM_PRE, iReturn, id, WORLD_REALM, "Real World", szCurrRealm);

		if(iReturn >= PLUGIN_HANDLED) return;

		jb_set_user_enemies(id, g_iPlayer_bitsEnemies[id]);
		jb_set_user_allies(id, g_iPlayer_bitsAllies[id]);
		set_pev(id, pev_deadflag, DEAD_NO);
		g_iPlayer_Realm[ id ] = WORLD_REALM;

		// realm_menu_select_post(id, mask_realm, const newrealm_name[], const oldrealm_name[]);
		ExecuteForward(g_FW_MENU_SELECT_REALM_POST, iReturn, id, WORLD_REALM, "Real World", szCurrRealm);
	}

	if(pev(id, pev_groupinfo) != WORLD_REALM)
	{
		set_pev(id, pev_groupinfo, WORLD_REALM);
	}
}

public fw_player_spawn_post(id)
{
	if(g_bFirstSpawn[id])
	{
		g_bFirstSpawn[id] = false;
		return;
	}

	// remove the other realms revive task.
	remove_task(id);

	if(g_iPlayer_Realm[ id ] != pev(id, pev_groupinfo))
	{
		set_pev(id, pev_groupinfo, g_iPlayer_Realm[ id ]);
	}
}

public task_player_spawndead(id)
{
	set_player_realm(g_iPlayer_Realm[ id ], id);
}

set_player_realm(const iRealm, const id)
{
	if(iRealm != WORLD_REALM)
	{
		jb_set_user_enemies(id, JB_ENEMIES_EVERYONE);
		jb_set_user_allies(id, JB_ALLIES_DEFAULT);
		jb_block_user_weapons(id, false);

		static iMsgID_ScoreAttrib = 0; if(!iMsgID_ScoreAttrib) iMsgID_ScoreAttrib = get_user_msgid("ScoreAttrib");
		ExecuteHam(Ham_Spawn, id);

		new Float:fOrigin[3];
		ROGGetOrigin(fOrigin);
		engfunc(EngFunc_SetOrigin, id, fOrigin);

		strip_user_weapons(id);
		give_item(id, "weapon_knife");
		set_pev(id, pev_deadflag, DEAD_REALMS);
		set_pev(id, pev_solid, SOLID_SLIDEBOX);
		set_pev(id, pev_movetype, MOVETYPE_WALK);
		set_pev(id, pev_health, 100.0);
		set_user_rendering(id);

		const SCOREATTRIBUTE_FLAG_DEAD = (1<<0);
		emessage_begin(MSG_ALL, iMsgID_ScoreAttrib);
		ewrite_byte(id);
		ewrite_byte(SCOREATTRIBUTE_FLAG_DEAD);
		emessage_end();

		new iRet;
		ExecuteForward(g_FW_REALM_PLAYER_RESPAWN, iRet, id, iRealm);
	}
	else if(g_iPlayer_Realm[ id ] != WORLD_REALM)
	{
		strip_user_weapons(id);
		set_pev(id, pev_effects, pev(id, pev_effects) | EF_NODRAW);

		jb_set_user_enemies(id, g_iPlayer_bitsEnemies[id]);
		jb_set_user_allies(id, g_iPlayer_bitsAllies[id]);
		jb_block_user_weapons(id, false);

		user_silentkill(id, .flag = 1);
		set_msg_block(g_iMSGID_CLCORPSE, BLOCK_ONCE);
		set_pev(id, pev_deadflag, DEAD_REALMS);

		// Remove all belongings to the player from the previous realm.
		for(new iPreviousRealm = g_iPlayer_Realm[ id ], i = MAX_PLAYERS + 1, iMaxEntities = global_get(glb_maxEntities); i <= iMaxEntities; i++)
		{
			if(pev_valid( i ) && pev(i, pev_groupinfo) == iPreviousRealm && pev(i, pev_owner) == id)
			{
				set_pev(i, pev_flags, FL_KILLME);
				dllfunc(DLLFunc_Think, i);
			}
		}
	}

	remove_task(id);
	g_iPlayer_Realm[ id ] = iRealm;
	set_pev(id, pev_groupinfo, iRealm);
}

// Is Origin in player's potentially view set?
bool:IsOriginInPlayerPVS(const id, const Float:fOrigin[3])
{
    static iEnt = 0, next, Float:fEntOrigin[3];

    if( !iEnt )
    {
    	new sClass[32];

    	while( (iEnt = find_ent_by_class(iEnt, "info_target")) > 0 )
    	{
    		if(pev(iEnt, pev_flags) & FL_WORLDBRUSH)
    		{
    			pev(iEnt, pev_classname, sClass, charsmax(sClass));

    			if(equal(sClass, "PVS_#4935784"))
    			{
    				break;
    			}
    		}
    	}

    	if( !iEnt )
	    {
	 	   iEnt = create_entity("info_target");

	 	   set_pev(iEnt, pev_flags, FL_WORLDBRUSH);
	 	   set_pev(iEnt, pev_netname, "PVS_#4935784");
	 	}
    }

    if( iEnt )
    {
        engfunc(EngFunc_SetOrigin, iEnt, fOrigin);

        next = engfunc(EngFunc_EntitiesInPVS, id);

        while( next )
        {
            pev(next, pev_origin, fEntOrigin);

            if( xs_vec_equal(fOrigin, fEntOrigin) )
            {
                return true;
            }

            next = pev(next, pev_chain);
        }

        return false;
    }

    return false;
}
