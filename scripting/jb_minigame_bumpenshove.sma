/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <jailbreak_core>
#include <jb_minigames_core>
#include <hamsandwich>
#include <fakemeta>
#include <xs>

#define PLUGIN "[JB] MINIGAMES: BUMP & SHOVE"
#define AUTHOR "Natsheh"

#define IsPlayer(%1) (1 <= %1 <= 32)

new MINIGAME_INDEX, HamHook:g_fw_HamTakeDamage, HamHook:g_fw_HamTraceAttack, HamHook:g_fw_ham_player_traceattack_post, HamHook:g_fw_ham_player_touch_post, g_pcvar_shove_force, g_pcvar_bump_force;

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	g_pcvar_shove_force = register_cvar("jb_minigame_bumpenshove_shove_force", "380");
	g_pcvar_bump_force = register_cvar("jb_minigame_bumpenshove_bump_force", "300");
	
	DisableHamForward( (g_fw_ham_player_traceattack_post=RegisterHam(Ham_TraceAttack, "player", "fw_player_traceattack_post", true)) );
	DisableHamForward( (g_fw_ham_player_touch_post=RegisterHam(Ham_Touch, "player", "fw_player_touch_post", true)) );
	DisableHamForward( (g_fw_HamTraceAttack = RegisterHam(Ham_TraceAttack, "player", "fw_traceattack_player_pre")));
	DisableHamForward( (g_fw_HamTakeDamage = RegisterHam(Ham_TakeDamage, "player", "fw_takedamage_pre")));

	MINIGAME_INDEX = register_jb_minigame("Bump & Shove", "fw_bumpshove_handle");
}

public fw_traceattack_player_pre(victim, attacker, Float:damage, Float:direction[3], traceresults, dmgbits)
{
	if(!IsPlayer(attacker) || victim == attacker) return HAM_IGNORED;
	
	if(jb_is_user_inminigame(victim) != MINIGAME_INDEX ||
		jb_is_user_inminigame(attacker) != MINIGAME_INDEX)
			return HAM_IGNORED;
	
	SetHamParamFloat(3, 0.0);
	return HAM_SUPERCEDE;
}

public fw_takedamage_pre(victim, inflictor, attacker, Float:damage, dmgbits)
{
	if(!IsPlayer(attacker) || victim == attacker) return HAM_IGNORED;
	
	if((jb_is_user_inminigame(victim) != MINIGAME_INDEX ||
		jb_is_user_inminigame(attacker) != MINIGAME_INDEX))
			return HAM_IGNORED;
	
	set_pev(victim, pev_punchangle, Float:{0.0,0.0,0.0});
	SetHamParamFloat(4, 0.0);
	return HAM_SUPERCEDE;
}

public fw_player_touch_post(id, toucher)
{
	if(!IsPlayer(toucher)) return;
    
	// is it possible for dead players to touch ?
	 /* if( !is_user_alive(id) || !is_user_alive(toucher) ) return; */ 
	
	if(jb_is_user_inminigame(id) != MINIGAME_INDEX ||
		jb_is_user_inminigame(toucher) != MINIGAME_INDEX)
			return;
	
	// lets bump that mother f***er
	static Float:fVelo[3], Float:fForce; fForce = get_pcvar_float(g_pcvar_bump_force);
	if(fForce == 0.0)
	{
		pev(toucher, pev_velocity, fVelo);
		set_pev(id, pev_velocity, fVelo);
		return;
	}
	
	pev(toucher, pev_velocity, fVelo);

	if(xs_vec_len(fVelo) <= 0.0) return;

	xs_vec_normalize(fVelo, fVelo);
	xs_vec_mul_scalar(fVelo, fForce, fVelo);
	set_pev(id, pev_velocity, fVelo);
}

public fw_player_traceattack_post(victim, attacker, Float:fDamage, Float:fDirection[3], traceresults, dmgbits)
{
	if(!IsPlayer(attacker) || victim == attacker) return;
	
	if(jb_is_user_inminigame(victim) != MINIGAME_INDEX ||
		jb_is_user_inminigame(attacker) != MINIGAME_INDEX)
			return;
	
	// lets shove that mother f***er
	static Float:fVelo[3];
	xs_vec_copy(fDirection, fVelo);
	xs_vec_mul_scalar(fVelo, get_pcvar_float(g_pcvar_shove_force), fVelo);
	set_pev(victim, pev_velocity, fVelo);
}

public jb_minigame_ended(const Minigame_Index, const MINIGAMES_MODES:Minigame_Mode, const Winner, bits_players)
{
	if(Minigame_Index == MINIGAME_INDEX)
	{
		DisableHamForward(g_fw_ham_player_traceattack_post);
		DisableHamForward(g_fw_ham_player_touch_post);
		DisableHamForward(g_fw_HamTraceAttack);
		DisableHamForward(g_fw_HamTakeDamage);
	}
}

public fw_bumpshove_handle( minigame_index, minigame_mode, minigame_players[33], teams[MAX_MINIGAMES_TEAMS], maxteams, players_num, bits_players )
{
	EnableHamForward(g_fw_ham_player_traceattack_post);
	EnableHamForward(g_fw_ham_player_touch_post);
	EnableHamForward(g_fw_HamTraceAttack);
	EnableHamForward(g_fw_HamTakeDamage);
}
