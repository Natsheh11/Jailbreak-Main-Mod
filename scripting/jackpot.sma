/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <nvault>
#include <cstrike>
#include <jailbreak_core>

#define PLUGIN "Jackpot"
#define AUTHOR "Natsheh"

#define get_user_money(%1) jb_get_user_cash(%1)
#define set_user_money(%1,%2) jb_set_user_cash(%1,%2)

#define MAX_PLAYERS 32

#define TASK_JACKPOT_STARTED 5656783
	
const MAX_CHANCES = 100;

new chances_reserved[MAX_CHANCES][32], Trie:user_injackpot, Jackpot_money,
 jackpot_participates, Array:users_participated, Trie:user_chances;

new Float:jackpot_delay, jackpot_rolling, g_cvar_one, g_cvar_two, nVault;

native jailbreak_reg_gambling_game(const func_target[], const gamble_gamename[], gamble_minimum_amount=1000, gamble_game_access=0);

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	//register_clcmd("say", "clcmd_jackpot")
	//register_clcmd("say_team", "clcmd_jackpot")
	
	g_cvar_one = register_cvar("jackpot_cooldown", "60")
	g_cvar_two = register_cvar("jackpot_rolling_duration", "90")
	
	user_injackpot = TrieCreate();
	user_chances = TrieCreate();
	users_participated = ArrayCreate(32,1);
	
	nVault = nvault_open("jackpot_vault");
	
	if(nVault == INVALID_HANDLE)
	{
		set_fail_state("Error opening nvault!");
	}
	
	new szAmount[16], timestmp;
	if(nvault_lookup(nVault, "TOTAL_PARTICIPATERS", szAmount, charsmax(szAmount), timestmp))
	{
		Jackpot_money = nvault_get(nVault, "JACKPOT_MONEY");
		new Float:fJackpot_money = float(Jackpot_money);
		jackpot_participates = str_to_num(szAmount);
		for(new i, j, sAuthid[32], iAmount, start, iChance, iChances; i < jackpot_participates; i++)
		{
			num_to_str(i, szAmount, charsmax(szAmount))
			nvault_get(nVault, szAmount, sAuthid, charsmax(sAuthid))
			nvault_get(nVault, sAuthid, szAmount, charsmax(szAmount))
			
			iAmount = str_to_num(szAmount);
			ArrayPushString(users_participated, sAuthid);
			TrieSetCell(user_injackpot, sAuthid, iAmount);
			iChance = floatround((iAmount / fJackpot_money) * MAX_CHANCES);
			iChances = min((iChances + iChance), MAX_CHANCES);
			TrieSetCell(user_chances, sAuthid, iChance);
			
			for(j = start; j < iChances; j++)
			{
				chances_reserved[j] = sAuthid;
			}
			
			start = iChances;
		}
		
		jackpot_rolling = nvault_get(nVault, "JACKPOT_ROLLING");
		if(jackpot_participates > 1) set_task(1.0, "task_jackpot_rolling", TASK_JACKPOT_STARTED, _, _, "b");
	}
	
	jailbreak_reg_gambling_game("jb_jackpot", "Jackpot", 1000, 0);
}

public jb_jackpot(id, gambling_amount, minimum_amount, access)
{
	if(access > 0 && !(get_user_flags(id) & access))
	{
		cprint_chat(id, _, "You have no access to the !gjackpot!");
		return;
	}
	
	if(gambling_amount < minimum_amount)
	{
		cprint_chat(id, _, "no enough cash to gamble in the jackpot");
		return;
	}
	
	new szAmount[16];
	num_to_str(gambling_amount, szAmount, charsmax(szAmount));
	Join_Jackpot(id, szAmount);
}

public client_putinserver(id)
{
	new szText[48], timestmp;
	get_user_authid(id, szText, charsmax(szText));
	format(szText, charsmax(szText), "WINNER_%s", szText);
	if(nvault_lookup(nVault, szText, "", 0, timestmp))
	{
		set_task(3.0, "task_win_jackpot", id, szText, sizeof szText);
	}
}

public task_win_jackpot(szParam[], id)
{
	if(!is_user_connected(id)) return;
	
	new winamount = nvault_get(nVault, szParam);
	client_print(id, print_chat, "Congratulation you have won the jackpot, win amount: %d$ !", winamount)
	set_user_money(id,get_user_money(id)+winamount);
	nvault_remove(nVault, szParam);
}

public clcmd_jackpot(id)
{
	new szArgs[48];
	read_args(szArgs, charsmax(szArgs))
	remove_quotes(szArgs)
	
	new szCmd[16], szAmount[16];
	strtok(szArgs, szCmd, charsmax(szCmd), szAmount, charsmax(szAmount), ' ');
	
	if(!equali(szCmd, "/jackpot")) return 0;

	Join_Jackpot(id, szAmount);
	return 1;
}

Join_Jackpot(const id, szAmount[16])
{
	new Float:different = (jackpot_delay - get_gametime());
	if(different > 0.0)
	{
		client_print(id, print_chat, "Jackpot is available in %.2f seconds!", different)
		return 0;
	}
	
	new iAmount = str_to_num(szAmount), Float:fTemp_money = float(Jackpot_money);
	
	if(iAmount <= 0)
	{
		client_print(id, print_chat, "Please enter a positive value in the jackpot!")
		return 0;
	}
	if(get_user_money(id) < iAmount)
	{
		client_print(id, print_chat, "Sorry but you don't have this amount of money!")
		return 0;
	}
	
	set_user_money(id,get_user_money(id)-iAmount)
	fTemp_money += float(iAmount);

	new sAuthid[32], xAmount;
	get_user_authid(id, sAuthid, charsmax(sAuthid))
	
	if(!(xAmount = has_user_participated(id)))
	{
		ArrayPushString(users_participated, sAuthid)
		
		num_to_str(jackpot_participates, szAmount, charsmax(szAmount))
		nvault_set(nVault, szAmount, sAuthid)
		
		num_to_str(++jackpot_participates, szAmount, charsmax(szAmount))
		nvault_set(nVault, "TOTAL_PARTICIPATERS", szAmount)
	}
	
	xAmount += iAmount;
	TrieSetCell(user_injackpot, sAuthid, xAmount);
	num_to_str(xAmount, szAmount, charsmax(szAmount));
	nvault_set(nVault, sAuthid, szAmount);

	new szKeyName[64], szName[32];
	get_user_name(id, szName, charsmax(szName));
	formatex(szKeyName, charsmax(szKeyName), "NAME_%s", sAuthid);
	nvault_set(nVault, szKeyName, szName);
	
	// update users chances.
	for(new i, start, iChance, iChances, player, j; i < jackpot_participates; i++)
	{
		ArrayGetString(users_participated, i, sAuthid, charsmax(sAuthid))
		TrieGetCell(user_injackpot, sAuthid, iAmount)
		iChance = floatround((iAmount / fTemp_money) * MAX_CHANCES);
		iChances += iChance;
		TrieSetCell(user_chances, sAuthid, iChance);
		
		if((player = is_user_connected_byauthid(sAuthid)))
		{
			client_print(player, print_chat, "your chance of winning in the Jackpot is %d %%%% .", iChance)
		}
		
		if(iChances > MAX_CHANCES) iChances = MAX_CHANCES;
		
		for(j = start; j < iChances; j++)
		{
			chances_reserved[j] = sAuthid;
		}
		
		start = iChances;
	}
	
	Jackpot_money = floatround(fTemp_money);
	
	num_to_str(Jackpot_money, szAmount, charsmax(szAmount))
	nvault_set(nVault, "JACKPOT_MONEY", szAmount)
	
	if(!task_exists(TASK_JACKPOT_STARTED) && jackpot_participates > 1)
	{
		jackpot_rolling = clamp(get_pcvar_num(g_cvar_two), 10, 99999999999);
		set_task(1.0, "task_jackpot_rolling", TASK_JACKPOT_STARTED, _, _, "b");
	}
	
	switch( jackpot_rolling )
	{
		case 0: client_print(0, print_chat, "%s has added %d$ in the Jackpot and the total amount is %d$ and its rolling soon!", szName, xAmount, Jackpot_money)
		default: client_print(0, print_chat, "%s has added %d$ in the Jackpot and the total amount is %d$ and its rolling in %d seconds!", szName, xAmount, Jackpot_money, jackpot_rolling)
	}
	return 1;
}

public plugin_end()
{
	remove_task(TASK_JACKPOT_STARTED);

	ArrayDestroy(users_participated)
	TrieDestroy(user_injackpot)
	TrieDestroy(user_chances)
	nvault_close(nVault)
}

public task_jackpot_rolling(taskid)
{
	if(!jackpot_rolling && jackpot_rolling != -999)
	{
		remove_task(taskid);
		
		set_hudmessage(0, 255, 0, -1.0, 0.27, 2, 2.0, 2.0, _, _, -1)
		show_hudmessage(0, "^n^n^nThe Winner In The JackPot is.....")
		jackpot_rolling = -999;
		jackpot_delay = floatclamp(get_pcvar_float(g_cvar_one), 10.0, 99999999999.0) + get_gametime() + 4.0;
		set_task(2.0, "task_jackpot_rolling", TASK_JACKPOT_STARTED);
		return;
	}
	if(jackpot_rolling == -999)
	{
		SortCustom2D(chances_reserved, sizeof chances_reserved, "chances_reserved_sorting");
		new winner, szWinnerName[32], szWinnerAuthID[32], rand = random(MAX_CHANCES);
		if( !(winner = is_user_connected_byauthid(chances_reserved[rand])))
		{
			new szKeyName[64];
			szWinnerName = chances_reserved[rand];
			szWinnerAuthID = szWinnerName;
			formatex(szKeyName, charsmax(szKeyName), "NAME_%s", szWinnerAuthID);
			nvault_get(nVault, szKeyName, szWinnerName, charsmax(szWinnerName));
		}
		else
		{
			get_user_name(winner, szWinnerName, charsmax(szWinnerName));
		}
		
		set_hudmessage(0, 255, 0, -1.0, 0.27, 1, 2.0, 3.0, 0.05, 0.05, 4);
		show_hudmessage(0, "^n^n^n^n%s", szWinnerName);
		client_print(0, print_chat, "%s has won the Jackpot!", szWinnerName);
		
		jackpot_participates = 0;
		ArrayClear(users_participated);
		TrieClear(user_injackpot);
		TrieClear(user_chances);
		nvault_prune(nVault, 0, get_systime());
		for(new i; i < sizeof chances_reserved; i++) arrayset(chances_reserved[i], 0, sizeof chances_reserved[]);
		
		if(!winner)
		{
			new szText[48], szAmount[20];
			num_to_str(Jackpot_money, szAmount, charsmax(szAmount));
			formatex(szText, charsmax(szText), "WINNER_%s", szWinnerAuthID);
			nvault_pset(nVault, szText, szAmount);
		}
		else
		{
			client_print(winner, print_chat, "Congratulation you have won the jackpot, win amount: %d$.", Jackpot_money);
			set_user_money(winner,get_user_money(winner)+Jackpot_money);
		}
		
		Jackpot_money = 0;
		jackpot_rolling = 0;
		
		remove_task(taskid);
		return;
	}
	
	for(new i, sAuthid[32], player, xChance, szTime[10]; i < jackpot_participates; i++)
	{
		ArrayGetString(users_participated, i, sAuthid, charsmax(sAuthid))
		
		if(!(player = is_user_connected_byauthid(sAuthid))) continue;
		
		TrieGetCell(user_chances, sAuthid, xChance)
		format_time(szTime, charsmax(szTime), "%M:%S", jackpot_rolling);
		set_hudmessage(0, 255, 0, -1.0, 0.27, 2, 2.0, 0.90, 0.05, 0.05, 4);
		show_hudmessage(player, "Jackpot Rolling in %s^nJackpot Amount of money: %d$^nYour Chance of Winning: %d%%", szTime, Jackpot_money, xChance);
	}
	
	new szAmount[20];
	num_to_str(jackpot_rolling, szAmount, charsmax(szAmount))
	nvault_set(nVault, "JACKPOT_ROLLING", szAmount)
	jackpot_rolling--;
}

public chances_reserved_sorting(elementOne[], elementTwo[])
{
	if(random_num(1, 2) == 1)
	{
		return 1;
	}

	return -1;
}

has_user_participated(id)
{
	new sAuthid[32];
	get_user_authid(id, sAuthid, charsmax(sAuthid))
	
	if(!TrieKeyExists(user_injackpot, sAuthid)) return 0;
	
	new xAmount;
	TrieGetCell(user_injackpot, sAuthid, xAmount)
	
	return xAmount;
}

stock is_user_connected_byauthid(const authid[32])
{
	new players[32], pnum;
	get_players(players, pnum, "ch")
	
	for(new i, sAuthid[32], player; i < pnum; i++)
	{
		player = players[i];
		get_user_authid(player, sAuthid, charsmax(sAuthid))
		if(equal(authid, sAuthid))
		{
			return player;
		}
	}
	
	return 0;
}

