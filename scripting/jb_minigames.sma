/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <jailbreak_core>
#include <hamsandwich>
#include <fakemeta>
#include <cs_player_models_api>
#include <xs>
#include <inc_get_team_fix>

#define PLUGIN "[JB] MINIGAMES SYSTEM"
#define AUTHOR "Natsheh"

#define is_valid_client(%1)	((g_iMaxplayers >= %1 >= 1) ? true:false)

#define TASK__XXXXX__ 476536

#define MAX_MINIGAME_TEAMS 16
#define MAX_MINIGAME_NAME 32

#define MINIGAME_NO_WINNER 0

// returns commander id, if no commander was found returns 0.
native jb_get_commander();

#define OFFSET_TEAM	114
#define fm_get_user_team(%1)	get_pdata_int(%1,OFFSET_TEAM)
#define fm_set_user_team(%1,%2)	set_pdata_int(%1,OFFSET_TEAM,%2)

#if !defined EOS
#define EOS 0
#endif

#define ADMIN_NOACCESS (1<<26)

enum any:MINIGAME_ESSENTIAL (+=1)
{
	MINIGAME_NAME[MAX_MINIGAME_NAME] = 0,
	MINIGAME_FUNCTION_ID,
	MINIGAME_PLUGIN_ID
}

enum _:MINIGAMES_MODES (+=1)
{
	MODE_TEAM_VS_TEAM = 0,
	MODE_FREE_FOR_ALL
}

enum any:MINIGAME_DATA (+=1)
{
	MINIGAME_INDEX = 0,
	MINIGAMES_MODES:MINIGAME_MODE,
	MINIGAME_MAX_TEAMS,
	MINIGAME_PLAYERS_BITS,
	MINIGAME_PLAYERS,
	MINIGAME_PLAYERS_TEAM[MAX_PLAYERS+1],
	MINIGAME_TEAMS[MAX_MINIGAME_TEAMS],
	
}

new const szMINIGAMES_TEAMS_NAME[][] = {
	"[ NONE ]",
	"Allies",
	"Enemies"
}

enum _:MINIGAME_TEAMS_DATA(+=1)
{
	MINIGAME_TEAM_NONE = 0,
	MINIGAME_TEAM_ALLIES,
	MINIGAME_TEAM_ENEMIES
}
	
enum _:USER_DATA
{
	USER_MINIGAME[32],
	USER_IN_MINIGAME[32],
	USER_TEAM[MAX_PLAYERS+1]
}

native jb_has_user_afreeday(index);
native register_jailbreak_cmitem(const itemname[]);
native unregister_jailbreak_cmitem(const item_index);

forward jb_cmenu_item_postselect(id, item);

new user_data[MAX_PLAYERS+1][USER_DATA],
g_iMaxplayers, Array:array_minigames, TOTAL_MINIGAMES, ITEM_ID, HamHook:FW_KILLED_PLAYER_POST,
MINIGAME_MENU, MINIGAME_MENU_CALLBACK, MINIGAME_MENU_CALLBACK_DIS, g_fw_handle, Trie:trie_minigames,
g_total_active_minigames, FM_FW_PLAYER_PRETHINK_POST = -1, FM_FW_ADDTOFULLPACK_POST = -1;

new g_iTPlayers[32], g_tnum;

new g_cvar_one, sprite_arrow, CM_ITEM = INVALID_HANDLE, USER_IN_TEAM_EDIT, USER_TEAM_EDIT[MAX_PLAYERS+1], USER_EDIT_DUMMY[MAX_PLAYERS+1][MAX_PLAYERS+1];

new ALLIES_PLAYER_MDL[32] = "prisoner_allies", ENEMIES_PLAYER_MDL[32] = "prisoner_enemies",
	g_iAlliesBodyID, g_iEnemiesBodyID;

public plugin_end()
{
	if(array_minigames > Invalid_Array) ArrayDestroy(array_minigames);
	if(trie_minigames > Invalid_Trie) TrieDestroy(trie_minigames);
	if(MINIGAME_MENU != INVALID_HANDLE) menu_destroy(MINIGAME_MENU);
}

public plugin_natives()
{
	array_minigames = ArrayCreate(MINIGAME_ESSENTIAL, 1);
	
	trie_minigames = TrieCreate();
	
	register_native("register_jb_minigame", "jb_minigame_registeration");
	register_native("jb_is_user_inminigame", "check_user_inminigame");
	register_native("jb_is_minigame_active", "is_minigame_active");
	register_native("jb_minigame_get_team_players", "minigame_get_team_players");
}

public plugin_precache()
{
	sprite_arrow = PRECACHE_SPRITE_I("sprites/arrow.spr");
	
	new sText[86];
	
	jb_ini_get_keyvalue("MINIGAMES", "ALLIES_P_MODEL", ALLIES_PLAYER_MDL, charsmax(ALLIES_PLAYER_MDL));
	sText[0] = '0'; sText[1] = EOS;
	jb_ini_get_keyvalue("MINIGAMES", "ALLIES_P_MODEL_BODY", sText, charsmax(sText));
	g_iAlliesBodyID = str_to_num(sText);
	jb_ini_get_keyvalue("MINIGAMES", "ENEMIES_P_MODEL", ENEMIES_PLAYER_MDL, charsmax(ENEMIES_PLAYER_MDL));
	sText[0] = '0'; sText[1] = EOS;
	jb_ini_get_keyvalue("MINIGAMES", "ENEMIES_P_MODEL_BODY", sText, charsmax(sText));
	g_iEnemiesBodyID = str_to_num(sText);
	
	formatex(sText, charsmax(sText), "models/player/%s/%s.mdl", ALLIES_PLAYER_MDL, ALLIES_PLAYER_MDL);
	PRECACHE_PLAYER_MODEL(sText);
	formatex(sText, charsmax(sText), "models/player/%s/%sT.mdl", ALLIES_PLAYER_MDL, ALLIES_PLAYER_MDL);
	if(file_exists(sText)) PRECACHE_PLAYER_MODEL(sText);
	
	formatex(sText, charsmax(sText), "models/player/%s/%s.mdl", ENEMIES_PLAYER_MDL, ENEMIES_PLAYER_MDL);
	PRECACHE_PLAYER_MODEL(sText);
	formatex(sText, charsmax(sText), "models/player/%s/%sT.mdl", ENEMIES_PLAYER_MDL, ENEMIES_PLAYER_MDL);
	if(file_exists(sText)) PRECACHE_PLAYER_MODEL(sText);
}

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	register_clcmd("jb_minigames_menu", "clcmd_minigames_menu", ADMIN_KICK);
	
	// forward jb_minigame_ended(const minigameID, const minigameMOD, const winner, players_bits)
	g_fw_handle = CreateMultiForward("jb_minigame_ended", ET_IGNORE, FP_CELL, FP_CELL, FP_CELL, FP_CELL);
	
	ITEM_ID = register_jailbreak_mmitem("MAIN_MENU_ITEM_MGAMES", ADMIN_ALL, TEAM_GUARDS);
	CM_ITEM = register_jailbreak_cmitem("CM_ITEM_MINIGAMES");
	
	g_cvar_one = register_cvar("jb_minigame_commander_only", "1");

	hook_cvar_change(g_cvar_one, "fwOnCvarChange");
	
	FW_KILLED_PLAYER_POST = RegisterHam(Ham_Killed, "player", "fw_killed_post", 1)
	DisableHamForward(FW_KILLED_PLAYER_POST);
	
	g_iMaxplayers = get_maxplayers();
	
	MINIGAME_MENU = menu_create("Choose a -<Mini>_<Game>-", "main_mhandler");
	menu_additem(MINIGAME_MENU, "None");
	MINIGAME_MENU_CALLBACK = menu_makecallback("minigame_callback_menu");
	MINIGAME_MENU_CALLBACK_DIS = menu_makecallback("minigame_callback_menu_dis");
	
	register_clcmd("say /freeday", "clcmd_check_freeday");
}

public fwOnCvarChange(pcvar, const old_value[], const new_value[])
{
	if(pcvar == g_cvar_one)
	{
		new newValue = str_to_num(new_value);
		if(newValue != str_to_num(old_value))
		{
			switch( newValue )
			{
				case 1:
				{
					if(CM_ITEM == INVALID_HANDLE)
					{
						CM_ITEM = register_jailbreak_cmitem("CM_ITEM_MINIGAMES");
					}
				}
				default:
				{
					if(CM_ITEM != INVALID_HANDLE)
					{
						unregister_jailbreak_cmitem(CM_ITEM);
						CM_ITEM = INVALID_HANDLE;
					}
				}
			}
		}
	}
}

public clcmd_check_freeday(id)
{
	switch( jb_has_user_afreeday(id) )
	{
		case false: cprint_chat(id, _, "You don't have a freeday!");
		case true: cprint_chat(id, _, "You have a freeday, go and enjoy it !!!");
	}
}

public clcmd_minigames_menu(id, level, cid)
{
	if(!(get_user_flags(id) & level))
	{
		console_print(id, "You have no access to use this command!");
		return PLUGIN_HANDLED;
	}
	
	minigames_menu_main(id);
	return PLUGIN_HANDLED;
}

public __XXXXX__(const szMinigameName[], const TASKID)
{
	if(!TrieKeyExists(trie_minigames, szMinigameName))
	{
		remove_task(TASKID);
		return;
	}
	
	static xArray[MINIGAME_DATA], szEnemy[32];
	TrieGetArray(trie_minigames, szMinigameName, xArray, sizeof xArray);
	
	static XPlayer, i, j, player, pnum;
	get_players(g_iTPlayers, g_tnum, "ahe", "TERRORIST");
	pnum = g_tnum;

	static Oplayers[32], z;
	
	if(_:xArray[MINIGAME_MODE] == MODE_FREE_FOR_ALL)
	{
		for(i = 0, j = 0, player = 0; i < pnum; i++)
		{
			XPlayer = g_iTPlayers[i];
			
			if(!check_flag(xArray[MINIGAME_PLAYERS_BITS],XPlayer)) continue;
			
			for(z = 0, j = 0; j < pnum; j++)
			{ 
				player = g_iTPlayers[j];
				
				if(XPlayer == player || !check_flag(xArray[MINIGAME_PLAYERS_BITS],player)) continue;
				
				Oplayers[z] = player;
				z++;
				
				message_begin(MSG_ONE_UNRELIABLE, SVC_TEMPENTITY, _, XPlayer);
				write_byte(TE_BEAMFOLLOW)
				write_short(player)
				write_short(sprite_arrow)
				write_byte(8) 
				write_byte(10) 
				write_byte(255)
				write_byte(0)
				write_byte(0)
				write_byte(200)
				message_end();
			}
			
			if( z > 0 )
			{
				player = random(z);
				
				get_user_name(Oplayers[player], szEnemy, charsmax(szEnemy))
				set_hudmessage(215, 255, 255, -1.0, 0.87, 1, 3.0, 0.95, 0.01, 0.01, -1)
				show_hudmessage(XPlayer, "Minigame: %s ^n Enemies: %s", szMinigameName, szEnemy)
			}
		}
		
		return;
	}
	
	static szTeam[32], iEnemy[ MAX_PLAYERS+1 ] = { 0, 0, ... };
	
	for(i = 0, j = 0, player = 0; i < pnum; i++)
	{
		XPlayer = g_iTPlayers[i];
		
		if(!check_flag(xArray[MINIGAME_PLAYERS_BITS],XPlayer)) continue;
		
		for(j = z = 0; j < pnum; j++)
		{ 
			player = g_iTPlayers[j];
			
			if(XPlayer == player || !check_flag(xArray[MINIGAME_PLAYERS_BITS],player)) continue;
			
			if(xArray[MINIGAME_PLAYERS_TEAM][player] == xArray[MINIGAME_PLAYERS_TEAM][XPlayer]) continue;
			
			Oplayers[z++] = player;
			
			message_begin(MSG_ONE_UNRELIABLE, SVC_TEMPENTITY, _, XPlayer);
			write_byte(TE_BEAMFOLLOW);
			write_short(player);
			write_short(sprite_arrow);
			write_byte(8);
			write_byte(10);
			write_byte(255); // r
			write_byte(0);   // g
			write_byte(0);   // b
			write_byte(200);
			message_end();
		}

		// There're no enemies to highlight? ignore...
		if(!z) continue;

		if(!iEnemy[XPlayer] || iEnemy[XPlayer] > z) iEnemy[XPlayer] = z;

		j = Oplayers[ --iEnemy[XPlayer] ];
		
		minigame_get_team_name(xArray[MINIGAME_PLAYERS_TEAM][j], szTeam, charsmax(szTeam));
		get_user_name(j, szEnemy, charsmax(szEnemy));
		set_hudmessage(215, 255, 255, -1.0, 0.87, 1, 3.0, 0.95, 0.01, 0.01, -1);
		show_hudmessage(XPlayer, "Minigame: %s ^n Enemy team:%s^n%s)", szMinigameName, szTeam, szEnemy);
	}
}

public plugin_cfg()
{
	static xArray[MINIGAME_ESSENTIAL];
	for(new i = 0; i < TOTAL_MINIGAMES; i++)
	{
		ArrayGetArray(array_minigames, i, xArray)
		menu_additem(MINIGAME_MENU, xArray[MINIGAME_NAME], "DISABLED", 0, -1)
	}
	menu_setprop(MINIGAME_MENU, MPROP_EXITNAME, "Return?")
}

public client_connect(id)
{
	USER_TEAM_EDIT[id] = 0;
	user_data[id][USER_IN_MINIGAME][0] = EOS;
	remove_flag(USER_IN_TEAM_EDIT,id);
}

#if AMXX_VERSION_NUM > 182
public client_disconnected(id)
#else
public client_disconnect(id)
#endif
{
	static szMinigame[32];
	copy(szMinigame, charsmax(szMinigame), user_data[id][USER_IN_MINIGAME]);
	
	if(szMinigame[0] == EOS) return;
	remove_user_from_minigame(id, szMinigame);
}

public fw_addtofullpack_post(const entity_state, const e, const ent, const host, const hostflags, const bool:player, const pSet)
{
	if(player && check_flag(USER_IN_TEAM_EDIT,host) && USER_EDIT_DUMMY[ent][host] > 0)
	{
		set_es(entity_state, ES_RenderMode, kRenderTransAlpha);
		set_es(entity_state, ES_RenderAmt, 0);
		return FMRES_IGNORED;
	}
	
	if(!player && !check_flag(USER_IN_TEAM_EDIT,host) && pev_valid(ent))
	{
		static szClassname[18];
		pev(ent, pev_classname, szClassname, charsmax(szClassname));
		
		if(equal(szClassname, "player_hollogram"))
		{
			set_es(entity_state, ES_RenderMode, kRenderTransAlpha);
			set_es(entity_state, ES_RenderAmt, 0);
			return FMRES_IGNORED;
		}
	}
	
	return FMRES_IGNORED;
}

public fw_player_prethink_post(id)
{
	if(!check_flag(USER_IN_TEAM_EDIT,id)) return;
	
	if((pev(id, pev_button) & IN_USE) && !(pev(id, pev_oldbuttons) & IN_USE))
	{
		static iTarget, null;
		if(get_user_aiming(id, iTarget, null) <= 2000.0 && (1 <= iTarget <= g_iMaxplayers))
		{
			static ent;
			ent = USER_EDIT_DUMMY[iTarget][id];
			
			if(!pev_valid(ent))
			{
				USER_EDIT_DUMMY[iTarget][id] = ent = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "info_target"));
				
				if(!ent) return;
				
				set_pev(ent, pev_classname, "player_hollogram");
				set_pev(ent, pev_aiment, iTarget);
				set_pev(ent, pev_movetype, MOVETYPE_FOLLOW);
				
				set_pev(ent, pev_team, USER_TEAM_EDIT[id]);
			}
			
			switch( USER_TEAM_EDIT[id] )
			{
				case MINIGAME_TEAM_NONE:
				{
					static iTeam;
					iTeam = pev(ent, pev_team);
					
					user_data[id][USER_TEAM][iTarget] = MINIGAME_TEAM_NONE;
					
					USER_EDIT_DUMMY[iTarget][id] = 0;
					set_pev(ent, pev_flags, FL_KILLME);
					dllfunc(DLLFunc_Think, ent);
					
					if(iTeam == MINIGAME_TEAM_NONE) return;
					
					static szTeam[16];
					switch( iTeam )
					{
						case MINIGAME_TEAM_ALLIES: copy(szTeam, charsmax(szTeam), "Allies");
						case MINIGAME_TEAM_ENEMIES: copy(szTeam, charsmax(szTeam), "Enemies");
					}
					
					minigame_deselect_team_menu(id, szTeam, iTeam);
				}
				case MINIGAME_TEAM_ALLIES:
				{
					static sText[96];
					user_data[id][USER_TEAM][iTarget] = MINIGAME_TEAM_ALLIES;
					set_pev(ent, pev_team, MINIGAME_TEAM_ALLIES);
					
					formatex(sText, charsmax(sText), "models/player/%s/%s.mdl", ALLIES_PLAYER_MDL, ALLIES_PLAYER_MDL);
					engfunc(EngFunc_SetModel, ent, sText);
					set_pev(ent, pev_body, g_iAlliesBodyID);
					
					minigame_select_team_menu(id, "Allies", MINIGAME_TEAM_ALLIES)
				}
				case MINIGAME_TEAM_ENEMIES:
				{
					static sText[96];
					user_data[id][USER_TEAM][iTarget] = MINIGAME_TEAM_ENEMIES;
					set_pev(ent, pev_team, MINIGAME_TEAM_ENEMIES);
					
					formatex(sText, charsmax(sText), "models/player/%s/%s.mdl", ENEMIES_PLAYER_MDL, ENEMIES_PLAYER_MDL);
					engfunc(EngFunc_SetModel, ent, sText);
					set_pev(ent, pev_body, g_iEnemiesBodyID);
					
					minigame_select_team_menu(id, "Enemies", MINIGAME_TEAM_ENEMIES)
				}
			}
		}
	}
}

remove_user_from_minigame(user, const minigamename[])
{
	jb_set_user_enemies(user, JB_ENEMIES_DEFAULT);
	
	static xArray[MINIGAME_DATA];
	TrieGetArray(trie_minigames, minigamename, xArray, sizeof xArray)
	
	formatex(user_data[user][USER_IN_MINIGAME], charsmax(user_data[][USER_IN_MINIGAME]), "");
	
	remove_flag(xArray[MINIGAME_PLAYERS_BITS],user);
	xArray[MINIGAME_PLAYERS] --;

	get_players(g_iTPlayers, g_tnum, "ahe", "TERRORIST");

	if(g_tnum > 0)
	{
		for(new i, player; i < g_tnum; i++)
		{
			player = g_iTPlayers[ i ];
			if(!equal(user_data[player][USER_IN_MINIGAME], minigamename)) continue;

			jb_set_user_enemies(player, jb_get_user_enemies(player) & ~player_flag(user));
		}
	}
	
	if(_:xArray[MINIGAME_MODE] == MODE_TEAM_VS_TEAM)
	{
		new iTeam = xArray[MINIGAME_PLAYERS_TEAM][user];
		xArray[MINIGAME_PLAYERS_TEAM][user] = MINIGAME_TEAM_NONE;
		
		new team_count;
		
		for(new i, player; i < g_tnum; i++)
		{
			player = g_iTPlayers[ i ];
				
			if(!check_flag(xArray[MINIGAME_PLAYERS_BITS],player)) continue;
			
			if(xArray[MINIGAME_PLAYERS_TEAM][player] == iTeam)
			{
				team_count++;
				break;
			}
		}
		
		// Team was eliminated!
		if(!team_count)
		{
			new i, maxteams = xArray[MINIGAME_MAX_TEAMS];
			for(i = 0; i < maxteams; i++)
			{
				if( iTeam == xArray[MINIGAME_TEAMS][i] )
				{
					break;
				}
			}
			
			xArray[MINIGAME_TEAMS][i] = xArray[MINIGAME_TEAMS][ --xArray[MINIGAME_MAX_TEAMS] ];
		}
	}
	
	TrieSetArray(trie_minigames, minigamename, xArray, sizeof xArray)
	
	check_minigame(minigamename);
}

end_minigame(const szMinigameName[], winner)
{
	new Ind = GetIndexInArrayByString(array_minigames, szMinigameName);
	
	if(Ind == -1) return;
	
	static xArray[MINIGAME_DATA], szLog[MAX_LOG_MESSAGE_LENGTH];
	TrieGetArray(trie_minigames, szMinigameName, xArray, sizeof xArray);
	
	menu_item_setcmd(MINIGAME_MENU, Ind + 1, "DISABLED");
	
	switch( winner )
	{
		case MINIGAME_NO_WINNER:
		{
			cprint_chat(0, _, "^4~ MINIGAMES ~ ^1The ^4%s ^1match has ^4Ended^3!", szMinigameName)
			formatex(szLog, charsmax(szLog), "MINIGAMES THE '%s' MATCH HAS ENDED!", szMinigameName);
		}
		default:
		{
			if(_:xArray[MINIGAME_MODE] == MODE_TEAM_VS_TEAM) // winner is a team
			{
				new szTeam[32];
				minigame_get_team_name(winner, szTeam, charsmax(szTeam));
				cprint_chat(0, _, "^4~ MINIGAMES ~ ^1The ^%s ^1has won the ^4%s ^1match^3!", szTeam, szMinigameName);
				formatex(szLog, charsmax(szLog), "MINIGAMES '%s' HAS WON THE '%s' MATCH!", szTeam, szMinigameName);
			}
			else
			{
				new szWinnerName[32]
				get_user_name(winner, szWinnerName, charsmax(szWinnerName))
				cprint_chat(0, _, "^1~ MINIGAMES ~ ^4%s ^1has ^3won ^1the ^4%s ^1match^3!", szWinnerName, szMinigameName);
				formatex(szLog, charsmax(szLog), "MINIGAMES '%s' WON THE '%s' MATCH!", szWinnerName, szMinigameName);
			}
		}
	}

	new iInReturn;
	ExecuteForward(g_fw_handle, iInReturn, Ind, xArray[MINIGAME_MODE], winner, xArray[MINIGAME_PLAYERS_BITS])
	
	// do jailbreak logs...
	jb_logmessage(szLog);
	
	new players[32], pnum;
	get_players(players, pnum, "he", "TERRORIST");
	
	for(new Float:fHealth, i = 0, player; i < pnum; i++)
	{
		player = players[i];
		
		if(!check_flag(xArray[MINIGAME_PLAYERS_BITS], player)) continue;
		
		user_data[player][USER_IN_MINIGAME][0] = EOS;
		jb_set_user_class_model(player);
		pev(player, pev_max_health, fHealth);
		set_pev(player, pev_health, fHealth);
		jb_set_user_enemies(player, JB_ENEMIES_DEFAULT);
	}
	
	TrieDeleteKey(trie_minigames, szMinigameName);
	
	remove_task(TASK__XXXXX__ + Ind); 
	
	g_total_active_minigames--;
	
	if(!g_total_active_minigames)
	{
		DisableHamForward(FW_KILLED_PLAYER_POST);
	}
}

public jb_cmenu_item_postselect(id, item)
{
	if(item == CM_ITEM)
	{
		minigames_menu_main(id);
		return JB_HANDLED;
	}

	return JB_IGNORED;
}

public jb_mm_itemadded(id, itemid)
{
	if(itemid == ITEM_ID)
	{
		if(get_pcvar_num(g_cvar_one))
		{
			if(jb_get_current_day() != DAY_NONE || jb_get_current_duel() != DUEL_NONE)
			{
				return JB_MENU_ITEM_DONT_SHOW;
			}

			return JB_MENU_ITEM_DONT_SHOW;
		}
		else if(jb_get_current_day() != DAY_NONE || jb_get_current_duel() != DUEL_NONE)
		{
			return JB_MENU_ITEM_UNAVAILABLE;
		}
	}
	
	return JB_IGNORED;
}

public jb_mm_itemselected(id, itemid)
{
	if(itemid == ITEM_ID)
	{
		if(jb_get_current_day() != DAY_NONE || jb_get_current_duel() != DUEL_NONE)
		{
			return JB_MENU_ITEM_UNAVAILABLE;
		}
		if(jb_get_commander() != id && get_pcvar_num(g_cvar_one))
		{
			return JB_MENU_ITEM_UNAVAILABLE;
		}
		
		minigames_menu_main(id);
	}
	
	return PLUGIN_CONTINUE;
}

public fw_killed_post(victim, attacker, shouldgib)
{
	static szMinigame[32];
	copy(szMinigame, charsmax(szMinigame), user_data[victim][USER_IN_MINIGAME]);
	
	if(szMinigame[0] == EOS) return;
	
	static szText[MAX_LOG_MESSAGE_LENGTH];
	formatex(szText, charsmax(szText), "'%s' Minigame - has killed", szMinigame);
	jb_logmessage_action(szText, attacker, victim);
	
	remove_user_from_minigame(victim, szMinigame);
}

check_minigame(const minigame_name[])
{
	new xArray[MINIGAME_DATA], szText[MAX_LOG_MESSAGE_LENGTH];
	TrieGetArray(trie_minigames, minigame_name, xArray, sizeof xArray)
	
	switch( xArray[MINIGAME_MODE] )
	{
		case MODE_TEAM_VS_TEAM:
		{
			if(xArray[MINIGAME_MAX_TEAMS] > 1) return;
			
			if(xArray[MINIGAME_MAX_TEAMS] == 0)
			{
				end_minigame(minigame_name, _:MINIGAME_NO_WINNER);
				formatex(szText, charsmax(szText), "'%s' Minigame - [NO WINNER] has ended!", minigame_name);
				jb_logmessage(szText);
				return;
			}
			else
			{
				new szTeam[32];
				minigame_get_team_name(xArray[MINIGAME_TEAMS][0], szTeam, charsmax(szTeam));
				formatex(szText, charsmax(szText), "'%s' Minigame - [%s WON] has ended!", minigame_name, szTeam);
				
				end_minigame(minigame_name, xArray[MINIGAME_TEAMS][0]);
				jb_logmessage(szText);
				return;
			}
		}
		case MODE_FREE_FOR_ALL:
		{
			if(xArray[MINIGAME_PLAYERS] <= 1)
			{
				new player;
				get_players(g_iTPlayers, g_tnum, "ahe", "TERRORIST");
				
				for(new i; i < g_tnum; i++)
				{
					player = g_iTPlayers[i];
					if(check_flag(xArray[MINIGAME_PLAYERS_BITS], player))
					{
						break;
					}
					
					player = 0;
				}
				
				end_minigame(minigame_name, player);
				
				if(player > 0)
				{
					formatex(szText, charsmax(szText), "'%s' Minigame - has won the minigame", minigame_name);
					jb_logmessage_action(szText, player);
				}
			}
		}
	}
}
end_all_activated_minigames()
{
	static xArray[MINIGAME_ESSENTIAL], szMinigameName[MAX_MINIGAME_NAME];
	for(new i = 0; i < TOTAL_MINIGAMES; i++)
	{
		ArrayGetArray(array_minigames, i, xArray);
		copy(szMinigameName, charsmax(szMinigameName), xArray[MINIGAME_NAME]);
		if(TrieKeyExists(trie_minigames, szMinigameName))
		{
			end_minigame(szMinigameName, _:MINIGAME_NO_WINNER);
		}
	}
}

public jb_round_end()
{
	end_all_activated_minigames();
}

public jb_day_started(iDayid)
{
	if(iDayid != DAY_NONE)
	{
		end_all_activated_minigames();
	}
}

public jb_lr_duel_started(prisoner, guard, duelid)
{
	if(duelid != DUEL_NONE)
	{
		end_all_activated_minigames();
	}
}

minigames_menu_main(id)
{
	new sText[64], menu = menu_create("\y[Jailbreak] \r<Mini>-<Games>", "menu_main_handle"), paccess;
	
	new szMiniGameName[MAX_MINIGAME_NAME];
	copy(szMiniGameName, charsmax(szMiniGameName), user_data[id][USER_MINIGAME]);
	if(szMiniGameName[0] == EOS || TrieKeyExists(trie_minigames, szMiniGameName) || !ArraySize(array_minigames))
	{
		copy(szMiniGameName, charsmax(szMiniGameName), "None");
		paccess = ADMIN_NOACCESS;
	}
	
	formatex(sText, charsmax(sText), "Minigame : %s", szMiniGameName);
	menu_additem(menu, sText)
	
	formatex(sText, charsmax(sText), "Allies Crew!");
	menu_additem(menu, sText, "SELECTING_ALIES", paccess);
	
	formatex(sText, charsmax(sText), "Enemies Crew!");
	menu_additem(menu, sText, "SELECTING_ENEMIES", paccess);
	
	if(!paccess)
	{
		new iMinigame_teams, teams_count;
		get_players(g_iTPlayers, g_tnum, "ahe", "TERRORIST");
		
		for(new iTeam, i = 0, player; i < g_tnum; i++)
		{
			player = g_iTPlayers[i];
			
			if(!is_user_available_for_minigame(player)) continue;
			
			iTeam = user_data[id][USER_TEAM][player];
			
			if(iTeam == MINIGAME_TEAM_NONE) continue;
			
			if(!check_flag(iMinigame_teams,iTeam))
			{
				set_flag(iMinigame_teams,iTeam);
				teams_count++;
			}
		}
		
		if(teams_count <= 1) paccess = ADMIN_NOACCESS;
	}
	
	formatex(sText, charsmax(sText), "Allies vs Enemies!^n^n")
	menu_additem(menu, sText, "", paccess)
	
	paccess = (equal(szMiniGameName, "None") || !minigame_available(id)) ? ADMIN_NOACCESS:0;
	
	formatex(sText, charsmax(sText), "Free for all!^n^n")
	menu_additem(menu, sText, "", paccess)
	
	paccess = g_total_active_minigames > 0 ? 0:ADMIN_NOACCESS;
	
	formatex(sText, charsmax(sText), "End Current Minigames!")
	menu_additem(menu, sText, "", paccess)
	
	menu_display(id, menu)
}

minigame_available(id)
{
	if(jb_get_current_day() != DAY_NONE || jb_get_current_duel() != DUEL_NONE)
	{
		return false;
	}
	if(!(get_user_flags(id) & ADMIN_KICK))
	{
		if(jb_get_commander() != id && get_pcvar_num(g_cvar_one))
		{
			return false;
		}
	}
	
	new available_minigamers;
	get_players(g_iTPlayers, g_tnum, "ahe", "TERRORIST")
	for(new i, player; i < g_tnum; i++)
	{
		player = g_iTPlayers[i];
		if(is_user_available_for_minigame(player)) available_minigamers++;
	}
	
	return available_minigamers > 1 ? true:false;
}

bool:is_user_available_for_minigame(id) 
{
	return (!jb_has_user_afreeday(id) && user_data[id][USER_IN_MINIGAME][0] == EOS)
}

minigame_select_team_menu(id, const team_name[], const TEAM)
{
	new szText[64];
	formatex(szText, charsmax(szText), "%s Crew^nChoose a player to add him/her to the crew!", team_name)
	new xmenu = menu_create(szText, "main_mhandler")
	
	new szData[3];
	szData[0] = TEAM;
	szData[1] = '2';
	menu_additem(xmenu, "\rDeselect a player!", szData)
	
	new players[32], pnum, x = 0;
	get_players(players, pnum, "ahe", "TERRORIST")
	
	for(new i, IsUserInTeam, xplayer, szName[32]; i < pnum; i++)
	{
		xplayer = players[i];
		
		if(!is_user_available_for_minigame(xplayer)) continue;
		
		IsUserInTeam = (user_data[id][USER_TEAM][xplayer] > 0) ? 1:0
		
		if(!IsUserInTeam)
		{
			szData[1] = xplayer;
			get_user_name(xplayer, szName, charsmax(szName))
			menu_additem(xmenu, szName, szData);
			continue;
		}
		
		if(user_data[id][USER_TEAM][xplayer] == TEAM)
		{
			players[x] = xplayer;
			x ++;
		}
	}
	
	menu_setprop(xmenu, MPROP_EXITNAME, "Return?")
	menu_display(id, xmenu)
	
	if( x > 0 )
	{
		for (new iTarget, ent, i = 0, sText[96]; i < x; i++)
		{
			iTarget = players[i];
			ent = USER_EDIT_DUMMY[iTarget][id];
			
			if(!pev_valid(ent))
			{
				USER_EDIT_DUMMY[iTarget][id] = ent = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "info_target"));
				
				if(!ent) continue;
				
				set_pev(ent, pev_classname, "player_hollogram");
				set_pev(ent, pev_aiment, iTarget);
				set_pev(ent, pev_movetype, MOVETYPE_FOLLOW);
			}
			
			set_pev(ent, pev_team, TEAM);
			
			switch( TEAM )
			{
				case MINIGAME_TEAM_ALLIES:
				{
					formatex(sText, charsmax(sText), "models/player/%s/%s.mdl", ALLIES_PLAYER_MDL, ALLIES_PLAYER_MDL)
					engfunc(EngFunc_SetModel, ent, sText);
					set_pev(ent, pev_body, g_iAlliesBodyID);
				}
				case MINIGAME_TEAM_ENEMIES:
				{
					formatex(sText, charsmax(sText), "models/player/%s/%s.mdl", ENEMIES_PLAYER_MDL, ENEMIES_PLAYER_MDL)
					engfunc(EngFunc_SetModel, ent, sText);
					set_pev(ent, pev_body, g_iEnemiesBodyID);
				}
			}
		}
	}
	
	USER_TEAM_EDIT[id] = TEAM;
	
	if(!USER_IN_TEAM_EDIT)
	{
		if(FM_FW_PLAYER_PRETHINK_POST == -1)
		{
			FM_FW_PLAYER_PRETHINK_POST = register_forward(FM_PlayerPreThink, "fw_player_prethink_post", 1);
		}
		
		if(FM_FW_ADDTOFULLPACK_POST == -1)
		{
			FM_FW_ADDTOFULLPACK_POST = register_forward(FM_AddToFullPack, "fw_addtofullpack_post", 1);
		}
	}
	
	set_flag(USER_IN_TEAM_EDIT,id);
}

minigame_deselect_team_menu(id, const team_name[], const TEAM)
{
	new sText[96], players[32], szName[32];
	
	get_players(g_iTPlayers, g_tnum, "ahe", "TERRORIST")
	
	new x = 0;
	
	for(new i = 0, player; i < g_tnum; i++)
	{
		player = g_iTPlayers[i];
		
		if(!is_user_available_for_minigame(player)) continue;
		
		if(user_data[id][USER_TEAM][player] == TEAM)
		{
			players[x] = player;
			x++;
		}
	}
	
	formatex(sText, charsmax(sText), "\r%s Crew \w(%d)^n\yChoose a player to remove him/her from the crew!", team_name, x)
	new menu = menu_create(sText, "main_mhandler")
	
	new szData[3];
	szData[0] = TEAM;
	szData[1] = '1';
	menu_additem(menu, "\ySelect a player!", szData)
	
	for(new i = 0, player; i < x; i++)
	{
		player = players[i];
	
		get_user_name(player, szName, charsmax(szName))
		szData[1] = player;
		menu_additem(menu, szName, szData)
	}
	
	menu_setprop(menu, MPROP_EXITNAME, "Return?")
	menu_display(id, menu)
	
	if( x > 0 )
	{
		for (new sText[96], iTarget, ent, i = 0; i < x; i++)
		{
			iTarget = players[i];
			ent = USER_EDIT_DUMMY[iTarget][id];
			
			if(!pev_valid(ent))
			{
				USER_EDIT_DUMMY[iTarget][id] = ent = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "info_target"));
				
				if(!ent) continue;
				
				set_pev(ent, pev_classname, "player_hollogram");
				set_pev(ent, pev_aiment, iTarget);
				set_pev(ent, pev_movetype, MOVETYPE_FOLLOW);
			}
			
			set_pev(ent, pev_team, TEAM);
			
			switch( TEAM )
			{
				case MINIGAME_TEAM_ALLIES:
				{
					formatex(sText, charsmax(sText), "models/player/%s/%s.mdl", ALLIES_PLAYER_MDL, ALLIES_PLAYER_MDL)
					engfunc(EngFunc_SetModel, ent, sText);
					set_pev(ent, pev_body, g_iAlliesBodyID);
				}
				case MINIGAME_TEAM_ENEMIES:
				{
					formatex(sText, charsmax(sText), "models/player/%s/%s.mdl", ENEMIES_PLAYER_MDL, ENEMIES_PLAYER_MDL)
					engfunc(EngFunc_SetModel, ent, sText);
					set_pev(ent, pev_body, g_iEnemiesBodyID);
				}
			}
		}
	}
	
	USER_TEAM_EDIT[id] = MINIGAME_TEAM_NONE;
	
	if(!USER_IN_TEAM_EDIT)
	{
		if(FM_FW_PLAYER_PRETHINK_POST == -1) FM_FW_PLAYER_PRETHINK_POST = register_forward(FM_PlayerPreThink, "fw_player_prethink_post", 1);
		if(FM_FW_ADDTOFULLPACK_POST == -1) FM_FW_ADDTOFULLPACK_POST = register_forward(FM_AddToFullPack, "fw_addtofullpack_post", 1);
	}
	
	set_flag(USER_IN_TEAM_EDIT,id);
}

public menu_main_handle(id, menu, item)
{
	menu_destroy(menu);
	
	switch( item )
	{
		case MENU_EXIT: return PLUGIN_HANDLED;
		case 0:
		{
			static xArray[MINIGAME_ESSENTIAL];
			for(new i = 0 ; i < TOTAL_MINIGAMES; i++)
			{
				ArrayGetArray(array_minigames, i, xArray)
				
				menu_item_setcall(MINIGAME_MENU, i + 1, MINIGAME_MENU_CALLBACK);
			}
			
			menu_display(id, MINIGAME_MENU)
		}
		case 1: minigame_select_team_menu(id, "Allies", MINIGAME_TEAM_ALLIES)
		case 2: minigame_select_team_menu(id, "Enemies", MINIGAME_TEAM_ENEMIES)
		case 3:
		{
			new szMinigame[MAX_MINIGAME_NAME];
			formatex(szMinigame, charsmax(szMinigame), user_data[id][USER_MINIGAME]);
			
			new itemid = GetIndexInArrayByString(array_minigames, szMinigame);
			if(!minigame_available(id) || TrieKeyExists(trie_minigames, szMinigame) || itemid == -1)
			{
				minigames_menu_main(id)
				return PLUGIN_HANDLED;
			}
			
			new _:xArray[MINIGAME_DATA];
			get_players(g_iTPlayers, g_tnum, "ahe", "TERRORIST");
			
			new iMinigame_teams, teams_count;
			
			for(new iTeam, i = 0, player; i < g_tnum; i++)
			{
				player = g_iTPlayers[i];
				
				if(!is_user_available_for_minigame(player)) continue;
				
				iTeam = user_data[id][USER_TEAM][player];
				
				if(iTeam == MINIGAME_TEAM_NONE) continue;
				
				if(!check_flag(iMinigame_teams,iTeam))
				{
					set_flag(iMinigame_teams,iTeam);
					xArray[MINIGAME_TEAMS][teams_count++] = iTeam;
				}
			}
			
			if(teams_count <= 1)
			{
				minigames_menu_main(id)
				return PLUGIN_HANDLED;
			}
			
			new iContesters_count, iContesters;
			
			for(new iTeam, TargetTeam, j, i, player, target, iBits_enemies; i < g_tnum; i++)
			{
				player = g_iTPlayers[i];
				
				if((iTeam=user_data[id][USER_TEAM][player]) != MINIGAME_TEAM_NONE)
				{
					set_flag(iContesters,player);
					iContesters_count++;
					xArray[MINIGAME_PLAYERS_TEAM][player] = iTeam;
					formatex(user_data[player][USER_IN_MINIGAME], charsmax(user_data[][USER_IN_MINIGAME]), szMinigame);
				
					switch( iTeam )
					{
						case MINIGAME_TEAM_ALLIES:
						{
							if(ALLIES_PLAYER_MDL[0] != EOS)
							{
								cs_set_player_model(player, ALLIES_PLAYER_MDL);
								set_pev(player, pev_body, g_iAlliesBodyID);
							}
						}
						case MINIGAME_TEAM_ENEMIES:
						{
							if(ENEMIES_PLAYER_MDL[0] != EOS)
							{
								cs_set_player_model(player, ENEMIES_PLAYER_MDL);
								set_pev(player, pev_body, g_iEnemiesBodyID);
							}
						}
					}
					
					for( j = 0; j < g_tnum; j++)
					{
						target = g_iTPlayers[ j ];
						TargetTeam = user_data[id][USER_TEAM][target];

						if(iTeam != TargetTeam && TargetTeam != MINIGAME_TEAM_NONE)
						{
							set_flag(iBits_enemies,target);
						}
					}
					
					jb_set_user_enemies(player, iBits_enemies);
					iBits_enemies = JB_ENEMIES_DEFAULT;
				}
			}
			
			arrayset(user_data[id][USER_TEAM], MINIGAME_TEAM_NONE, sizeof user_data[][USER_TEAM]);
			
			xArray[MINIGAME_MODE] = _:MODE_TEAM_VS_TEAM;
			xArray[MINIGAME_INDEX] = g_total_active_minigames;
			xArray[MINIGAME_MAX_TEAMS] = teams_count;
			xArray[MINIGAME_PLAYERS_BITS] = iContesters;
			xArray[MINIGAME_PLAYERS] = iContesters_count;
			
			TrieSetArray(trie_minigames, szMinigame, xArray, sizeof xArray)
			
			if(!(g_total_active_minigames++))
			{
				EnableHamForward(FW_KILLED_PLAYER_POST);
			}
			
			static any:xxArray[MINIGAME_ESSENTIAL];
			ArrayGetArray(array_minigames, itemid, xxArray)
			
			if(!menu_item_setcmd(MINIGAME_MENU, itemid + 1, "ENABLED"))
				log_error(AMX_ERR_NATIVE, "Failed enabling item!");
			
			new j;
			if((j = callfunc_begin_i(xxArray[MINIGAME_FUNCTION_ID], xxArray[MINIGAME_PLUGIN_ID])) == 1)
			{
				callfunc_push_int(itemid);
				callfunc_push_int(_:xArray[MINIGAME_MODE]);
				callfunc_push_array(xArray[MINIGAME_PLAYERS_TEAM], sizeof xArray[MINIGAME_PLAYERS_TEAM], false);
				callfunc_push_array(xArray[MINIGAME_TEAMS], sizeof xArray[MINIGAME_TEAMS], false);
				callfunc_push_int(xArray[MINIGAME_MAX_TEAMS]);
				callfunc_push_int(xArray[MINIGAME_PLAYERS]);
				callfunc_push_int(xArray[MINIGAME_PLAYERS_BITS]);
				callfunc_end();
			}
			else
			{
				switch( j )
				{
					case -1: log_error(AMX_ERR_NOTFOUND, "Plugin is not found, PLUGIN-ID: (#%d), failed to execute the function!", xxArray[MINIGAME_PLUGIN_ID]);
					case -2: log_error(AMX_ERR_NOTFOUND, "Function is not found, FUNC-ID: (#%d), unExecutable function!", xxArray[MINIGAME_FUNCTION_ID]);
				}
			}
			
			set_task(1.0, "__XXXXX__", itemid + TASK__XXXXX__, szMinigame, sizeof szMinigame, "b");
			
			new szText[MAX_LOG_MESSAGE_LENGTH];
			formatex(szText, charsmax(szText), "has started [TEAM VS TEAM MODE] '%s' Minigame", szMinigame);
			jb_logmessage_action(szText, id);
		}
		case 4:
		{
			new szMinigame[MAX_MINIGAME_NAME];
			formatex(szMinigame, charsmax(szMinigame), user_data[id][USER_MINIGAME]);
			if(!minigame_available(id) || TrieKeyExists(trie_minigames, szMinigame))
			{
				minigames_menu_main(id)
				return PLUGIN_HANDLED;
			}
			
			new any:xArray[MINIGAME_DATA];
			get_players(g_iTPlayers, g_tnum, "ahe", "TERRORIST")
			
			new iContesters, iContesters_count;
			
			for(new i = 0, player; i < g_tnum; i++)
			{
				player = g_iTPlayers[i];
				
				if(!is_user_available_for_minigame(player)) continue;
				
				formatex(user_data[player][USER_IN_MINIGAME], charsmax(user_data[][USER_IN_MINIGAME]), szMinigame);
				set_flag(iContesters,player);
				iContesters_count++;
			}
			
			for(new i = 0, player; i < g_tnum; i++)
			{
				player = g_iTPlayers[i];
				if(!check_flag(iContesters,player)) continue;
				jb_set_user_enemies(player, iContesters);
			}
			
			arrayset(user_data[id][USER_TEAM], MINIGAME_TEAM_NONE, sizeof user_data[][USER_TEAM]);
			
			xArray[MINIGAME_INDEX] = g_total_active_minigames;
			xArray[MINIGAME_MAX_TEAMS] = 0;
			xArray[MINIGAME_PLAYERS_BITS] = iContesters;
			xArray[MINIGAME_PLAYERS] = iContesters_count;
			xArray[MINIGAME_MODE] = MODE_FREE_FOR_ALL;
			arrayset(xArray[MINIGAME_PLAYERS_TEAM], 0, sizeof xArray[MINIGAME_PLAYERS_TEAM]);
			arrayset(xArray[MINIGAME_TEAMS], 0, sizeof xArray[MINIGAME_TEAMS]);
			
			TrieSetArray(trie_minigames, user_data[id][USER_MINIGAME], xArray, sizeof xArray)
			
			if(!g_total_active_minigames)
			{
				EnableHamForward(FW_KILLED_PLAYER_POST);
			}
			g_total_active_minigames++;
			
			static any:xxArray[MINIGAME_ESSENTIAL];
			new j, itemid = GetIndexInArrayByString(array_minigames,szMinigame);
			ArrayGetArray(array_minigames, itemid, xxArray)
			
			menu_item_setcmd(MINIGAME_MENU, itemid + 1, "ENABLED")
			
			if((j = callfunc_begin_i(xxArray[MINIGAME_FUNCTION_ID], xxArray[MINIGAME_PLUGIN_ID])) == 1)
			{
				callfunc_push_int(itemid);
				callfunc_push_int(_:xArray[MINIGAME_MODE]);
				callfunc_push_array(xArray[MINIGAME_PLAYERS_TEAM], sizeof xArray[MINIGAME_PLAYERS_TEAM], false);
				callfunc_push_array(xArray[MINIGAME_TEAMS], sizeof xArray[MINIGAME_TEAMS], false);
				callfunc_push_int(xArray[MINIGAME_MAX_TEAMS]);
				callfunc_push_int(xArray[MINIGAME_PLAYERS]);
				callfunc_push_int(xArray[MINIGAME_PLAYERS_BITS]);
				callfunc_end();
			}
			else
			{
				switch( j )
				{
					case -1: log_error(AMX_ERR_NOTFOUND, "Plugin is not found, PLUGIN-ID: (#%d), failed to execute the function!", xxArray[MINIGAME_PLUGIN_ID])
					case -2: log_error(AMX_ERR_NOTFOUND, "Function is not found, FUNC-ID: (#%d), unExecutable function!", xxArray[MINIGAME_FUNCTION_ID])
				}
			}
			
			set_task(1.0, "__XXXXX__", itemid + TASK__XXXXX__, szMinigame, sizeof szMinigame, "b");
			
			new szText[MAX_LOG_MESSAGE_LENGTH];
			formatex(szText, charsmax(szText), "has started a [FREE FOR ALL MODE] '%s' Minigame", szMinigame);
			jb_logmessage_action(szText, id);
		}
		case 5:
		{
			static xArray[MINIGAME_ESSENTIAL];
			for(new i = 0; i < TOTAL_MINIGAMES; i++)
			{
				ArrayGetArray(array_minigames, i, xArray)
				
				menu_item_setcall(MINIGAME_MENU, i + 1, MINIGAME_MENU_CALLBACK_DIS);
			}
			
			menu_display(id, MINIGAME_MENU)
		}
	}
	
	return PLUGIN_HANDLED;
}

public minigame_callback_menu(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		return ITEM_IGNORE;
	}
	
	static sData[32]; new ignore;
	menu_item_getinfo(menu, item, ignore, sData, charsmax(sData), "", 0, ignore)
	
	if(equal(sData, "ENABLED")) return ITEM_DISABLED;
	
	return ITEM_ENABLED;
}

public minigame_callback_menu_dis(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		return ITEM_IGNORE;
	}
	
	static sData[32]; new ignore;
	menu_item_getinfo(menu, item, ignore, sData, charsmax(sData), "", 0, ignore)
	
	if(equal(sData, "DISABLED")) return ITEM_DISABLED;
	
	return ITEM_ENABLED;
}

public main_mhandler(id, menu, item)
{
	if(menu == MINIGAME_MENU)
	{
		if(item == MENU_EXIT)
		{
			if(is_user_connected(id)) minigames_menu_main(id);
			return PLUGIN_HANDLED;
		}
		
		new szName[32], szData[32], ignore;
		menu_item_getinfo(menu, item, ignore, szData, charsmax(szData), szName, charsmax(szName), ignore);
		
		if(equal(szData, "ENABLED"))
		{
			new szPlayerName[32], szText[MAX_LOG_MESSAGE_LENGTH];
			get_user_name(id, szPlayerName, charsmax(szPlayerName));
			cprint_chat(0, _, "^4~ MINIGAMES ~ ^3%s ^1has ended the ^3%s ^1match^4!", szPlayerName, szName);
			end_minigame(szName, _:MINIGAME_NO_WINNER);
			formatex(szText, charsmax(szText), "has ended the '%s' Minigame!", szName);
			jb_logmessage_action(szText, id);
		}
		else
		{
			copy(user_data[id][USER_MINIGAME], charsmax(user_data[][USER_MINIGAME]), szName);
		}
		
		minigames_menu_main(id);
		return PLUGIN_HANDLED;
	}
	
	switch( item )
	{
		case MENU_EXIT:
		{
			USER_TEAM_EDIT[id] = 0;
			remove_flag(USER_IN_TEAM_EDIT,id);
			
			if(!USER_IN_TEAM_EDIT)
			{
				if(FM_FW_PLAYER_PRETHINK_POST > -1)
				{
					unregister_forward(FM_PlayerPreThink, FM_FW_PLAYER_PRETHINK_POST, 1);
					FM_FW_PLAYER_PRETHINK_POST = -1;
				}
				
				if(FM_FW_ADDTOFULLPACK_POST > -1)
				{
					unregister_forward(FM_AddToFullPack, FM_FW_ADDTOFULLPACK_POST, 1);
					FM_FW_ADDTOFULLPACK_POST = -1;
				}
				
				for(new i = 1; i <= g_iMaxplayers; i++) arrayset(USER_EDIT_DUMMY[i], 0, sizeof USER_EDIT_DUMMY);
				
				new ent = -1;
				while((ent=engfunc(EngFunc_FindEntityByString, ent, "classname", "player_hollogram")) > 0)
				{
					set_pev(ent, pev_flags, FL_KILLME);
					dllfunc(DLLFunc_Think, ent);
				}
			}
			
			menu_destroy(menu);
			if(is_user_connected(id)) minigames_menu_main(id);
			return PLUGIN_HANDLED;
		}
		default:
		{
			new ignore, sData[3], player, iTeam;
			menu_item_getinfo(menu, item, ignore, sData, charsmax(sData), "", 0, ignore)
			menu_destroy(menu);
			
			iTeam = sData[0];
			
			if(item == 0) // De/Select a player
			{
				new szTeam[16];
				minigame_get_team_name(iTeam, szTeam, charsmax(szTeam));
				
				switch( sData[1] )
				{
					case '2': minigame_deselect_team_menu(id, szTeam, iTeam);
					case '1': minigame_select_team_menu(id, szTeam, iTeam);
				}
				
				return PLUGIN_HANDLED;
			}
			
			player = sData[1];
			
			if(!player || !is_user_available_for_minigame(player))
			{
				client_print(id, print_center, "The Player is no longer available!");
				
				new szTeam[16];
				minigame_get_team_name(iTeam, szTeam, charsmax(szTeam));
				minigame_select_team_menu(id, szTeam, iTeam);
				
				return PLUGIN_HANDLED;
			}
			else
			{
				new szTeam[16];
				minigame_get_team_name(iTeam, szTeam, charsmax(szTeam));
				
				if(user_data[id][USER_TEAM][player] == iTeam)
				{
					new ent;
					if((ent=USER_EDIT_DUMMY[player][id]) > 0)
					{
						USER_EDIT_DUMMY[player][id] = 0;
						set_pev(ent, pev_flags, FL_KILLME);
						dllfunc(DLLFunc_Think, ent);
					}
					
					user_data[id][USER_TEAM][player] = MINIGAME_TEAM_NONE;
					minigame_deselect_team_menu(id, szTeam, iTeam);
				}
				else
				{
					user_data[id][USER_TEAM][player] = iTeam;
					minigame_select_team_menu(id, szTeam, iTeam);
				}
			}
		}
	}
	return PLUGIN_HANDLED;
}

GetIndexInArrayByString(const Array:name, const string[])
{
	static xArray[MINIGAME_ESSENTIAL];
	for(new i = 0, size = ArraySize(name); i < size; i++)
	{
		ArrayGetArray(name, i, xArray);
		if(equal(xArray[MINIGAME_NAME], string)) return i;
	}
	
	return -1;
}

// forward < > (const MiniGameMOD, iAllies[32], iAllies_num, iEnemies[32], iEnemies_num)
// native register_jb_minigame(const name[], const function[])
public jb_minigame_registeration(plugin, cid)
{
	static xArray[MINIGAME_ESSENTIAL], szFunction[32];
	get_string(1, xArray[MINIGAME_NAME], charsmax(xArray[MINIGAME_NAME]))
	get_string(2, szFunction, charsmax(szFunction))
	xArray[MINIGAME_FUNCTION_ID] = get_func_id(szFunction, plugin);
	xArray[MINIGAME_PLUGIN_ID] = plugin;
	ArrayPushArray(array_minigames, xArray)
	TOTAL_MINIGAMES ++;
	return TOTAL_MINIGAMES-1;
}

// native jb_is_user_inminigame(id)
public check_user_inminigame(plugin, cid)
{
	new id = get_param(1);

	if(!is_user_connected(id))
	{
		log_amx("Error (native check_user_inminigame) User with #%d is not connected!", id);
		return -2;
	}

	return GetIndexInArrayByString(array_minigames, user_data[id][USER_IN_MINIGAME]);
}

// native jb_is_minigame_active(minigame_Id)
public is_minigame_active(plugin, cid)
{
	new minigame_Id = get_param(1);
	if(!(0 <= minigame_Id < ArraySize(array_minigames))) return -1;
	
	static xArray[MINIGAME_ESSENTIAL];
	ArrayGetArray(array_minigames, minigame_Id, xArray);
	return TrieKeyExists(trie_minigames, xArray[MINIGAME_NAME]) ? true:false;
}

// native jb_minigame_get_team_players(const minigame[], const minigame_team, team[32], &count);
public minigame_get_team_players(plugin, argc)
{
	new szMiniGameName[MAX_MINIGAME_NAME];
	get_array(1, szMiniGameName, charsmax(szMiniGameName));
	
	if(!TrieKeyExists(trie_minigames, szMiniGameName))
	{
		return 0;
	}
	
	static xArray[MINIGAME_DATA];
	TrieGetArray(trie_minigames, szMiniGameName, xArray, sizeof xArray);
	
	new i_aPrisoners[32], pris_num;
	get_players(i_aPrisoners, pris_num, "he", "TERRORIST");
	
	new j = 0;
	for(new x, iTeam = get_param(2), i = 0; i < pris_num; i++)
	{
		x = i_aPrisoners[ i ];
		i_aPrisoners[ i ] = 0;

		if(xArray[MINIGAME_PLAYERS_TEAM][x] == iTeam)
		{
			i_aPrisoners[j] = x;
			j ++;
		}
	}
	
	set_array(3, i_aPrisoners, sizeof i_aPrisoners);
	set_param_byref(4, j);
	return 1;
}

minigame_get_team_name(const iTeam = MINIGAME_TEAM_NONE, szTeamName[], len)
{
	copy(szTeamName, len, szMINIGAMES_TEAMS_NAME[iTeam]);
}
