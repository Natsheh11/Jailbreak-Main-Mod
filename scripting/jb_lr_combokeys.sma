/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <fakemeta>
#include <fun>
#include <jailbreak_core>
#include <hamsandwich>

#define PLUGIN "[JB] LR:COMBO KEY"
#define AUTHOR "Natsheh"

#define TASK_COMBOKEYS_HUD 8884672

new COMBO_KEY_DUEL, FW_FM_CMDSTART_POST;

enum(+=1)
{
	KEY_USE = 0,
	KEY_ATTACK,
	KEY_ATTACK2,
	KEY_DUCK,
	KEY_JUMP,
	KEY_MLEFT,
	KEY_MRIGHT,
	KEY_RELOAD,
	KEY_MFORWARD,
	KEY_MBACKWARD,
	
	MAX_KEYS
}

new const iComboKeys[] = {
	IN_USE,
	IN_ATTACK,
	IN_ATTACK2,
	IN_DUCK,
	IN_JUMP,
	IN_MOVELEFT,
	IN_MOVERIGHT,
	IN_RELOAD,
	IN_FORWARD,
	IN_BACK
}

new const szComboKeys[][] = {
	"USE",
	"SLASH",
	"STAB",
	"CROUCH",
	"JUMP",
	"MOVE LEFT",
	"MOVE RIGHT",
	"RELOAD",
	"MOVE FORWARD",
	"MOVE BACKWARD"
}

new g_user_progress[33], Array:g_TempArray = Invalid_Array, iLRPrisoner, iLRGuard, Float:g_delay[33];

new const correct_snd[] = "buttons/blip2.wav";
new const incorrect_snd[] = "buttons/button10.wav";

public plugin_precache()
{
	PRECACHE_SOUND(correct_snd);
	PRECACHE_SOUND(incorrect_snd);
}

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	COMBO_KEY_DUEL = register_jailbreak_lritem("Combo Key");
	
	FW_FM_CMDSTART_POST = -1;
}

public jb_lr_duel_started(prisoner, guard, duelid)
{
	if(duelid == COMBO_KEY_DUEL)
	{
		if(FW_FM_CMDSTART_POST == -1)
		{
			FW_FM_CMDSTART_POST = register_forward(FM_CmdStart, "fw_CmdStart_post", 1);
		}
		
		iLRGuard = guard;
		iLRPrisoner = prisoner;
		
		strip_user_weapons(guard)
		strip_user_weapons(prisoner)
		give_item(guard, "weapon_knife");
		give_item(prisoner, "weapon_knife");
		
		jb_block_user_weapons(guard, true, ~(1<<CSW_KNIFE))
		jb_block_user_weapons(prisoner, true, ~(1<<CSW_KNIFE))
		
		if(g_TempArray == Invalid_Array)
		{
			g_TempArray = ArrayCreate(1,1);
		}
		
		for(new i; i < MAX_KEYS; i++)
		{
			ArrayPushCell(g_TempArray, i);
		}
		
		new szString[96];
		const maxcombokeys = 7;
		for(new i, maxloop = (ArraySize(g_TempArray)-maxcombokeys); i < maxloop; i++)
		{
			ArrayDeleteItem(g_TempArray, random(ArraySize(g_TempArray)));
		}
		
		ArraySort(g_TempArray, "arraysorting_keys");
		
		for(new i, maxloop = ArraySize(g_TempArray); i < maxloop; i++)
		{
			add(szString, charsmax(szString), szComboKeys[ArrayGetCell(g_TempArray,i)])
			add(szString, charsmax(szString), "|");
		}
		
		if(szString[0] != 0)
			szString[strlen(szString)-1] = 0;
		
		set_task(0.5, "show_combokeys_hud", guard+TASK_COMBOKEYS_HUD, szString, sizeof szString, "b");
		set_task(0.5, "show_combokeys_hud", prisoner+TASK_COMBOKEYS_HUD, szString, sizeof szString, "b");
	}
}

public arraysorting_keys(Array:array, item1, item2, const data[], data_size)
{
	if(random_num(0,1) == 0) return -1;
	
	return 1;
}

public show_combokeys_hud(const szString[], taskid)
{
	new id = taskid - TASK_COMBOKEYS_HUD;
	
	if(!is_user_connected(id))
	{
		remove_task(taskid);
		return;
	}
	
	set_hudmessage(255, 255, 255, -1.0, 0.30, 2, 3.0, 0.5, 0.05, 0.2, 4);
	show_hudmessage(id, "%s^n%s", szString, g_TempArray == Invalid_Array ? "None":szComboKeys[ArrayGetCell(g_TempArray, g_user_progress[id])]);
}

public jb_lr_duel_ended(prisoner, guard, duelid)
{
	if(duelid == COMBO_KEY_DUEL)
	{
		if(FW_FM_CMDSTART_POST != -1)
		{
			unregister_forward(FM_CmdStart, FW_FM_CMDSTART_POST, 1);
			FW_FM_CMDSTART_POST = -1;
		}
		
		iLRGuard = 0;
		iLRPrisoner = 0;
		
		if(g_TempArray != Invalid_Array)
		{
			ArrayDestroy(g_TempArray);
			g_TempArray = Invalid_Array;
		}
		
		remove_task(guard+TASK_COMBOKEYS_HUD);
		remove_task(prisoner+TASK_COMBOKEYS_HUD);
		
		jb_block_user_weapons(guard, false);
		jb_block_user_weapons(prisoner, false);
		
		g_user_progress[guard] = 0;
		g_user_progress[prisoner] = 0;
	}
}

public fw_CmdStart_post(id, uc_handle, seed)
{
	if(iLRGuard != id && iLRPrisoner != id)
	{
		return;
	}
	
	if(g_delay[id] >= get_gametime())
	{
		return;
	}
	
	static iButtons; iButtons = get_uc(uc_handle, UC_Buttons);
	static iOldButtons; iOldButtons = pev(id, pev_oldbuttons);
	
	if(iButtons == iComboKeys[ArrayGetCell(g_TempArray, g_user_progress[id])])
	{
		g_delay[id] = get_gametime() + 0.1;
		emit_sound(id, CHAN_AUTO, correct_snd, VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
		
		if((g_user_progress[id] + 1) == ArraySize(g_TempArray))
		{
			g_user_progress[id] = 0;
			keycombo_end(id);
		}
		else
		{
			g_user_progress[id]++;
		}
	}
	else if( g_user_progress[id] > 0 && iButtons > 0 && (iOldButtons != iComboKeys[ArrayGetCell(g_TempArray, g_user_progress[id]-1)]) )
	{
		g_delay[id] = get_gametime() + 0.1;
		g_user_progress[id] = 0;
		emit_sound(id, CHAN_AUTO, incorrect_snd, VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
	}
}

keycombo_end(winner)
{
	new szWinnerName[32];
	get_user_name(winner, szWinnerName, charsmax(szWinnerName));
	
	set_hudmessage(225, 225, 225, -1.0, 0.25, 2, 6.0, 3.0, 0.05, 0.2, -1);
	show_hudmessage(0, "%s has won the KeyCombo Duel!", szWinnerName);
	
	cprint_chat(0, _, "!g%s !yhas won the !gKeyCombo !yDuel!t!", szWinnerName);
	
	const PLAYER_GIBS = 2;

	if(iLRPrisoner == winner)
	{
		ExecuteHamB(Ham_Killed, iLRGuard, winner, PLAYER_GIBS);
		return;
	}
	if(iLRGuard == winner)
	{
		ExecuteHamB(Ham_Killed, iLRPrisoner, winner, PLAYER_GIBS);
	}
}
