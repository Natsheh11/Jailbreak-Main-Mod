/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <jailbreak_core>
#include <fakemeta>
#include <xs>
#include <fun>
#include <hamsandwich>
#include <nvault>
#include <cstrike>
#include <engine>
#include <rog>

#define PLUGIN "[JB] DAY: Hunger-Games"
#define AUTHOR "Natsheh"

#if AMXX_VERSION_NUM > 182
#define client_disconnect client_disconnected
#endif

#define TASK_SPAWN_BOXES 9353781
#define TASK_COUNTDOWN 49873623
#define TASK_SHOW_BOXES 23245435
#define TASK_CREATE_BOX 3456346

#define ORIGIN_RADIUS_SPAWNS 300.0

#define MAX_BOXES 40
#define BOXES_DISTANCE 800.0
#define BOXES_RESTRICTION_DISTANCE 1400.0

#define ADMIN_FLAG_HG_EDITMENU ADMIN_BAN


//////////////////////////////////////////////////
//=============[nVault saving formats]===========//
//////////////////////////////////////////////////

// saving starting position format
// KEY: MAPNAME ( %s )
// VALUE: "X" "Y" "Z"

// saving boxes position format
// KEY: MAPNAME_BOX_ID ( %s_BOX_%d )
// VALUE: "X" "Y" "Z" "spawn delay" "box containment" "box max spawn times"

// saving boxes quantity format
// KEY: MAPNAME_BOX_SPAWNS ( %s_BOX_SPAWNS )
// VALUE: "max boxes"

//////////////////////////////////////////////////
//=============[nVault saving formats]===========//
//////////////////////////////////////////////////

new const CSW_WEAPONS[] = {
	CSW_KNIFE,
	CSW_AK47,
	CSW_AUG,
	CSW_AWP,
	CSW_DEAGLE,
	CSW_M4A1,
	CSW_M3,
	CSW_ELITE,
	CSW_G3SG1,
	CSW_FIVESEVEN,
	CSW_FAMAS,
	CSW_SG550,
	CSW_GALI,
	CSW_GLOCK18,
	CSW_M249,
	CSW_XM1014,
	CSW_SCOUT,
	CSW_SG552,
	CSW_MAC10,
	CSW_UMP45,
	CSW_USP,
	CSW_TMP,
	CSW_P228,
	CSW_P90,
	CSW_MP5NAVY
}

new DAY_INDEX, g_vault, bool:hg_available, Float:Origin_Spawn[3];

new Trie:trie_box_spawns_origin, Trie:trie_box_spawns_attempt, g_MAXBOXES;
new HamHook:EnableHook;
new HamHook:EnableHook2;
new HamHook:EnableHook3;
new HamHook:EnableHook4;
new HamHook:EnableHook5;

const OFFSET_TEAM = 114;
#define fm_get_user_team(%1)		clamp(get_pdata_int(%1,OFFSET_TEAM),TEAM_ANY,TEAM_SPECTATOR)
#define fm_set_user_team(%1,%2)		set_pdata_int(%1,OFFSET_TEAM,%2)

new const MODEL_BOX[] = "models/jailbreak/hungergames/box.mdl";
new const SND_CD[] = "sound/jailbreak/hungergames/hungergames_countdown.mp3";
new const SND_BEGINING[] = "sound/jailbreak/hungergames/hungergames_begining.wav";
new MAP_NAME[64], bool:g_showboxes[33], g_boxdelay_spawn[33], g_user_wpn[33], g_boxmax_spawns[33];

new laser_spr, FW_FM_SET_MODEL_POST, bool:g_players_frozen, g_msg_radar;
new FW_MESSAGE_RADAR = INVALID_HANDLE;

static const Float:PLAYER_MAXS[3] = { 16.0, 16.0, 36.0 }
static const Float:g_flBOX_MAXS[3] = { 16.0, 16.0, 16.0 }
static const Float:PLAYER_MINS[3] = { -16.0, -16.0, -36.0 }
static const Float:g_flBOX_MINS[3] = { -16.0, -16.0, -0.0 }
static const Float:PLAYER_SIZE[] = { -16.0, -16.0, -36.0, 16.0, 16.0, 36.0 };

enum _:BOX_INFO
{
	Float:BOX_ORIGIN[3],
	BOX_SPAWN_DELAY,
	BOX_WEAPON_INSIDE_TYPE,
	BOX_MAX_SPAWNS
}

public plugin_precache()
{
	PRECACHE_FILE(SND_BEGINING);
	PRECACHE_FILE(SND_CD);
	PRECACHE_WORLD_ITEM(MODEL_BOX);
	
	laser_spr = PRECACHE_SPRITE_I("sprites/laserbeam.spr");
}

public plugin_end()
{
	if(g_vault != INVALID_HANDLE) nvault_close(g_vault);
	TrieDestroy(trie_box_spawns_origin);
	TrieDestroy(trie_box_spawns_attempt);
}

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	DAY_INDEX = register_jailbreak_day("Hunger Games", 0, (8.0 * 60), DAY_ONE_SURVIVOR);
	
	g_vault = nvault_open("jb_hungergames_data");
	
	if(g_vault == INVALID_HANDLE) set_fail_state("Error opening nvault file!");
	
	trie_box_spawns_origin = TrieCreate();
	trie_box_spawns_attempt = TrieCreate();
	g_msg_radar = get_user_msgid("Radar");
	
	new null, szString[128], szOrigins[3][10];
	get_mapname(MAP_NAME, charsmax(MAP_NAME));
	
	if(nvault_lookup(g_vault, MAP_NAME, szString, charsmax(szString), null))
	{
		parse(szString, szOrigins[0], charsmax(szOrigins[]),
			szOrigins[1], charsmax(szOrigins[]), szOrigins[2], charsmax(szOrigins[]));
		
		for(new i; i < sizeof szOrigins; i++)
		{
			remove_quotes(szOrigins[i]);
			Origin_Spawn[i] = str_to_float(szOrigins[i]);
		}
		
		hg_available = true;
	}
	
	if(!hg_available)
	{
		ROGInitialize((ORIGIN_RADIUS_SPAWNS * 2.0), "check_origin_spawn");
		set_task(1.0, "task_rog_set_origin_spawn");
	}
	
	new szNum[10];
	formatex(szString, charsmax(szString), "%s_BOX_SPAWNS", MAP_NAME);
	nvault_lookup(g_vault, szString, szNum, charsmax(szNum), null)
	g_MAXBOXES = str_to_num(szNum);
	
	if(g_MAXBOXES == 0)
	{
		set_task(1.5, "task_rog_init_boxes_spawns");
		set_task(2.5, "task_rog_set_boxes_spawns");
	}
	else
	{
		for(new i, xArray[BOX_INFO], szWpnType[4], szDelay[10], szMaxSpawns[5]; i < g_MAXBOXES; i++)
		{
			formatex(szString, charsmax(szString), "%s_BOX_%d", MAP_NAME, i);
			if(nvault_lookup(g_vault, szString, szString, charsmax(szString), null))
			{
				parse(szString, szOrigins[0], charsmax(szOrigins[]),
					szOrigins[1], charsmax(szOrigins[]), szOrigins[2], charsmax(szOrigins[]),
					szDelay, charsmax(szDelay), szWpnType, charsmax(szWpnType),
					szMaxSpawns, charsmax(szMaxSpawns));
			
				for(new i; i < sizeof szOrigins; i++)
				{
					remove_quotes(szOrigins[i]);
					xArray[BOX_ORIGIN][i] = _:str_to_float(szOrigins[i]);
				}
				
				remove_quotes(szDelay);
				remove_quotes(szWpnType);
				remove_quotes(szMaxSpawns);
				xArray[BOX_SPAWN_DELAY] = str_to_num(szDelay);
				xArray[BOX_WEAPON_INSIDE_TYPE] = str_to_num(szWpnType);
				xArray[BOX_MAX_SPAWNS] = str_to_num(szMaxSpawns);
				
				formatex(szString, charsmax(szString), "%s_BOX_%d", MAP_NAME, i);
				TrieSetArray(trie_box_spawns_origin, szString, xArray, sizeof xArray);
			}
		}
	}
	
	DisableHamForward(EnableHook = RegisterHam(Ham_Use, "func_breakable", "fw_breakable_box_post", 1));
	DisableHamForward(EnableHook2 = RegisterHam(Ham_Spawn, "player", "fw_player_spawn_post", 1));
	DisableHamForward(EnableHook4 = RegisterHam(Ham_Use, "func_button", "fw_func_button_pre", 0));
	DisableHamForward(EnableHook5 = RegisterHam(Ham_Use, "button_target", "fw_func_button_pre", 0));
	DisableHamForward(EnableHook3 = RegisterHam(Ham_Touch, "func_breakable", "fw_breakable_touch_post", 1));
	
	register_clcmd("say /hg", "clcmd_hg");
	register_clcmd("jb_hg_spawns_menu", "clcmd_hg");
	register_concmd("jb_hg_remove_boxes", "clcmd_remove_boxes", ADMIN_IMMUNITY, "remove all hungergames box spawns!");
	register_concmd("jb_hg_remove_spawn_origin", "clcmd_remove_origin", ADMIN_IMMUNITY, "remove the hungergames origin spawn!");
}

public task_rog_set_origin_spawn()
{
	if(!ROGOriginsCount()) return;

	new Float:fOrigin[3];
	ROGShuffleOrigins();
	ROGGetOrigin(fOrigin);
	save_origin_spawn(fOrigin);
}

public task_rog_init_boxes_spawns()
{
	ROGInitialize(BOXES_DISTANCE, "check_box_spawn");
}

public task_rog_set_boxes_spawns()
{
	if(hg_available)
	{ // Add the knife spawn !
		addbox_spawn(Origin_Spawn, 1, CSW_KNIFE, 0);
	}
	
	ROGShuffleOrigins();
	
	for(new i, Float:fOrigin[3]; i < MAX_BOXES; i++)
	{
		ROGGetOrigin(fOrigin);
		addbox_spawn(fOrigin, random(30), 0 /* 0 for random weapon */, random(3));
	}
}

public clcmd_remove_origin(id, level, cid)
{
	if(!cmd_access(id, level, cid, 1)) return PLUGIN_HANDLED;
	
	console_print(id, " ~={ HUNGER GAMES }=~ Spawn Origin have been removed!");
	nvault_remove(g_vault, MAP_NAME);
	hg_available = false;
	return PLUGIN_HANDLED;
}

public clcmd_remove_boxes(id, level, cid)
{
	if(!cmd_access(id, level, cid, 1)) return PLUGIN_HANDLED;
	
	new szString[96];
	formatex(szString, charsmax(szString), "%s_BOX_SPAWNS", MAP_NAME);
	nvault_set(g_vault, szString, "0");
	console_print(id, " ~={ HUNGER GAMES }=~ All boxes have been removed!");
	g_MAXBOXES = 0;
	return PLUGIN_HANDLED;
}

public check_origin_spawn(Float:fOrigin[3])
{
	if(check_hungergames_spawn(fOrigin))
	{
		return 1;
	}
	return 0;
}

public check_box_spawn(Float:fOrigin[3])
{
	if( object_stuck(fOrigin, g_flBOX_MAXS, g_flBOX_MINS) || 
		(hg_available && get_distance_f(fOrigin, Origin_Spawn) <= BOXES_RESTRICTION_DISTANCE))
	{
		// box is stuck or its nearby the hungergame spawn then its bad spawn.
		return 0;
	}
	
	return 1;
}

public jb_day_preselected(id, Dayid)
{
	if(DAY_INDEX == Dayid)
	{
		if(!hg_available)
		{
			return JB_MENU_ITEM_UNAVAILABLE;
		}
	}
	
	return PLUGIN_CONTINUE;
}

public radar_block()
{
	return PLUGIN_HANDLED;
}

public fw_player_spawn_post(id)
{
	if(!is_user_alive(id)) return;
	
	strip_user_weapons(id);
}

public fw_breakable_touch_post(const ent, const toucher)
{
	if(pev_valid(ent) && is_user_alive(toucher)) 
	{
		static sTargetname[24];
		pev(ent, pev_target, sTargetname, charsmax(sTargetname))
		
		if(equal(sTargetname, "HUNGERGAMES_BOX"))
		{
			ExecuteHamB(Ham_Use, ent, toucher, toucher, 2, 1.0) ;
		}
	}
}

public fw_func_button_pre(entity)
{
	new szInfo[ 32 ]
	pev( entity, pev_target, szInfo, charsmax( szInfo ) );
	
	new iTarget = engfunc( EngFunc_FindEntityByString, -1, "targetname", szInfo );
	
	if( iTarget )
		pev( iTarget, pev_classname, szInfo, charsmax( szInfo ) );
	
	return equal( szInfo, "multi_manager" ) || equal( szInfo, "game_player_equip" ) ? HAM_SUPERCEDE : HAM_IGNORED;
}

public clcmd_hg(id)
{
	g_boxdelay_spawn[id] = 5;
	hungergames_editmenu(id);
	return 1;
}

public fw_breakable_box_post(entity, user)
{
	new szString[96], xArray[BOX_INFO], x;
	formatex(szString, charsmax(szString), "%s_BOX_%d", MAP_NAME, (x=pev(entity, pev_iuser4)));
	TrieGetArray(trie_box_spawns_origin, szString, xArray, sizeof xArray);
	
	new cswid = xArray[BOX_WEAPON_INSIDE_TYPE];
	if(!cswid) cswid = CSW_WEAPONS[random(sizeof CSW_WEAPONS)];
	
	new szWeaponName[32]; get_weaponname(cswid, szWeaponName, charsmax(szWeaponName));
	new ent = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, szWeaponName));
	
	if(!ent) return;
	
	engfunc(EngFunc_SetSize, ent, Float:{-1.0,-1.0,-1.0}, Float:{1.0,1.0,1.0});
	
	set_pev(ent, pev_solid, SOLID_BBOX);
	set_pev(ent, pev_movetype, MOVETYPE_TOSS);
	set_pev(ent, pev_iuser2, 5000);
	
	new Float:fOrigin[3];
	pev(entity, pev_origin, fOrigin);
	engfunc(EngFunc_SetOrigin, ent, fOrigin);

	set_pev(entity, pev_flags, FL_KILLME);
	dllfunc(DLLFunc_Think, entity);
	
	new BoxSpawns;
	TrieGetCell(trie_box_spawns_attempt, szString, BoxSpawns);
	
	if(BoxSpawns > 0 || BoxSpawns == -1)
	{
		set_task(float(xArray[BOX_SPAWN_DELAY]), "create_box", TASK_CREATE_BOX+x);
	}
	
	set_pev(ent, pev_spawnflags, SF_NORESPAWN);
	dllfunc(DLLFunc_Spawn, ent);
	
	if(cswid == CSW_KNIFE)
	{
		if(is_user_alive(user))
		{
			fake_touch(ent, user);
		}
	}
	else
	{
		const m_iClip = 51;
		const m_iDefaultAmmo = 56;
		set_pdata_int(ent, m_iClip, random( 10 ), ._linuxdiff = 4);
		set_pdata_int(ent, m_iDefaultAmmo, 0, ._linuxdiff = 4);
	}
}

public client_disconnect(id)
{
	g_showboxes[id] = false;
	remove_task(TASK_SHOW_BOXES+id);
}

public jb_pretouch_wpnbox(ent, player, bool:bBlock)
{
	if(jb_get_current_day() != DAY_INDEX) return PLUGIN_CONTINUE;
	
	if(pev(ent, pev_iuser2) == 5000)
	{
		return PLUGIN_CONTINUE;
	}
	
	return HAM_SUPERCEDE;
}

public jb_day_ended(iDayid)
{
	if(iDayid == DAY_INDEX)
	{
		DisableHamForward(EnableHook);
		DisableHamForward(EnableHook2);
		DisableHamForward(EnableHook3);
		DisableHamForward(EnableHook4);
		DisableHamForward(EnableHook5);

		if(FW_FM_SET_MODEL_POST)
		{
			unregister_forward(FM_SetModel, FW_FM_SET_MODEL_POST, 1);
			FW_FM_SET_MODEL_POST = 0;
		}

		if(FW_MESSAGE_RADAR != INVALID_HANDLE)
		{
			unregister_message(g_msg_radar, FW_MESSAGE_RADAR);
			FW_MESSAGE_RADAR = INVALID_HANDLE;
		}

		remove_task(TASK_SPAWN_BOXES);		
		remove_task(TASK_COUNTDOWN);
		
		new ent;
		while((ent = engfunc(EngFunc_FindEntityByString, ent, "target", "HUNGERGAMES_BOX")) > 0)
		{
			set_pev(ent, pev_flags, FL_KILLME);
			dllfunc(DLLFunc_Think, ent);
		}
		
		client_cmd(0, "stopsound; mp3 stop;");
		
		for(new i; i < g_MAXBOXES; i++)
		{
			remove_task(i+TASK_CREATE_BOX);
		}
		
		if(g_players_frozen == true)
		{
			new players[32],pnum;
			get_players(players,pnum, "ah");
			for(new i, player; i < pnum; i++)
			{
				player = players[i];
				entity_set_int(player, EV_INT_flags, (entity_get_int(player, EV_INT_flags)&~FL_FROZEN));
			}
			
			g_players_frozen = false;
		}
	}
}

public fw_SetModel_post(ent, const model[])
{
	if(!pev_valid(ent)) return;
	
	if(equal(model, "models", 6))
	{
		set_pev(ent, pev_iuser2, 5000);
	}
}

new g_counts;

public jb_day_start(iDayid)
{
	if(iDayid == DAY_INDEX)
	{
		if(!hg_available)
		{
			cprint_chat(0, _, "!gHunger-Games !tSpawn Origin is not set!g, !yfailed to start!t!");
			return JB_HANDLED;
		}

		new players[32], pnum;
		get_players(players, pnum, "ah");

		if(pnum <= 2)
		{
			cprint_chat(0, _, "!gHunger-Games !tRequires at least three players to play the day!y!");
			return JB_HANDLED;
		}
	}
	return JB_IGNORED;
}

public jb_day_started(iDayid)
{
	if(iDayid == DAY_INDEX)
	{
		new players[32], pnum;
		get_players(players, pnum, "ah");
		
		EnableHamForward(EnableHook);
		EnableHamForward(EnableHook2);
		EnableHamForward(EnableHook3);
		EnableHamForward(EnableHook4);
		EnableHamForward(EnableHook5);

		if(!FW_FM_SET_MODEL_POST) FW_FM_SET_MODEL_POST = register_forward(FM_SetModel, "fw_SetModel_post", 1);
		if(FW_MESSAGE_RADAR == INVALID_HANDLE) FW_MESSAGE_RADAR = register_message(g_msg_radar, "radar_block");
		
		
		new Float:fOrigin[3], Float:fOrigin2[3], Float:fPAngle[3];
		new Float:fAngle[3], Float:AngleMulScalar = (AngleMulScalar = 360.0 / pnum), Float:fVector[3];
		fOrigin=Origin_Spawn;

		for(new i, player; i < pnum; i++)
		{
			player = players[i];
			
			angle_vector(fAngle, ANGLEVECTOR_RIGHT, fVector);
			xs_vec_mul_scalar(fVector, ORIGIN_RADIUS_SPAWNS, fVector);
			xs_vec_add(fOrigin, fVector, fOrigin2);
			
			strip_user_weapons(player);
			
			xs_vec_sub(fOrigin, fOrigin2, fPAngle);
			xs_vec_normalize(fPAngle, fPAngle);
			vector_to_angle(fPAngle, fPAngle);
			fPAngle[0] = fPAngle[2] = 0.0;
			set_pev(player, pev_angles, fPAngle);
			set_pev(player, pev_v_angle, fPAngle);
			set_pev(player, pev_fixangle, 1);
			
			set_pev(player, pev_origin, fOrigin2);
			entity_set_int(player, EV_INT_flags, entity_get_int(player, EV_INT_flags)|FL_FROZEN);
			
			fAngle[1] += AngleMulScalar;
		}
		
		g_players_frozen = true;
		g_counts = 10;
		client_cmd(0, "spk ^"%s^"", SND_BEGINING);
		set_task(5.0, "task_countdown", TASK_COUNTDOWN);
		set_task(4.5, "task_sound", TASK_COUNTDOWN);
		
		spawn_boxes();
	}
}

spawn_boxes()
{
	new szKey[96];
	for(new i, xArray[BOX_INFO]; i < g_MAXBOXES; i++)
	{
		formatex(szKey, charsmax(szKey), "%s_BOX_%d", MAP_NAME, i);
		TrieGetArray(trie_box_spawns_origin, szKey, xArray, sizeof xArray);
		
		TrieSetCell(trie_box_spawns_attempt, szKey, xArray[BOX_MAX_SPAWNS]);
		set_task(float(xArray[BOX_SPAWN_DELAY]), "create_box", i+TASK_CREATE_BOX);
	}
}

public create_box(taskid)
{
	new i = taskid - TASK_CREATE_BOX;
	
	new ent = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "func_breakable"));
	if(!ent) return;
	
	set_pev(ent, pev_target, "HUNGERGAMES_BOX");
	engfunc(EngFunc_SetModel, ent, MODEL_BOX);
	engfunc(EngFunc_SetSize, ent, g_flBOX_MINS, g_flBOX_MAXS);
	
	const m_Material = 36;
	const MATERIAL_WOOD = 1;
	set_pdata_int(ent, m_Material, MATERIAL_WOOD, ._linuxdiff = 4);

	set_pev(ent, pev_solid, SOLID_BBOX);
	set_pev(ent, pev_movetype, MOVETYPE_TOSS);
	set_pev(ent, pev_iuser4, i);
	
	new Float:fOrigin[3], xArray[BOX_INFO], szKey[96], BoxSpawns;
	formatex(szKey, charsmax(szKey), "%s_BOX_%d", MAP_NAME, i);
	TrieGetArray(trie_box_spawns_origin, szKey, xArray, sizeof xArray);
	TrieGetCell(trie_box_spawns_attempt, szKey, BoxSpawns);
	if(BoxSpawns > 0) TrieSetCell(trie_box_spawns_attempt, szKey, --BoxSpawns);
	fOrigin[0] = xArray[BOX_ORIGIN][0];
	fOrigin[1] = xArray[BOX_ORIGIN][1];
	fOrigin[2] = xArray[BOX_ORIGIN][2];
	engfunc(EngFunc_SetOrigin, ent, fOrigin);
}

public hungergames_editmenu(id)
{
	if(!(get_user_flags(id) & ADMIN_FLAG_HG_EDITMENU))
	{
		return;
	}
	
	new menu = menu_create("Hunger Games Settings!", "m_handler")
	
	new szText[64]
	
	menu_additem(menu, "Set start spawn point");
	menu_additem(menu, "Add box spawn point");
	menu_additem(menu, "Remove box spawn point");
	
	formatex(szText, charsmax(szText), "^n\rMax Boxes: \y%d^n", g_MAXBOXES);
	menu_addtext(menu, szText, 0);
	
	new szWpname[32]; copy(szWpname, charsmax(szWpname), "weapon_random");
	if(CSW_P90 >= g_user_wpn[id] >= CSW_P228) get_weaponname(g_user_wpn[id], szWpname, charsmax(szWpname));
	ucfirst(szWpname[7]);
	
	formatex(szText, charsmax(szText), "Box Containment: \r%s", szWpname[7]);
	menu_additem(menu, szText);
	
	formatex(szText, charsmax(szText), "^nBox Spawn Delay: %d Sec!", g_boxdelay_spawn[id])
	menu_addtext(menu, szText, 0);
	menu_additem(menu, "\y+ Increase")
	menu_additem(menu, "\r- Decrease")
	
	num_to_str(g_boxmax_spawns[id], szWpname, charsmax(szWpname))
	if(g_boxmax_spawns[id] == -1) formatex(szWpname, charsmax(szWpname), "Infinite");
	
	formatex(szText, charsmax(szText), "^nBox Max Spawns: %s time's!", szWpname);
	menu_addtext(menu, szText, 0);
	menu_additem(menu, "\y+ Increase");
	menu_additem(menu, "\r- Decrease^n");
	
	formatex(szText, charsmax(szText), "Show Spawns: \y%s^n", g_showboxes[id] == true ? "Yes":"No")
	menu_additem(menu, szText)
	
	menu_additem(menu, "\rExit.");
	
	menu_setprop(menu, MPROP_PERPAGE, 0);
	menu_display(id, menu);
}

public m_handler(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	menu_destroy(menu);
	
	switch( item )
	{
		case 0:
		{
			new Float:fOrigin[3];
			pev(id, pev_origin, fOrigin);
			
			if(check_hungergames_spawn(fOrigin, id))
			{
				save_origin_spawn(fOrigin);
				cprint_chat(id, _, " ~={ HUNGER GAMES }=~ !gGOOD !ystart point!");
			}
			else
			{
				cprint_chat(id, _, " ~={ HUNGER GAMES }=~ !tBAD !ystart point!");
			}
		}
		case 1:
		{
			new Float:fOrigin[3];
			pev(id, pev_origin, fOrigin);
			
			addbox_spawn(fOrigin, g_boxdelay_spawn[id], g_user_wpn[id], g_boxmax_spawns[id]);
			
			cprint_chat(id, _, " ~={ HUNGER GAMES }=~ !gAdded a box in your location!");
		}
		case 2:
		{
			new Float:fOrigin[3];
			pev(id, pev_origin, fOrigin);
			
			if(removebox_spawn(fOrigin))
				cprint_chat(id, _, " ~={ HUNGER GAMES }=~ !tRemoved the nearby box!");
		}
		case 3:
		{
			weapon_menu(id);
			return PLUGIN_HANDLED;
		}
		case 4:
		{
			g_boxdelay_spawn[id] = clamp((g_boxdelay_spawn[id] += 5), 5, 120);
		}
		case 5:
		{
			g_boxdelay_spawn[id] = clamp((g_boxdelay_spawn[id] -= 5), 5, 120);
		}
		case 6:
		{
			g_boxmax_spawns[id] = clamp((g_boxmax_spawns[id] += 1), -1, 1000);
		}
		case 7:
		{
			g_boxmax_spawns[id] = clamp((g_boxmax_spawns[id] -= 1), -1, 1000);
		}
		case 8:
		{
			g_showboxes[id] = g_showboxes[id] ? false:true;
			remove_task(TASK_SHOW_BOXES+id);
			
			if(g_showboxes[id])
			{
				set_task(1.0, "task_show_boxes", TASK_SHOW_BOXES+id, _, _, "b");
			}
		}
		default: return PLUGIN_HANDLED;
	}
	
	hungergames_editmenu(id)
	return PLUGIN_HANDLED;
}

weapon_menu(id)
{
	new menu = menu_create("Choose the weapon type!", "mhandler2");
	
	menu_additem(menu, "Random", "0");
	
	for(new i, szInfo[4], szWeapon[32]; i < sizeof CSW_WEAPONS; i++)
	{
		get_weaponname(CSW_WEAPONS[i], szWeapon, charsmax(szWeapon))
		ucfirst(szWeapon[7]);
		num_to_str(CSW_WEAPONS[i], szInfo, charsmax(szInfo));
		menu_additem(menu, szWeapon[7], szInfo)
	}
	
	menu_setprop(menu, MPROP_EXITNAME, "Back?");
	menu_display(id, menu);
}

public mhandler2(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu);
		hungergames_editmenu(id)
		return PLUGIN_HANDLED;
	}
	
	new szData[4], null;
	menu_item_getinfo(menu, item, null, szData, charsmax(szData), "", 0, null);
	menu_destroy(menu);
	
	g_user_wpn[id] = str_to_num(szData);
	
	hungergames_editmenu(id)
	return PLUGIN_HANDLED;
}

public task_show_boxes(taskid)
{
	new id = taskid - TASK_SHOW_BOXES;
	
	for(new i, Float:fOrigin[3], szString[96]; i < g_MAXBOXES; i++)
	{
		formatex(szString, charsmax(szString), "%s_BOX_%d", MAP_NAME, i)
		TrieGetArray(trie_box_spawns_origin, szString, fOrigin, sizeof fOrigin);
		
		message_begin(MSG_ONE_UNRELIABLE, SVC_TEMPENTITY, _, id);
		write_byte(TE_BEAMPOINTS)
		engfunc(EngFunc_WriteCoord, fOrigin[0]);
		engfunc(EngFunc_WriteCoord, fOrigin[1])
		engfunc(EngFunc_WriteCoord, fOrigin[2] - 20.0)
		engfunc(EngFunc_WriteCoord, fOrigin[0])
		engfunc(EngFunc_WriteCoord, fOrigin[1])
		engfunc(EngFunc_WriteCoord, fOrigin[2] + 20.0)
		write_short(laser_spr)
		write_byte(0) 
		write_byte(10) 
		write_byte(10) 
		write_byte(20) 
		write_byte(0) 
		write_byte(200)
		write_byte(200)
		write_byte(0)
		write_byte(250)
		write_byte(1)
		message_end()
	}
	
	if(hg_available)
	{
		check_hungergames_spawn(Origin_Spawn, id);
	}
}

public task_sound(taskid)
{
	client_cmd(0, "mp3 play ^"%s^"", SND_CD);
}

public task_countdown(taskid)
{
	if(--g_counts <= 0)
	{
		new players[32], pnum;
		get_players(players, pnum, "ah")
		
		for(new i, player; i < pnum; i++)
		{
			player = players[i];
			entity_set_int(player, EV_INT_flags, (entity_get_int(player, EV_INT_flags)&~FL_FROZEN));
		}
		
		
		g_players_frozen = false;
		remove_task(taskid)
		return;
	}
	
	set_hudmessage(127, 255, 127, -1.0, 0.24, 1, 6.0, 0.98, _, _, -1)
	show_hudmessage(0, "---> %d <---", g_counts)
	
	
	set_task(1.0, "task_countdown", TASK_COUNTDOWN);
}

bool:object_stuck(const Float:fOrigin[3], const Float:Maxs[3], const Float:Mins[3])
{
	for(new i, Float:tmpOrigin[3]; i < 8; i++)
	{
		switch( i )
		{
			case 0:
			{
				tmpOrigin[0] = fOrigin[0] + Maxs[0];
				tmpOrigin[1] = fOrigin[1] + Maxs[1];
				tmpOrigin[2] = fOrigin[2] + Maxs[2];
			}
			case 1:
			{
				tmpOrigin[0] = fOrigin[0] + Mins[0];
				tmpOrigin[1] = fOrigin[1] + Mins[1];
				tmpOrigin[2] = fOrigin[2] + Mins[2];
			}
			case 2:
			{
				tmpOrigin[0] = fOrigin[0] + Mins[0];
				tmpOrigin[1] = fOrigin[1] + Mins[1];
				tmpOrigin[2] = fOrigin[2] + Maxs[2];
			}
			case 3:
			{
				tmpOrigin[0] = fOrigin[0] + Maxs[0];
				tmpOrigin[1] = fOrigin[1] + Maxs[1];
				tmpOrigin[2] = fOrigin[2] + Mins[2];
			}
			case 4:
			{
				tmpOrigin[0] = fOrigin[0] + Maxs[0];
				tmpOrigin[1] = fOrigin[1] + Mins[1];
				tmpOrigin[2] = fOrigin[2] + Maxs[2];
			}
			case 5:
			{
				tmpOrigin[0] = fOrigin[0] + Mins[0];
				tmpOrigin[1] = fOrigin[1] + Maxs[1];
				tmpOrigin[2] = fOrigin[2] + Mins[2];
			}
			case 6:
			{
				tmpOrigin[0] = fOrigin[0] + Mins[0];
				tmpOrigin[1] = fOrigin[1] + Maxs[1];
				tmpOrigin[2] = fOrigin[2] + Maxs[2];
			}
			case 7:
			{
				tmpOrigin[0] = fOrigin[0] + Maxs[0];
				tmpOrigin[1] = fOrigin[1] + Mins[1];
				tmpOrigin[2] = fOrigin[2] + Mins[2];
			}
		}
		
		if(engfunc(EngFunc_PointContents, tmpOrigin) != CONTENTS_EMPTY)
		{
			return true;
		}
	}
	return false;
}

removebox_spawn(const Float:fOrigin2[3])
{
	new szString[128], szString2[128], szValue[128];
	
	for(new i, xArray[BOX_INFO], Float:fOrigin[3]; i < g_MAXBOXES; i++)
	{
		formatex(szString, charsmax(szString), "%s_BOX_%d", MAP_NAME, i)
		TrieGetArray(trie_box_spawns_origin, szString, xArray, sizeof xArray);
		fOrigin[0] = xArray[BOX_ORIGIN][0];
		fOrigin[1] = xArray[BOX_ORIGIN][1];
		fOrigin[2] = xArray[BOX_ORIGIN][2];
		if(get_distance_f(fOrigin, fOrigin2) <= 50.0)
		{
			formatex(szString2, charsmax(szString2), "%s_BOX_SPAWNS", MAP_NAME);
			num_to_str(--g_MAXBOXES, szValue, charsmax(szValue))
			nvault_set(g_vault, szString2, szValue);
			
			formatex(szString2, charsmax(szString2), "%s_BOX_%d", MAP_NAME, g_MAXBOXES)
			nvault_get(g_vault, szString2, szValue, charsmax(szValue));
			nvault_set(g_vault, szString, szValue);
			TrieGetArray(trie_box_spawns_origin, szString2, xArray, sizeof xArray);
			TrieSetArray(trie_box_spawns_origin, szString, xArray, sizeof xArray);
			
			TrieDeleteKey(trie_box_spawns_origin, szString2);
			nvault_remove(g_vault, szString2);
			
			if(jb_get_current_day() == DAY_INDEX)
			{
				new BoxSpawns;
				TrieGetCell(trie_box_spawns_attempt, szString2, BoxSpawns);
				TrieSetCell(trie_box_spawns_attempt, szString, BoxSpawns);
				remove_task(g_MAXBOXES+TASK_CREATE_BOX);
			}
			
			return true;
		}
	}
	
	return false;
}

addbox_spawn(const Float:fOrigin[3], const spawn_delay = 1, const weapon_id = CSW_KNIFE, const max_respawn_times=0)
{
	new szString[96], xArray[BOX_INFO], szValue[128];
	
	xArray[BOX_ORIGIN][0] = _:fOrigin[0];
	xArray[BOX_ORIGIN][1] = _:fOrigin[1];
	xArray[BOX_ORIGIN][2] = _:fOrigin[2];
	xArray[BOX_SPAWN_DELAY] = spawn_delay;
	xArray[BOX_WEAPON_INSIDE_TYPE] = weapon_id;
	xArray[BOX_MAX_SPAWNS] = max_respawn_times;
	
	formatex(szString, charsmax(szString), "%s_BOX_%d", MAP_NAME, g_MAXBOXES);
	TrieSetArray(trie_box_spawns_origin, szString, xArray, sizeof xArray);
	formatex(szValue, charsmax(szValue), "^"%.10f^" ^"%.10f^" ^"%.10f^" ^"%d^" ^"%d^" ^"%d^"",
						fOrigin[0], fOrigin[1], fOrigin[2],
						spawn_delay, weapon_id, max_respawn_times);
	nvault_set(g_vault, szString, szValue);
	
	if(jb_get_current_day() == DAY_INDEX)
	{
		TrieSetCell(trie_box_spawns_attempt, szString, max_respawn_times);
		set_task(float(spawn_delay), "create_box", g_MAXBOXES+TASK_CREATE_BOX)
	}
	
	formatex(szString, charsmax(szString), "%s_BOX_SPAWNS", MAP_NAME);
	num_to_str(++g_MAXBOXES, szValue, charsmax(szValue))
	nvault_set(g_vault, szString, szValue);

}

bool:check_hungergames_spawn(const Float:fOrigin[3], id=0)
{
	static const Float:AngleMulScalar = 11.25; // ( 360.0 / 32 )
	new tr2 = create_tr2(), Float:fOrigin2[3], Float:fAngle[3], Float:fVector[3], bool:bValidLocation=true;
	
	for(new i, red, green, Float:fEnd[3]; i < 32; i++)
	{
		angle_vector(fAngle, ANGLEVECTOR_RIGHT, fVector);
		xs_vec_mul_scalar(fVector, ORIGIN_RADIUS_SPAWNS + 1.0, fVector);
		xs_vec_add(fOrigin, fVector, fOrigin2);
		
		engfunc(EngFunc_TraceHull, fOrigin, fOrigin2, IGNORE_MONSTERS, HULL_HUMAN, id, tr2);
		get_tr2(tr2, TR_vecEndPos, fEnd);
		
		xs_vec_copy(fOrigin2, fVector);
		fVector[2] -= 9999.0;
		engfunc(EngFunc_TraceHull, fOrigin2, fVector, IGNORE_MONSTERS, HULL_HUMAN, id, tr2);
		get_tr2(tr2, TR_vecEndPos, fVector);

		green = 255; red = 0;
		
		if(!check_spawn_valid(fOrigin2,PLAYER_SIZE,id)  ||
			!xs_vec_equal(fOrigin2, fEnd) ||
			object_stuck(fOrigin2, PLAYER_MAXS, PLAYER_MINS) ||
			((fVector[2] - PLAYER_MINS[2]) <= fOrigin2[2]) )
		{
			bValidLocation = false;
			red = 255;
			green = 0;

			if( !id ) break;
		}
		
		if( id > 0 )
		{
			message_begin(MSG_ONE_UNRELIABLE, SVC_TEMPENTITY, _, id);
			write_byte(TE_BEAMPOINTS);
			engfunc(EngFunc_WriteCoord, fOrigin[0]);
			engfunc(EngFunc_WriteCoord, fOrigin[1]);
			engfunc(EngFunc_WriteCoord, fOrigin[2]);
			engfunc(EngFunc_WriteCoord, fEnd[0]);
			engfunc(EngFunc_WriteCoord, fEnd[1]);
			engfunc(EngFunc_WriteCoord, fEnd[2]);
			write_short(laser_spr);
			write_byte(0);
			write_byte(10);
			write_byte(40);
			write_byte(20); 
			write_byte(0);
			write_byte(red);
			write_byte(green);
			write_byte(0);
			write_byte(250)
			write_byte(1);
			message_end();
		}
		
		fAngle[1] += AngleMulScalar;
	}
	
	free_tr2(tr2);
	return bValidLocation;
}

save_origin_spawn(Float:fOrigin[3])
{
	new szValue[128];
	formatex(szValue, charsmax(szValue), "^"%.10f^" ^"%.10f^" ^"%.10f^"",
						fOrigin[0], fOrigin[1], fOrigin[2]);
	
	Origin_Spawn = fOrigin;
	hg_available = true;
	
	nvault_set(g_vault, MAP_NAME, szValue);
}

check_spawn_valid(Float:fOrigin[3], const Float:SIZE[6], const ignore_ent = 0)
{
	static ent = 0, Float:fMaxs[2][3], Float:fMins[2][3], Float:fDamage;

	fMaxs[0][0] = fOrigin[0] + SIZE[3];
	fMaxs[0][1] = fOrigin[1] + SIZE[4];
	fMaxs[0][2] = fOrigin[2] + SIZE[5];
	fMins[0][0] = fOrigin[0] + SIZE[0];
	fMins[0][1] = fOrigin[1] + SIZE[1];
	fMins[0][2] = fOrigin[2] + SIZE[2];

	while( (ent = find_ent_by_class(ent, "func_water")) )
	{
		pev(ent, pev_dmg, fDamage);
		if(fDamage <= 0.0) continue;

		pev(ent, pev_absmax, fMaxs[1]);
		pev(ent, pev_absmin, fMins[1]);

		if ( check_collision(fMaxs[0], fMins[0], fMaxs[1], fMins[1]) ) {
			return false;
		}

	}

	while( (ent = find_ent_by_class(ent, "trigger_hurt")) )
	{
		pev(ent, pev_dmg, fDamage);
		if(fDamage < 0.0) continue;

		pev(ent, pev_absmax, fMaxs[1]);
		pev(ent, pev_absmin, fMins[1]);

		if ( check_collision(fMaxs[0], fMins[0], fMaxs[1], fMins[1]) ) {
			return false;
		}

	}

	while( (ent = find_ent_by_class(ent, "trigger_push")) )
	{
		pev(ent, pev_absmax, fMaxs[1]);
		pev(ent, pev_absmin, fMins[1]);

		if ( check_collision(fMaxs[0], fMins[0], fMaxs[1], fMins[1]) ) {
			return false;
		}

	}

	while( (ent = find_ent_by_class(ent, "trigger_teleport")) )
	{
		pev(ent, pev_absmax, fMaxs[1]);
		pev(ent, pev_absmin, fMins[1]);

		if ( check_collision(fMaxs[0], fMins[0], fMaxs[1], fMins[1]) ) {
			return false;
		}

	}

	new OLD_SOLID, bValid;
	if( ignore_ent )
	{
		OLD_SOLID = pev(ignore_ent, pev_solid);
		set_pev(ignore_ent, pev_solid, SOLID_NOT);
	}

	bValid = ValidSpotFound(fOrigin);
	if( ignore_ent ) set_pev(ignore_ent, pev_solid, OLD_SOLID);

	return bValid;
}

check_collision( Float:absmax1[3], Float:absmin1[3], Float:absmax2[3], Float:absmin2[3] ) {

	if( (absmin1[0] > absmax2[0]) ||
		(absmin1[1] > absmax2[1]) ||
		(absmin1[2] > absmax2[2]) ||
		(absmin2[0] > absmax1[0]) ||
		(absmin2[1] > absmax1[1]) ||
		(absmin2[2] > absmax1[2]) ) return false;

	return true;
}
