/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <jailbreak_core>
#include <nvault>
#include <hamsandwich>

#define PLUGIN "[JB] LR: Side Damage"
#define AUTHOR "Natsheh"

#define valid_player_index(%1) (1 <= %1 <= 32)

new g_iVault, g_iLR_GUARD, g_iLR_PRISONER, g_iCURRENT_DUEL, bSIDEDAMAGE_ENABLED;
new HamHook:HamTraceAttPre, HamHook:HamTakeDmgPre, HamHook:HamKilledPre;

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	DisableHamForward((HamTraceAttPre = RegisterHam(Ham_TraceAttack, "player", "fw_traceattack_player_pre")));
	DisableHamForward((HamTakeDmgPre = RegisterHam(Ham_TakeDamage, "player", "fw_takedamage_player_pre")));
	DisableHamForward((HamKilledPre = RegisterHam(Ham_Killed, "player", "fw_killed_player_pre")));
	
	register_clcmd("jb_lr_sidedamage_menu", "clcmd_sidedamage_menu");
}

public clcmd_sidedamage_menu(id, level, cid)
{
	if(!cmd_access(id, level, cid, 1))
		return 1;
	
	new menu = menu_create("[LR] Side-Damage menu^n[En/Dis]able other players implementing damage on the duelers!", "mhandler_xxx");
	
	new iTotal_Duels = jb_get_duels_registered();
	
	for(new i, szDuelname[32], szText[96], iTimestamp, bool:bSideDamageEnabled; i < iTotal_Duels; i++)
	{
		jb_get_duel_name(i, szDuelname, charsmax(szDuelname));
		bSideDamageEnabled = nvault_lookup(g_iVault, szDuelname, "", 0, iTimestamp) > 0 ? true:false;
		formatex(szText, charsmax(szText), "\r%s   %s%s", szDuelname, bSideDamageEnabled ? "\y":"\w", bSideDamageEnabled ? "ON":"OFF")
		menu_additem(menu, szText);
	}
	
	if(!menu_items(menu))
	{
		menu_destroy(menu);
		return 1;
	}
	
	menu_display(id, menu);
	return 1;
}

public mhandler_xxx(id, menu, item)
{
	menu_destroy(menu);
	
	if(item == MENU_EXIT)
	{
		return 1;
	}
	
	new szDuelname[32], iTimestamp;
	jb_get_duel_name(item, szDuelname, charsmax(szDuelname));
	if(!nvault_lookup(g_iVault, szDuelname, "", 0, iTimestamp))
	{
		nvault_set(g_iVault, szDuelname, "1");
	}
	else
	{
		nvault_remove(g_iVault, szDuelname);
	}
	return 1;
}

public plugin_cfg()
{
	g_iVault = nvault_open("jb_lr_sidedamage");
	
	if(g_iVault == INVALID_HANDLE) set_fail_state("error opening nvault!");
}

public plugin_end()
{
	nvault_close(g_iVault);
}

public fw_traceattack_player_pre(victim, attacker, Float:fDamage, Float:fDirection[3], tracehandle, dmgbits)
{
	if(victim == attacker || !valid_player_index(attacker) || bSIDEDAMAGE_ENABLED) return HAM_IGNORED;
	
	if(g_iCURRENT_DUEL > DUEL_NONE)
	{
		if(victim == g_iLR_GUARD && attacker != g_iLR_PRISONER ||
			victim == g_iLR_PRISONER && attacker != g_iLR_GUARD)
		{
			SetHamParamFloat(3, 0.0);
			return HAM_SUPERCEDE;
		}
	}
	
	return HAM_IGNORED;
}

public jb_lr_duel_started(prisoner, guard, duelid)
{
	g_iLR_GUARD = guard;
	g_iLR_PRISONER = prisoner;
	g_iCURRENT_DUEL = duelid;
	
	new szDuelname[32], iTimestamp;
	jb_get_duel_name(duelid, szDuelname, charsmax(szDuelname));
	if(nvault_lookup(g_iVault, szDuelname, "", 0, iTimestamp) > 0)
	{
		EnableHamForward(HamTraceAttPre);
		EnableHamForward(HamTakeDmgPre);
		EnableHamForward(HamKilledPre);
		bSIDEDAMAGE_ENABLED = true;
	}
}

public jb_lr_duel_ended(prisoner, guard, duelid)
{
	g_iLR_GUARD = 0;
	g_iLR_PRISONER = 0;
	g_iCURRENT_DUEL = DAY_NONE;
	
	if(bSIDEDAMAGE_ENABLED)
	{
		bSIDEDAMAGE_ENABLED = false;
		DisableHamForward(HamTraceAttPre);
		DisableHamForward(HamTakeDmgPre);
		DisableHamForward(HamKilledPre);
	}
}

public fw_takedamage_player_pre(victim, inflictor, attacker, Float:fDamage, dmgbits)
{
	if(victim == attacker || !valid_player_index(attacker)) return HAM_IGNORED;
	
	if(g_iCURRENT_DUEL > DUEL_NONE)
	{
		if(victim == g_iLR_GUARD && attacker != g_iLR_PRISONER ||
			victim == g_iLR_PRISONER && attacker != g_iLR_GUARD)
		{
			SetHamParamFloat(4, 0.0);
			return HAM_SUPERCEDE;
		}
	}
	
	return HAM_IGNORED;
}

public fw_killed_player_pre(victim, killer, gib)
{
	if(victim == killer || !valid_player_index(killer)) return HAM_IGNORED;
	
	if(g_iCURRENT_DUEL > DUEL_NONE)
	{
		if(victim == g_iLR_GUARD && killer != g_iLR_PRISONER ||
			victim == g_iLR_PRISONER && killer != g_iLR_GUARD)
		{
			SetHamParamEntity(1, 0);
			return HAM_SUPERCEDE;
		}
	}
	
	return HAM_IGNORED;
}
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil\\ fcharset0 Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang1033\\ f0\\ fs16 \n\\ par }
*/
