/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <Hamsandwich>
#include <fakemeta>
#include <nvault>

#define PLUGIN "Mystery Box"
#define VERSION "1.2"
#define AUTHOR "Natsheh"

#define CBASE_ENTITY_CLASSNAME "info_target"
#define MYSTRYBOX_BONE_ITEM 2

#if !defined EOS
#define EOS 0
#endif

#define set_flag(%1,%2) (%1 |= (1<<(%2-1)))
#define remove_flag(%1,%2) (%1 &= ~(1<<(%2-1)))
#define check_flag(%1,%2) (%1 & (1<<(%2-1)))

#define TASK_LOOP_SPAWN 354356
#define ID_MYSTERYBOX 36952

#define PEV_MYSTERYBOX_IDENTIFIER pev_euser2
#define PEV_MYSTERYBOX_DISTRICT pev_iuser4
#define PEV_MYSTERYBOX_PROCESS pev_iuser3
#define PEV_MYSTERYBOX_ITEM_ENTITY pev_euser4
#define PEV_MYSTERYBOX_ITEM_ID pev_iuser2
#define PEV_MYSTERYBOX_CHOSEN_ITEM pev_iuser1
#define PEV_MYSTERYBOX_FALL_TYPE pev_iuser2
#define PEV_MYSTERYBOX_USER pev_iuser1
#define PEV_MYSTERYBOX_TIME_OPEN pev_fuser4
#define PEV_MYSTERYBOX_TIME_CLOSE pev_fuser1
#define PEV_MYSTERYBOX_TIME_CHOSEN_ITEM pev_fuser3
#define PEV_MYSTERYBOX_T_ABANDONED_ITEM pev_fuser2

enum any:MYSTERYBOX_PROCESS (+=1)
{
	MYSTERYBOX_PROCESS_DEPLOYMENT,
	MYSTERYBOX_PROCESS_SEEK_USER,
	MYSTERYBOX_PROCESS_BOX_OPENING,
	MYSTERYBOX_PROCESS_CHOOSING_ITEM,
	MYSTERYBOX_PROCESS_SELECT_ITEM,
	MYSTERYBOX_PROCESS_TEDDYBEAR_FAREWELL,
	MYSTERYBOX_PROCESS_ITEM_RESET,
	MYSTERYBOX_PROCESS_VANISHING_25,
	MYSTERYBOX_PROCESS_VANISHING_50,
	MYSTERYBOX_PROCESS_VANISHING_85,
	MYSTERYBOX_PROCESS_DEATH
}

enum any:MYSTERYBOX_SPAWNER_PLACEMENT(+=1)
{
	MYSTERYBOX_SPAWNER_UNLOCATED = - 2,
	MYSTERYBOX_SPAWNER_STUCK,
	MYSTERYBOX_SPAWNER_REMOVED,
	MYSTERYBOX_SPAWNER_OKAY
}

#define TEDDYBEAR_ITEM -999

/* Mysterybox flags *
* a = spawn a mybox on round start,
* b = spawn a mybox every x second,
* c = remove all the myboxes on round end,
* d = spawn a mybox if a mybox has teddybear called AKA vanished.
*/

new const Float:teddybear_angles[3] =  {0.0,0.0,0.0};

new const file_name[] = "mysterybox_items.ini";

enum any:MODEL_DATA
{
	MODEL_NAME[MAX_RESOURCE_PATH_LENGTH],
	MODEL_BODY,
	MODEL_SKIN
}

new const mystery_box_models[][MODEL_DATA] = {
	{ "models/mysterybox/mysterybox_obj.mdl", 000, 000 }
};

new const default_item_models[][MODEL_DATA] = {
	{ "models/mysterybox/mysterybox_obj.mdl", 002, 000 }
};

new const parachute_models[][MODEL_DATA] = {
	{ "models/mysterybox/parachute.mdl", 000, 000 }
};

new const default_teddybear_models[][MODEL_DATA] = {
	{ "models/mysterybox/mysterybox_obj.mdl", 001, 000 }
};

new const g_beam_sprites[][] = {
	"sprites/zbeam2.spr"
};

new const mysterybox_classname[] = "mysterybox";
new const mysterybox_classname_decoy[] = "mysterybox_decoy";

new const default_item_command[] = "say There's nothing in the box!"
new const default_item_flag = 0;

new const Float:default_item_chances = 50.0;
new const Float:default_item_scale = 100.0;

new const default_teddybear_sound[] = "mysterybox/teddybear.wav";
new const default_samanthas_laugh_sound[] = "mysterybox/samanthas_laughter.wav";
new const default_box_opening_sound[] = "mysterybox/box_opening.wav";

new const Float:mysterybox_maxs[3] = { 14.0 ,  40.0,  80.0 };
new const Float:mysterybox_mins[3] = { -14.0, -40.0,  -2.0 };

enum any:FallTypes (+=1)
{
	FALL_TYPE_NONE = 0,
	FALL_TYPE_PARACHUTE,
	FALL_TYPE_DROP,
	FALL_TYPE_BOUNCE
}

new const szFallTypes[][] = {
	"No Fall",
	"Parachute Fall",
	"Drop Fall",
	"Bouncing Fall"
}

enum (+=1)
{
	KEY_COMMAND_TYPE = 0, 	KEY_COMMAND, 		KEY_SOUND, 	KEY_MODEL, 		KEY_MODEL_BODY,
	KEY_MODEL_SKIN, 		KEY_MODEL_ANGLES, 	KEY_FLAG, 	KEY_CHANCES, 	KEY_SCALE
};

new const FILE_KEYS[][] = {
	"COMMAND_TYPE",
	"COMMAND",
	"SOUND",
	"MODEL",
	"BODY",
	"SKIN",
	"MODEL_ANGLES",
	"FLAG",
	"CHANCES",
	"SCALE"
}

enum _:ITEM_DATA
{
	ITEM_NAME[32],
	ITEM_COMMAND[160],
	ITEM_MODEL[64],
	ITEM_MODEL_BODY,
	ITEM_MODEL_SKIN,
	ITEM_SOUND[64],
	Float:ITEM_MODEL_ANGLES[3],
	ITEM_COMMAND_TYPE,
	ITEM_FLAG,
	ITEM_CHANCES,
	Float:ITEM_SCALE
}

new MAP_NAME[32];
new NVAULT_LOC, Trie:Trie_locations, Trie:Trie_locations_available, g_Total_loc;
new Array:array_items_data, Float:user_angle[33], FallTypes:g_user_mbox_falltype[33];
new user_editor_mode;
new g_sprites[sizeof g_beam_sprites], g_total_items;
new MYBOX_FLAGS[5], round_ended, PLUGIN_ENABLED;
new g_pcvar_mybox_enable, g_pcvar_mybox_flags,
g_pcvar_mybox_spawn_onstart, g_pcvar_mybox_loop_spawn_time,
g_FW_FM_ADDTOFULLPACK_POST, g_fw_mybox_open_attempt;

public plugin_precache()
{
	for(new i; i < sizeof mystery_box_models; i++)
	{
		precache_model(mystery_box_models[i][MODEL_NAME]);
	}
	
	for(new i; i < sizeof default_item_models; i++)
	{
		precache_model(default_item_models[i][MODEL_NAME]);
	}

	for(new i; i < sizeof default_teddybear_models; i++)
	{
		precache_model(default_teddybear_models[i][MODEL_NAME]);
	}

	for(new i; i < sizeof parachute_models; i++)
	{
		precache_model(parachute_models[i][MODEL_NAME]);
	}

	for(new i; i < sizeof g_beam_sprites; i++)
	{
		g_sprites[i] = precache_model(g_beam_sprites[i]);
	}

	precache_sound(default_box_opening_sound);
	precache_sound(default_teddybear_sound);
	precache_sound(default_samanthas_laugh_sound);
	
	new sFile[64], iLen = get_configsdir(sFile, charsmax(sFile));
	formatex(sFile[ iLen ], charsmax(sFile) - iLen, "/%s", file_name);
	
	new fp = fopen(sFile, "rt");
	
	if(!fp)
	{
		formatex(sFile, charsmax(sFile), "%s is not exists!", file_name);
		set_fail_state(sFile);
		return;
	}

	array_items_data = ArrayCreate(ITEM_DATA, 1);
	
	new sBuffer[128], szKey[32], xArray[ITEM_DATA], count, j, sizeofkeys = sizeof FILE_KEYS,
	registered;
	
	while(!feof(fp))
	{
		fgets(fp, sBuffer, charsmax(sBuffer));
		trim(sBuffer);
		
		switch( sBuffer[0] )
		{
			case EOS, ';', '/', '#': continue;
			case '[':
			{
				if((0 < count < sizeofkeys) && g_total_items > 0)
				{
					for(j = 0; j < sizeofkeys; j++)
					{
						if(!(registered & (1<<j)))
						{
							registered |= (1<<j);
							count++;
							
							switch( j )
							{
								case KEY_COMMAND_TYPE: xArray[ITEM_COMMAND_TYPE] = 0;
								case KEY_COMMAND: copy(xArray[ITEM_COMMAND], charsmax(xArray[ITEM_COMMAND]), default_item_command); // COMMAND
								case KEY_FLAG: xArray[ITEM_FLAG] = default_item_flag; // FLAG
								case KEY_MODEL_BODY: xArray[ITEM_MODEL_BODY] = default_item_models[random(sizeof default_item_models)][MODEL_BODY]; // MODEL BODY
								case KEY_MODEL_SKIN: xArray[ITEM_MODEL_SKIN] = default_item_models[random(sizeof default_item_models)][MODEL_SKIN]; // MODEL SKIN
								case KEY_CHANCES: xArray[ITEM_CHANCES] = floatround(default_item_chances); // CHANCES
								case KEY_MODEL: copy(xArray[ITEM_MODEL], charsmax(xArray[ITEM_MODEL]), default_item_models[random(sizeof default_item_models)][MODEL_NAME]); // MODEL
								case KEY_MODEL_ANGLES: xArray[ITEM_MODEL_ANGLES] = _:{0.0, 0.0, 0.0}; // MODEL ANGLES
								case KEY_SCALE: xArray[ITEM_SCALE] = _:default_item_scale; // SCALE
							}
						}
					}
					
					ArraySetArray(array_items_data, (g_total_items-1), xArray);
				}
				
				count = 0; registered = 0;
				copyc(xArray[ITEM_NAME], charsmax(xArray[ITEM_NAME]), sBuffer[1], ']')
				ArrayPushArray(array_items_data, xArray)
				g_total_items ++;
			}
			default:
			{
				if(count >= sizeofkeys || g_total_items <= 0) continue;
				
				strtok(sBuffer, szKey, charsmax(szKey), sBuffer, charsmax(sBuffer), '=')
				trim(szKey)
				trim(sBuffer)
				remove_quotes(szKey);
				remove_quotes(sBuffer);
				
				for(j = 0; j < sizeofkeys; j++)
				{
					if(equali(FILE_KEYS[j], szKey) && !(registered & (1<<j)))
					{
						registered |= (1<<j);
						count++;
						
						ArrayGetArray(array_items_data, (g_total_items-1), xArray)
						
						switch( j )
						{
							case KEY_COMMAND_TYPE: xArray[ITEM_COMMAND_TYPE] = str_to_num(sBuffer);
							case KEY_COMMAND: copy(xArray[ITEM_COMMAND], charsmax(xArray[ITEM_COMMAND]), sBuffer); // COMMAND
							case KEY_FLAG: xArray[ITEM_FLAG] = str_to_num(sBuffer); // FLAG
							case KEY_MODEL_BODY: xArray[ITEM_MODEL_BODY] = str_to_num(sBuffer); // MODEL BODY
							case KEY_MODEL_SKIN: xArray[ITEM_MODEL_SKIN] = str_to_num(sBuffer); // MODEL SKIN
							case KEY_CHANCES: xArray[ITEM_CHANCES] = str_to_num(sBuffer); // CHANCES
							case KEY_SCALE: xArray[ITEM_SCALE] = _:floatstr(sBuffer); // SCALE
							case KEY_MODEL:
							{
								formatex(xArray[ITEM_MODEL], charsmax(xArray[ITEM_MODEL]), sBuffer) // MODEL
								precache_model(sBuffer)
							}
							case KEY_MODEL_ANGLES:
							{
								for(new x, szfValue[5]; x < 3; x++)
								{
									strtok(sBuffer, szfValue, charsmax(szfValue), sBuffer, charsmax(sBuffer), ' ')
									xArray[ITEM_MODEL_ANGLES][x] = _:floatstr(szfValue);
								}
							}
							case KEY_SOUND:
							{
								formatex(xArray[ITEM_SOUND], charsmax(xArray[ITEM_SOUND]), sBuffer) // MODEL
								precache_sound(sBuffer)
							}
						}
						
						ArraySetArray(array_items_data, (g_total_items-1), xArray);
						
						j = sizeofkeys;
					}
				}
			}
		}
	}
	fclose(fp);
}

public plugin_end()
{
	ArrayDestroy(array_items_data);
	
	TrieDestroy(Trie_locations);
	TrieDestroy(Trie_locations_available);
	
	nvault_close(NVAULT_LOC);

	DestroyForward(g_fw_mybox_open_attempt);
}

public concmd_spawn(id, level, cid)
{
	if(!PLUGIN_ENABLED)
	{
		console_print(id, "The %s plugin is currently disabled!", PLUGIN);
		return 1;
	}
	if(!cmd_access(id, level, cid, 1)) return 1;
	if(spawning_mybox_process())
	{
		client_print(id, print_chat, "spawning a mysterybox in a random location!");
	}
	else
	{
		client_print(id, print_chat, "couldnt spawn a mysterybox, there's no available location!");
	}
	return 1;
}

new HamHook:HamThink

public plugin_pause()
{
	if(g_pcvar_mybox_enable > 0)
	{
		set_pcvar_num(g_pcvar_mybox_enable, 0)
		PLUGIN_ENABLED = 0;
	}
	round_ended = false;
	round_end()
	DisableHamForward(HamThink)
}

public plugin_unpause()
{
	if(g_pcvar_mybox_enable > 0)
	{
		set_pcvar_num(g_pcvar_mybox_enable, 1)
		PLUGIN_ENABLED = 1;
	}
	EnableHamForward(HamThink)
}

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR);

	g_fw_mybox_open_attempt = CreateMultiForward("mysterybox_open_attempt", ET_CONTINUE, FP_CELL, FP_CELL);
	
	register_clcmd("mysteryboxeditor", "clcmd_mysterybox", ADMIN_IMMUNITY, "Opens mybox editor menu!");
	register_clcmd("mysterybox_editor_menu", "clcmd_mysterybox", ADMIN_IMMUNITY, "Opens, mybox editor menu!");
	register_concmd("mysteryboxspawn", "concmd_spawn", ADMIN_IMMUNITY, "spawns a mysterybox");
	register_clcmd("mysterybox_call_teddybear", "clcmd_callteddybear", ADMIN_IMMUNITY, "aim on the mybox to spawn a teddy!");
	
	register_cvar("Mysterybox_By_Natsheh", "v1.0", (FCVAR_SERVER|FCVAR_PROTECTED|FCVAR_SPONLY));
	g_pcvar_mybox_enable = register_cvar("mybox_enabled", "1");
	g_pcvar_mybox_flags = register_cvar("mybox_flags", "acd");
	g_pcvar_mybox_spawn_onstart = register_cvar("mybox_quantity_spawn_onroundstart", "1");
	g_pcvar_mybox_loop_spawn_time = register_cvar("mybox_loop_spawn_time", "240");
	
	HamThink = RegisterHam(Ham_Think, CBASE_ENTITY_CLASSNAME, "fw_Think_post", 1);
	
	register_event("HLTV", "round_start", "a", "1=0", "2=0");
	register_event("TextMsg", "round_end", "a", "2&#Game_C", "2&#Game_w");
	register_logevent("round_end", 2, "1=Round_End");
	
	NVAULT_LOC = nvault_open("mysterybox_locations");
	if(NVAULT_LOC == INVALID_HANDLE) set_fail_state("Error opening nVault!");
	
	Trie_locations = TrieCreate();
	Trie_locations_available = TrieCreate();
	
	new szValue[48], szKey[64], timestamp;
	get_mapname(MAP_NAME, charsmax(MAP_NAME));
	formatex(szKey, charsmax(szKey), "%s_TOTAL", MAP_NAME);
	if(nvault_lookup(NVAULT_LOC, szKey, szValue, charsmax(szValue), timestamp))
	{
		new loops = str_to_num(szValue), Float:fValues[5], fvaluesloops = sizeof fValues;
		
		g_Total_loc = loops;
		
		for(new i,j, szfValue[10]; i < loops; i++)
		{
			formatex(szKey, charsmax(szKey), "%s_LOCATION_#%d", MAP_NAME, i)
			if(nvault_lookup(NVAULT_LOC, szKey, szValue, charsmax(szValue), timestamp))
			{
				for(j = 0; j < fvaluesloops; j++)
				{
					strtok(szValue, szfValue, charsmax(szfValue), szValue, charsmax(szValue), ' ')
					fValues[j] = floatstr(szfValue);
				}
				
				TrieSetArray(Trie_locations, szKey, fValues, sizeof fValues)
			}
		}
	}
}

public plugin_cfg()
{
	PLUGIN_ENABLED = get_pcvar_num(g_pcvar_mybox_enable);
}

public round_start()
{
	round_ended = false;
	
	PLUGIN_ENABLED = get_pcvar_num(g_pcvar_mybox_enable);
	if(!PLUGIN_ENABLED) return;
	
	get_pcvar_string(g_pcvar_mybox_flags, MYBOX_FLAGS, charsmax(MYBOX_FLAGS));
	
	if(contain(MYBOX_FLAGS, "a") > -1)
	{
		for(new i, maxloop = abs(get_pcvar_num(g_pcvar_mybox_spawn_onstart)); i < maxloop;i++)
		{
			set_task(i * 0.25, "spawning_mybox_process");
		}
	}
	
	if(contain(MYBOX_FLAGS, "b") > -1)
	{
		remove_task(TASK_LOOP_SPAWN);
		set_task(get_pcvar_float(g_pcvar_mybox_loop_spawn_time), "spawning_mybox_process", TASK_LOOP_SPAWN, _, _, "b")
	}
}

public round_end()
{
	if(round_ended) return;
	
	round_ended = true;
	remove_task(TASK_LOOP_SPAWN);
	
	if(contain(MYBOX_FLAGS, "c") > -1 || !PLUGIN_ENABLED)
	{
		remove_all_myboxes();
	}
}

remove_all_myboxes()
{
	new ent = -1, env, sBuff[64];
	while( ((ent = engfunc(EngFunc_FindEntityByString, ent, "classname", mysterybox_classname)) > 0) )
	{
		formatex(sBuff, charsmax(sBuff), "%s_LOCATION_#%d", MAP_NAME, pev(ent, PEV_MYSTERYBOX_DISTRICT));
		TrieDeleteKey(Trie_locations_available, sBuff);
		
		env = pev(ent, PEV_MYSTERYBOX_ITEM_ENTITY);
		remove_entity_safely(env);
		
		env = pev(ent, pev_impulse);
		remove_entity_safely(env);
		remove_entity_safely(ent);
	}
}

public clcmd_callteddybear(id, level, cid)
{
	if(!PLUGIN_ENABLED)
	{
		client_print(id, print_chat, "The plugin is currently disabled!")
		return 1;
	}

	if(!cmd_access(id, level, cid, 0))
	{
		return 1;
	}
	
	new target, body;
	get_user_aiming(id, target, body)
	
	if(pev_valid(target))
	{
		new sClassname[20];
		pev(target, pev_classname, sClassname, charsmax(sClassname));
		
		if(!equal(sClassname, mysterybox_classname))
		{
			client_print(id, print_chat, "Aim on the mysterybox to spawn a teddybear!")
			return 1;
		}
		
		new env = pev(target, PEV_MYSTERYBOX_ITEM_ENTITY);
		
		if(!pev_valid(env) || pev(env, PEV_MYSTERYBOX_CHOSEN_ITEM) == TEDDYBEAR_ITEM)
		{
			return 1;
		}

		set_pev(env, PEV_MYSTERYBOX_CHOSEN_ITEM, TEDDYBEAR_ITEM);
		mysterybox_chosen_item(target);
		
		client_print(id, print_chat, "The Teddybear has been successfully called!");
	}
	else
	{
		client_print(id, print_chat, "Mysterybox is not found!")
	}
	return 1;
}

public client_putinserver(id)
{
	user_angle[id] = 180.0;
}

#if AMXX_VERSION_NUM > 182
public client_disconnected(id)
#else
public client_disconnect(id)
#endif
{
	if(user_editor_mode)
	{
		remove_flag(user_editor_mode,id);

		if(!user_editor_mode)
		{
			mysterybox_remove_decoy_spawners();
		}
	}
}

public clcmd_mysterybox(id, level, cid)
{
	if(!PLUGIN_ENABLED)
	{
		console_print(id, "The plugin is currently disabled!")
		return 1;
	}
	if(!cmd_access(id, level, cid, 1)) return 1;
	
	mysterybox_editor_menu(id)
	return 1;
}

public mysterybox_editor_menu(const id)
{
	if(!PLUGIN_ENABLED)
	{
		console_print(id, "The plugin is currently disabled!")
		return;
	}
	new EDITOR_MENU = menu_create("Mystery Box^nEditor!!!","mysterybox_m_handler")
	
	new sText[64], paccess = check_flag(user_editor_mode,id) ? 0:(1<<26);
	formatex(sText, charsmax(sText), "Remove all the Mysterybox Spawners!^n")
	menu_additem(EDITOR_MENU, sText,"", paccess);
	
	formatex(sText, charsmax(sText), "Create a Spawner! ^n Spawns at the position your aiming at!")
	menu_additem(EDITOR_MENU, sText,"", paccess);
	
	formatex(sText, charsmax(sText), "Fall type: %s", szFallTypes[any:g_user_mbox_falltype[id]]);
	menu_additem(EDITOR_MENU, sText,"", paccess)
	
	formatex(sText, charsmax(sText), "Angle : %.2f^n", user_angle[id]);
	menu_additem(EDITOR_MENU, sText,"", paccess);
	
	formatex(sText, charsmax(sText), "Remove the Spawner! ^n Aim on the Spawner!^n")
	menu_additem(EDITOR_MENU, sText,"", paccess);
	
	formatex(sText, charsmax(sText), "\yEditor mode : %s", paccess ? "\wOff":"\rOn");
	menu_additem(EDITOR_MENU, sText);
	
	formatex(sText, charsmax(sText), "^nTotal Locations : %d", g_Total_loc);
	menu_addtext(EDITOR_MENU, sText,0);
	
	formatex(sText, charsmax(sText), "Total Items : %d", g_total_items);
	menu_addtext(EDITOR_MENU, sText,0);
	
	menu_display(id, EDITOR_MENU);
}

public mysterybox_m_handler(id, menu, item)
{
	if(!PLUGIN_ENABLED)
	{
		console_print(id, "The %s plugin is currently disabled!", PLUGIN);
		return PLUGIN_HANDLED;
	}

	if(item == MENU_EXIT)
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	menu_destroy(menu)
	
	switch( item )
	{
		case 0:
		{
			new szKey[64];
			g_Total_loc = 0;
			formatex(szKey, charsmax(szKey), "%s_TOTAL", MAP_NAME);
			nvault_set(NVAULT_LOC, szKey, "0");
			
			client_print(id, print_chat, "All the Mysterybox Spawner Successfully removed!");
			
			remove_all_myboxes();
			mysterybox_remove_decoy_spawners();
		}
		case 1:
		{
			new iOrigin[3], Float:fvAngle[3], Float:fOrigin[3];
			get_user_origin(id, iOrigin, Origin_AimEndEyes);
			IVecFVec(iOrigin, fOrigin);
			pev(id, pev_v_angle, fvAngle);
			fvAngle[1] += user_angle[id];
			if( fvAngle[1] > 360.0 ) fvAngle[1] -= 360.0;

			switch( place_mysterybox_spawner(fOrigin, fvAngle, g_user_mbox_falltype[id]) )
			{
				case MYSTERYBOX_SPAWNER_STUCK:
				{
					client_print(id, print_chat, "You cannot place the mysterybox spawner there!");
				}
				case MYSTERYBOX_SPAWNER_OKAY:
				{
					spawn_mysterybox_decoy( g_Total_loc - 1 );
					client_print(id, print_chat, "Mysterybox Spawner Successfully been created!");
				}
			}
		}
		case 2:
		{
			g_user_mbox_falltype[id] ++;
			
			if(any:g_user_mbox_falltype[id] >= sizeof szFallTypes) g_user_mbox_falltype[id] = FALL_TYPE_NONE;
		}
		case 3:
		{
			user_angle[id] += 30.0;
			
			if(user_angle[id] > 360.0) user_angle[id] = 0.0;
		}
		case 4:
		{
			new iOrigin[3], Float:fOrigin[3], ent = -1;

			while( ((ent = engfunc(EngFunc_FindEntityByString, ent, "classname", mysterybox_classname_decoy)) > 0) )
			{
				set_pev(ent, pev_solid, SOLID_BBOX);
				engfunc(EngFunc_SetSize, ent, mysterybox_mins, mysterybox_maxs);
			}

			get_user_origin(id, iOrigin, Origin_AimEndEyes);
			IVecFVec(iOrigin, fOrigin);

			while( ((ent = engfunc(EngFunc_FindEntityByString, ent, "classname", mysterybox_classname_decoy)) > 0) )
			{
				set_pev(ent, pev_solid, SOLID_NOT);
			}

			switch( destroy_mysterybox_spawner(fOrigin) )
			{
				case MYSTERYBOX_SPAWNER_UNLOCATED:
				{
					client_print(id, print_chat, "Unable to find a mystrybox Spawner!");
				}
				case MYSTERYBOX_SPAWNER_REMOVED:
				{
					client_print(id, print_chat, "Mysterybox Spawner Successfully been deleted!");
				}
			}
		}
		case 5:
		{
			if(!user_editor_mode) // enabling editor mode
			{
				set_flag(user_editor_mode,id);
				show_mysterybox_spawners();
			}
			else
			{
				check_flag(user_editor_mode,id) ? remove_flag(user_editor_mode,id) : set_flag(user_editor_mode,id);
			}
			
			client_print(id, print_chat, "You have %sabled mysterybox editor mode!", check_flag(user_editor_mode,id) ? "en":"dis");
			
			if(!user_editor_mode) // disabling editor mode
			{
				mysterybox_remove_decoy_spawners();
			}
		}
	}
	mysterybox_editor_menu(id)
	return PLUGIN_HANDLED;
}

MYSTERYBOX_SPAWNER_PLACEMENT:place_mysterybox_spawner(const Float:fOrigin[3], const Float:fvAngle[3], const FallTypes:iFallType = FALL_TYPE_NONE)
{
	static Float:fValues[5], szKey[64], szValue[48];
	fValues[0] = fOrigin[0];
	fValues[1] = fOrigin[1];
	fValues[2] = fOrigin[2];
	fValues[3] = fvAngle[1];
	fValues[4] = float(any:iFallType);

	if(is_object_stuck(fOrigin, mysterybox_maxs, mysterybox_mins) == true)
	{
		return MYSTERYBOX_SPAWNER_STUCK;
	}

	formatex(szKey, charsmax(szKey), "%s_LOCATION_#%d", MAP_NAME, g_Total_loc);
	formatex(szValue, charsmax(szValue), "%.2f %.2f %.2f %.2f %.2f", fValues[0], fValues[1], fValues[2], fValues[3], fValues[4]);
	nvault_set(NVAULT_LOC, szKey, szValue)
	TrieSetArray(Trie_locations, szKey, fValues, sizeof fValues)
	TrieDeleteKey(Trie_locations_available, szKey)

	g_Total_loc ++;

	formatex(szKey, charsmax(szKey), "%s_TOTAL", MAP_NAME);
	num_to_str(g_Total_loc, szValue, charsmax(szValue));
	nvault_set(NVAULT_LOC, szKey, szValue);

	return MYSTERYBOX_SPAWNER_OKAY;
}

MYSTERYBOX_SPAWNER_PLACEMENT:destroy_mysterybox_spawner(const Float:fOrigin[3])
{
	new Float:fValues[5], szKey[64], selected = -1;

	for(new i, Float:distance = 50.0, Float:tempdistance, Float:fOrigin2[3]; i < g_Total_loc; i++)
	{
		formatex(szKey, charsmax(szKey), "%s_LOCATION_#%d", MAP_NAME, i);
		TrieGetArray(Trie_locations, szKey, fOrigin2, sizeof fOrigin2);

		if((tempdistance = get_distance_f(fOrigin, fOrigin2)) <= 50.0)
		{
			if(tempdistance < distance)
			{
				distance = tempdistance;
				selected = i;
			}
		}
	}

	if(selected == -1)
	{
		return MYSTERYBOX_SPAWNER_UNLOCATED;
	}

	new szValue[48], timestamp;

	g_Total_loc --;

	new ent;
	while( ((ent = engfunc(EngFunc_FindEntityByString, ent, "classname", mysterybox_classname_decoy)) > 0) )
	{
		if(pev(ent, PEV_MYSTERYBOX_DISTRICT) == selected) break; // saved district
	}

	if(ent > 0)
	{
		remove_entity_safely( ent );
		ent = 0;

		while( ((ent = engfunc(EngFunc_FindEntityByString, ent, "classname", mysterybox_classname_decoy)) > 0) )
		{
			if(pev(ent, PEV_MYSTERYBOX_DISTRICT) == g_Total_loc) break; // saved district
		}

		if(ent > 0)
		{
			// changing ent location
			set_pev(ent, PEV_MYSTERYBOX_DISTRICT, selected);
		}

		ent = 0;
	}

	while( ((ent = engfunc(EngFunc_FindEntityByString, ent, "classname", mysterybox_classname)) > 0) )
	{
		if(pev(ent, PEV_MYSTERYBOX_DISTRICT) == selected) break; // saved district
	}

	if(ent > 0)
	{
		new env = pev(ent, PEV_MYSTERYBOX_ITEM_ENTITY);
		remove_entity_safely(env);

		env = pev(ent, pev_impulse);
		remove_entity_safely(env);

		remove_entity_safely( ent );
		ent = 0;
	}

	while( ((ent = engfunc(EngFunc_FindEntityByString, ent, "classname", mysterybox_classname)) > 0) )
	{
		if(pev(ent, PEV_MYSTERYBOX_DISTRICT) == g_Total_loc) break; // saved district
	}

	if(ent > 0)
	{
		// changing ent location
		set_pev(ent, PEV_MYSTERYBOX_DISTRICT, selected);
	}


	formatex(szKey, charsmax(szKey), "%s_LOCATION_#%d", MAP_NAME, g_Total_loc);
	TrieGetArray(Trie_locations, szKey, fValues, sizeof fValues);
	nvault_lookup(NVAULT_LOC, szKey, szValue, charsmax(szValue), timestamp);
	nvault_remove(NVAULT_LOC, szKey);
	TrieDeleteKey(Trie_locations, szKey);
	timestamp = 0;
	if(TrieKeyExists(Trie_locations_available, szKey))
	{
		timestamp = 1;
		TrieDeleteKey(Trie_locations_available, szKey);
	}

	formatex(szKey, charsmax(szKey), "%s_LOCATION_#%d", MAP_NAME, selected);
	TrieSetArray(Trie_locations, szKey, fValues, sizeof fValues);
	if(timestamp == 1) TrieSetCell(Trie_locations_available, szKey, 1);
	nvault_set(NVAULT_LOC, szKey, szValue);

	formatex(szKey, charsmax(szKey), "%s_TOTAL", MAP_NAME);
	num_to_str(g_Total_loc, szValue, charsmax(szValue));
	nvault_set(NVAULT_LOC, szKey, szValue);

	return MYSTERYBOX_SPAWNER_REMOVED;
}

bool:is_object_stuck(const Float:vOrigin[3], const Float:fMaxs[3]={1.0,1.0,1.0}, const Float:fMins[3]={-1.0,-1.0,-1.0})
{
	new Float:fSizeMax[3]; fSizeMax = fMaxs;
	new Float:fSizeMin[3]; fSizeMin = fMins;
	
	new content;
	new Float:vPoint[3];
	
	//decrease the size values of the block
	fSizeMin[0] += 1.0;
	fSizeMax[0] -= 1.0;
	fSizeMin[1] += 1.0;
	fSizeMax[1] -= 1.0; 
	fSizeMin[2] += 1.0;
	fSizeMax[2] -= 1.0;
	
	//get the contents of the centre of all 6 faces of the block
	for (new i; i < 14; ++i)
	{
		//start by setting the point to the origin of the block (the middle)
		vPoint = vOrigin;
		
		//set the values depending on the loop number
		switch (i)
		{
			//corners
			case 0: { vPoint[0] += fSizeMax[0]; vPoint[1] += fSizeMax[1]; vPoint[2] += fSizeMax[2]; }
			case 1: { vPoint[0] += fSizeMin[0]; vPoint[1] += fSizeMax[1]; vPoint[2] += fSizeMax[2]; }
			case 2: { vPoint[0] += fSizeMax[0]; vPoint[1] += fSizeMin[1]; vPoint[2] += fSizeMax[2]; }
			case 3: { vPoint[0] += fSizeMin[0]; vPoint[1] += fSizeMin[1]; vPoint[2] += fSizeMax[2]; }
			case 4: { vPoint[0] += fSizeMax[0]; vPoint[1] += fSizeMax[1]; vPoint[2] += fSizeMin[2]; }
			case 5: { vPoint[0] += fSizeMin[0]; vPoint[1] += fSizeMax[1]; vPoint[2] += fSizeMin[2]; }
			case 6: { vPoint[0] += fSizeMax[0]; vPoint[1] += fSizeMin[1]; vPoint[2] += fSizeMin[2]; }
			case 7: { vPoint[0] += fSizeMin[0]; vPoint[1] += fSizeMin[1]; vPoint[2] += fSizeMin[2]; }
			
			//centre of faces
			case 8: { vPoint[0] += fSizeMax[0]; }
			case 9: { vPoint[0] += fSizeMin[0]; }
			case 10: { vPoint[1] += fSizeMax[1]; }
			case 11: { vPoint[1] += fSizeMin[1]; }
			case 12: { vPoint[2] += fSizeMax[2]; }
			case 13: { vPoint[2] += fSizeMin[2]; }
		}
			
		//get the contents of the point on the block
		content = engfunc(EngFunc_PointContents, vPoint)
		
		//if the point is out in the open
		if (content == CONTENTS_EMPTY || content == 0)
		{
			//block is not stuck
			return false;
		}
	}
	
	//block is stuck
	return true;
}  

public spawning_mybox_process()
{
	new Array:tempArray = ArrayCreate(1,1);
	get_available_mybox_locations(tempArray);
	new size = ArraySize(tempArray);

	if(!size)
	{
		ArrayDestroy(tempArray);
		return 0;
	}

	new ent = spawn_mysterybox(ArrayGetCell(tempArray, random(size)));
	ArrayDestroy(tempArray);

	return ent;
}

bool:is_spawn_location_available(const iDistrict)
{
	new szKey[64];
	formatex(szKey, charsmax(szKey), "%s_LOCATION_#%d", MAP_NAME, iDistrict);

	if(!TrieKeyExists(Trie_locations_available, szKey))
	{
		return true;
	}

	return false;
}

get_available_mybox_locations(const Array:pArray)
{
	if(!g_Total_loc) return 0;

	new szKey[64], size = 0;

	for(new i; i < g_Total_loc; i++)
	{
		formatex(szKey, charsmax(szKey), "%s_LOCATION_#%d", MAP_NAME, i);

		if(!TrieKeyExists(Trie_locations_available, szKey))
		{
			ArrayPushCell(pArray, i);
			size ++;
		}
	}

	return size;
}

spawn_mysterybox_decoy(const district)
{
	new box = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "info_target"));

	if(!box) return;

	set_pev(box, pev_classname, mysterybox_classname_decoy);
	set_pev(box, pev_solid, SOLID_NOT);
	set_pev(box, pev_movetype, MOVETYPE_NONE);
	set_pev(box, pev_owner, 0);
	set_pev(box, pev_takedamage, DAMAGE_NO);

	new Float:fValues[5], szKey[64], Float:fAngles[3], Float:fOrigin[3];
	formatex(szKey, charsmax(szKey), "%s_LOCATION_#%d", MAP_NAME, district);
	TrieGetArray(Trie_locations, szKey, fValues, sizeof fValues);

	fOrigin[0] = fValues[0];
	fOrigin[1] = fValues[1];
	fOrigin[2] = fValues[2];

	new iModelSlot = random(sizeof mystery_box_models);
	engfunc(EngFunc_SetOrigin, box, fOrigin);
	engfunc(EngFunc_SetModel, box, mystery_box_models[iModelSlot][MODEL_NAME]);
	engfunc(EngFunc_SetSize, box, mysterybox_mins, mysterybox_maxs);
	set_pev(box, pev_body, mystery_box_models[iModelSlot][MODEL_BODY]);
	set_pev(box, pev_skin, mystery_box_models[iModelSlot][MODEL_SKIN]);

	new TYPE =  floatround(fValues[4]);
	set_pev(box, PEV_MYSTERYBOX_FALL_TYPE, TYPE);

	fAngles[1] = fValues[3];
	set_pev(box, pev_angles, fAngles);
	set_pev(box, pev_fixangle, 1);

	set_pev(box, PEV_MYSTERYBOX_DISTRICT, district);
	set_pev(box, PEV_MYSTERYBOX_IDENTIFIER, ID_MYSTERYBOX);

	set_pev(box, pev_rendermode, kRenderTransAlpha);
	set_pev(box, pev_renderamt, 125.0);
}

spawn_mysterybox(const district)
{
	new box = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "info_target"));
	
	if(!box) return 0;
	
	set_pev(box, pev_classname, mysterybox_classname);
	set_pev(box, pev_solid, SOLID_BBOX);
	set_pev(box, pev_movetype, MOVETYPE_TOSS);
	set_pev(box, pev_owner, 0);
	set_pev(box, pev_takedamage, DAMAGE_NO);
	
	new Float:fValues[5], szKey[64], Float:fAngles[3], Float:fOrigin[3];
	formatex(szKey, charsmax(szKey), "%s_LOCATION_#%d", MAP_NAME, district);
	TrieGetArray(Trie_locations, szKey, fValues, sizeof fValues);
	TrieSetCell(Trie_locations_available, szKey, 1);
	
	fOrigin[0] = fValues[0];
	fOrigin[1] = fValues[1];
	fOrigin[2] = fValues[2];
	
	new iModelSlot = random(sizeof mystery_box_models);
	engfunc(EngFunc_SetModel, box, mystery_box_models[iModelSlot][MODEL_NAME]);
	engfunc(EngFunc_SetSize, box, mysterybox_mins, mysterybox_maxs);
	set_pev(box, pev_body, mystery_box_models[iModelSlot][MODEL_BODY]);
	set_pev(box, pev_skin, mystery_box_models[iModelSlot][MODEL_SKIN]);
	
	new TYPE =  floatround(fValues[4]);
	set_pev(box, PEV_MYSTERYBOX_FALL_TYPE, TYPE);
	set_pev(box, pev_impulse, 0);
	
	mysterybox_fall_type(box, fOrigin, FallTypes:TYPE);
	
	fAngles[1] = fValues[3];
	set_pev(box, pev_angles, fAngles);
	set_pev(box, pev_fixangle, 1);
	
	new env = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "env_sprite"));

	if(!env)
	{
		remove_entity_safely(box);
		return 0;
	}
	
	set_pev(env, pev_solid, SOLID_TRIGGER);
	set_pev(env, pev_movetype, MOVETYPE_FOLLOW);
	set_pev(env, pev_aiment, box);
	set_pev(env, pev_takedamage, DAMAGE_NO);
	
	new xArray[ITEM_DATA],
		Array:tArray = ArrayCreate(1,1),
		chances[100];

	arrayset(chances, TEDDYBEAR_ITEM, sizeof chances);

	for(new i; i < g_total_items; i++)
	{
		ArrayGetArray(array_items_data, i, xArray)

		ArrayPushCell(tArray, xArray[ITEM_CHANCES]);
	}

	for(new itemX, x, f; itemX < g_total_items; itemX++)
	{
		f = clamp( x + floatround(float( ArrayGetCell(tArray, itemX) ) / float( g_total_items )), 0, 100 );

		for(; x < f; x++)
		{
			chances[ x ] = itemX;
		}
	}

	ArrayDestroy(tArray);
	SortIntegers(chances, sizeof chances, Sort_Random);

	set_pev(env, PEV_MYSTERYBOX_CHOSEN_ITEM, chances[random(sizeof chances)]);
	set_pev(env, PEV_MYSTERYBOX_ITEM_ID, 0);
	
	set_pev(box, PEV_MYSTERYBOX_DISTRICT, district);
	set_pev(box, PEV_MYSTERYBOX_PROCESS, MYSTERYBOX_PROCESS_DEPLOYMENT);
	set_pev(box, PEV_MYSTERYBOX_ITEM_ENTITY, env);
	set_pev(box, pev_nextthink, (get_gametime() + 1.0));

	return box;
}

mysterybox_fall_type(const box, const Float:fOrigin[3], const FallTypes:iType)
{
	switch( iType )
	{
		case FALL_TYPE_NONE:
		{
			set_pev(box, pev_origin, fOrigin)
		}
		case FALL_TYPE_PARACHUTE:
		{
			set_pev(box, pev_gravity, 0.1);
			
			new Float:fEnd[3], Float:gtime = get_gametime();
			fEnd[0] = fOrigin[0];
			fEnd[1] = fOrigin[1];
			fEnd[2] = fOrigin[2] + 1000.0;
			
			new tr2 = create_tr2();
			engfunc(EngFunc_TraceLine, fOrigin, fEnd, (IGNORE_MONSTERS|IGNORE_MISSILE), box, tr2);
			
			get_tr2(tr2, TR_vecEndPos, fEnd);
			fEnd[2] -= 100.0;
			
			free_tr2(tr2);
			
			if(fEnd[2] < fOrigin[2]) fEnd[2] = fOrigin[2];
			
			set_pev(box, pev_origin, fEnd)
			
			new chute = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "info_target"));
			if(chute > 0)
			{
				set_pev(chute, pev_solid, SOLID_TRIGGER);
				set_pev(chute, pev_movetype, MOVETYPE_FOLLOW);
				set_pev(chute, pev_aiment, box);

				new iModel = random(sizeof parachute_models);
				engfunc(EngFunc_SetModel, chute, parachute_models[iModel][MODEL_NAME]);
				set_pev(chute, pev_body, parachute_models[iModel][MODEL_BODY]);
				set_pev(chute, pev_skin, parachute_models[iModel][MODEL_SKIN]);
				
				set_pev(chute, pev_sequence, 0);
				set_pev(chute, pev_gaitsequence, 1);
				set_pev(chute, pev_frame, 1.0);
				set_pev(chute, pev_animtime, gtime + 0.2);
				set_pev(chute, pev_framerate, 0.8);
				
				set_pev(box, pev_impulse, chute);
			}
		}
		case FALL_TYPE_DROP:
		{
			set_pev(box, pev_gravity, 1.0)
			
			new Float:fEnd[3];
			fEnd[0] = fOrigin[0];
			fEnd[1] = fOrigin[1];
			fEnd[2] = fOrigin[2] + 1000.0;
			
			new tr2 = create_tr2();
			engfunc(EngFunc_TraceLine, fOrigin, fEnd, (IGNORE_MONSTERS|IGNORE_MISSILE), box, tr2)
			
			get_tr2(tr2, TR_vecEndPos, fEnd)
			fEnd[2] -= 100.0;
			
			free_tr2(tr2);
			
			if(fEnd[2] < fOrigin[2]) fEnd[2] = fOrigin[2];
			
			set_pev(box, pev_origin, fEnd)
		}
		case FALL_TYPE_BOUNCE:
		{
			set_pev(box, pev_gravity, 1.5);
			set_pev(box, pev_friction, 0.25);
			set_pev(box, pev_solid, SOLID_NOT);
			set_pev(box, pev_movetype, MOVETYPE_BOUNCE);
			
			new Float:fEnd[3];
			fEnd[0] = fOrigin[0];
			fEnd[1] = fOrigin[1];
			fEnd[2] = fOrigin[2] + 1000.0;
			
			new tr2 = create_tr2();
			engfunc(EngFunc_TraceLine, fOrigin, fEnd, (IGNORE_MONSTERS|IGNORE_MISSILE), box, tr2);
			
			get_tr2(tr2, TR_vecEndPos, fEnd);
			fEnd[2] -= 100.0;
			
			free_tr2(tr2);
			
			if(fEnd[2] < fOrigin[2]) fEnd[2] = fOrigin[2];
			
			set_pev(box, pev_origin, fEnd);
		}
	}
}

public remove_entity_safely(const ent)
{
	if(pev_valid(ent))
	{
		if(pev(ent, pev_flags) & FL_KILLME)
		{ // entity is already being killed.
			return;
		}

		set_pev(ent, pev_flags, FL_KILLME);
		dllfunc(DLLFunc_Think, ent);
	}
}

public fw_Think_post(const ent)
{
	if(!pev_valid(ent) || pev(ent, pev_flags) & FL_KILLME) return;
	
	static sClassname[24];
	pev(ent, pev_classname, sClassname, charsmax(sClassname))
	
	if(!equal(sClassname, mysterybox_classname)) return;
	
	static xArray[ITEM_DATA], Float:gtime, Float:fOrigin[3], Float:fVec[3], env, bool:onground, iBeamLife;
	pev(ent, pev_origin, fOrigin);
	env = pev(ent, PEV_MYSTERYBOX_ITEM_ENTITY);
	gtime = get_gametime();
	iBeamLife = 0;
	onground = (pev(ent, pev_flags) & FL_ONGROUND) ? true:false;

	switch( pev(ent, PEV_MYSTERYBOX_PROCESS) )
	{
		case MYSTERYBOX_PROCESS_DEPLOYMENT:
		{
			if(onground)
			{
				set_pev(ent, PEV_MYSTERYBOX_PROCESS, MYSTERYBOX_PROCESS_SEEK_USER);

				switch( pev(ent, PEV_MYSTERYBOX_FALL_TYPE) )
				{
					case FALL_TYPE_BOUNCE:
					{
						pev(ent, pev_velocity, fVec);
						
						if(fVec[0] == 0.0 && fVec[1] == 0.0 && fVec[2] == 0.0)
						{
							set_pev(ent, pev_solid, SOLID_BBOX);
							set_pev(ent, pev_movetype, MOVETYPE_NONE);
							engfunc(EngFunc_SetSize, ent, mysterybox_mins, mysterybox_maxs);
						}
					}
					case FALL_TYPE_PARACHUTE:
					{
						new chute = pev(ent, pev_impulse);

						if( chute && pev_valid(chute) )
						{
							set_pev(ent, pev_impulse, 0);

							set_pev(chute, pev_sequence, 2);
							set_pev(chute, pev_gaitsequence, 1);
							set_pev(chute, pev_frame, 1.0);
							set_pev(chute, pev_animtime, gtime + 0.2);
							set_pev(chute, pev_framerate, 1.0);

							set_task(2.0, "remove_entity_safely", chute);
						}
					}
				}
			}
			
			set_pev(ent, pev_nextthink, (gtime + 0.1));
			iBeamLife = 1;
		}
		case MYSTERYBOX_PROCESS_SEEK_USER:
		{
			static player = 0;
			while((player = engfunc(EngFunc_FindEntityInSphere, player, fOrigin, 100.0)) > 0)
			{
				if(!is_user_alive(player)) continue;
				
				if(pev(player, pev_button) & IN_USE && !_mysterybox_open_attempt(player, ent))
				{
					set_pev(ent, PEV_MYSTERYBOX_PROCESS, MYSTERYBOX_PROCESS_BOX_OPENING);
					set_pev(ent, PEV_MYSTERYBOX_USER, player);
					set_pev(ent, pev_nextthink, (gtime + 0.3));
					iBeamLife = 3;
					player = -1;
					break;
				}
			}
			
			if(player != -1)
			{
				set_pev(ent, pev_nextthink, (gtime + 0.1));
				iBeamLife = 1;
			}
		}
		case MYSTERYBOX_PROCESS_BOX_OPENING:
		{
			set_pev(ent, pev_sequence, 1);
			set_pev(ent, pev_gaitsequence, 1);
			set_pev(ent, pev_frame, 1.0);
			set_pev(ent, pev_animtime, gtime + 0.3);
			set_pev(ent, pev_framerate, 0.5);

			set_pev(ent, PEV_MYSTERYBOX_TIME_OPEN, gtime);
			set_pev(ent, PEV_MYSTERYBOX_TIME_CLOSE, gtime + 15.0);
			set_pev(env, PEV_MYSTERYBOX_TIME_CHOSEN_ITEM, gtime + 5.0);
			
			engfunc(EngFunc_GetBonePosition, ent, MYSTRYBOX_BONE_ITEM, fVec);
			set_pev(env, pev_origin, fVec);
			set_pev(env, pev_movetype, MOVETYPE_NOCLIP);
			set_pev(env, pev_aiment, 0);
			set_pev(env, pev_velocity, Float:{0.0, 0.0, 5.0});
			
			emit_sound(ent, CHAN_AUTO, default_box_opening_sound, VOL_NORM, ATTN_NORM, 0, PITCH_HIGH);
			
			set_pev(ent, PEV_MYSTERYBOX_PROCESS, MYSTERYBOX_PROCESS_CHOOSING_ITEM);
			set_pev(ent, pev_nextthink, (gtime + 1.0));
			iBeamLife = 10;
		}
		case MYSTERYBOX_PROCESS_CHOOSING_ITEM:
		{
			static Float:fChoosingTime;
			pev(env, PEV_MYSTERYBOX_TIME_CHOSEN_ITEM, fChoosingTime);

			if(fChoosingTime < gtime)
			{
				mysterybox_chosen_item(ent);
			}
			else
			{
				new rand = pev(env, PEV_MYSTERYBOX_ITEM_ID) + 1;
				if(rand >= g_total_items) rand = 0;

				ArrayGetArray(array_items_data, rand, xArray);

				static szKey[48], Float:fValues[4];
				formatex(szKey, charsmax(szKey), "%s_LOCATION_#%d", MAP_NAME, pev(ent, PEV_MYSTERYBOX_DISTRICT));
				TrieGetArray(Trie_locations, szKey, fValues, sizeof fValues);
				xArray[ITEM_MODEL_ANGLES][1] += fValues[3];

				set_pev(env, pev_angles, xArray[ITEM_MODEL_ANGLES]);
				set_pev(env, PEV_MYSTERYBOX_ITEM_ID, rand);
				set_pev(env, pev_scale, (xArray[ITEM_SCALE] / 100.0));
				engfunc(EngFunc_SetModel, env, xArray[ITEM_MODEL]);
				set_pev(env, pev_body, xArray[ITEM_MODEL_BODY]);
				set_pev(env, pev_skin, xArray[ITEM_MODEL_SKIN]);
			}

			set_pev(ent, pev_nextthink, (gtime + 0.3));
			iBeamLife = 3;
		}
		case MYSTERYBOX_PROCESS_SELECT_ITEM:
		{
			new selected, player = pev(ent, PEV_MYSTERYBOX_USER);
			
			if(is_user_alive(player))
			{
				new Float:fOrigin2[3];
				pev(player, pev_origin, fOrigin2)
				if(get_distance_f(fOrigin, fOrigin2) <= 100.0)
				{
					if(pev(player, pev_button) & IN_USE) selected = player;
				}
			}
			
			if(selected > 0)
			{
				ArrayGetArray(array_items_data, pev(env, PEV_MYSTERYBOX_CHOSEN_ITEM), xArray);
				
				if( !xArray[ITEM_FLAG] || (get_user_flags(selected) & xArray[ITEM_FLAG]) )
				{
					set_pev(ent, PEV_MYSTERYBOX_PROCESS, MYSTERYBOX_PROCESS_ITEM_RESET)
					new uid[16]; num_to_str(get_user_userid(selected), uid, charsmax(uid));
					
					client_print(selected, print_chat, "You have found a %s!", xArray[ITEM_NAME])
					
					switch( xArray[ITEM_COMMAND_TYPE] )
					{
						case -1: // client command.
						{
							replace_all(xArray[ITEM_COMMAND], charsmax(xArray[ITEM_COMMAND]), "%id", uid);
							client_cmd(selected, xArray[ITEM_COMMAND]);
						}
						case 0: // server command.
						{
							replace_all(xArray[ITEM_COMMAND], charsmax(xArray[ITEM_COMMAND]), "%id", uid);
							server_cmd("%s", xArray[ITEM_COMMAND]);
						}
						case 1: // native calling
						{
							num_to_str(selected, uid, charsmax(uid));
							replace_all(xArray[ITEM_COMMAND], charsmax(xArray[ITEM_COMMAND]), "%id", uid);
							
							new szFunction[32], szPluginname[32], sParam[5][32];
							strtok(xArray[ITEM_COMMAND], szFunction, charsmax(szFunction), xArray[ITEM_COMMAND], charsmax(xArray[ITEM_COMMAND]))
							strtok(xArray[ITEM_COMMAND], szPluginname, charsmax(szPluginname), xArray[ITEM_COMMAND], charsmax(xArray[ITEM_COMMAND]))
							remove_quotes(szFunction); remove_quotes(szPluginname);
							new loop = parse(xArray[ITEM_COMMAND], sParam[0], charsmax(sParam[]), sParam[1], charsmax(sParam[]), sParam[2], charsmax(sParam[]),
							sParam[3], charsmax(sParam[]), sParam[4], charsmax(sParam[]));
							if((callfunc_begin(szFunction, szPluginname)) >= 1)
							{
								for(new i, type[2]; i < loop; i++)
								{
									strtok(sParam[i], type, charsmax(type), sParam[i], charsmax(sParam[]), ':')
									remove_quotes(sParam[i])
									
									switch(type[0])
									{
										case 'I', 'i':
										{
											callfunc_push_int(str_to_num(sParam[i]));
										}
										case 'F', 'f':
										{
											callfunc_push_float(floatstr(sParam[i]));
										}
										case 'S', 's':
										{
											callfunc_push_str(sParam[i], false);
										}
									}
								}
								callfunc_end();
							}
						}
					}
					
					set_pev(env, pev_scale, 1.0);
					engfunc(EngFunc_SetModel, env, "");
				}
				else
				{
					client_print(selected, print_chat, "Sorry but you dont have access to this item!");
				}
			}
			else
			{
				static Float:fClosingTime, Float:fChoosingDuration;
				pev(ent, PEV_MYSTERYBOX_TIME_CLOSE, fClosingTime);
				pev(env, PEV_MYSTERYBOX_T_ABANDONED_ITEM, fChoosingDuration);

				if(fClosingTime < gtime)
				{
					set_pev(ent, PEV_MYSTERYBOX_PROCESS, MYSTERYBOX_PROCESS_ITEM_RESET);
				}
				else if(fChoosingDuration < gtime)
				{
					set_pev(env, pev_velocity, Float:{0.0, 0.0, -5.0});
				}
			}
			
			set_pev(ent, pev_nextthink, (gtime + 0.1));
			iBeamLife = 1;
		}
		case MYSTERYBOX_PROCESS_TEDDYBEAR_FAREWELL:
		{
			static Float:fTeddyBearStandbyLen;
			pev(env, PEV_MYSTERYBOX_T_ABANDONED_ITEM, fTeddyBearStandbyLen);

			if(fTeddyBearStandbyLen < gtime)
			{
				set_pev(ent, pev_solid, SOLID_NOT);

				set_pev(env, pev_velocity, Float:{0.0, 0.0, 400.0});
				set_pev(ent, PEV_MYSTERYBOX_PROCESS, MYSTERYBOX_PROCESS_VANISHING_25);
			}

			set_pev(ent, pev_nextthink, (gtime + 0.1));
		}
		case MYSTERYBOX_PROCESS_ITEM_RESET:
		{
			engfunc(EngFunc_GetBonePosition, ent, MYSTRYBOX_BONE_ITEM, fVec);
			set_pev(env, pev_velocity, Float:{0.0,0.0,0.0});
			set_pev(env, pev_origin, fVec);
			set_pev(env, pev_scale, 1.0);
			
			set_pev(ent, pev_sequence, 1);
			set_pev(ent, pev_gaitsequence, 1);
			set_pev(ent, pev_frame, -1.0);
			set_pev(ent, pev_animtime, gtime + 0.3);
			set_pev(ent, pev_framerate, -0.5);
			set_pev(ent, PEV_MYSTERYBOX_PROCESS, MYSTERYBOX_PROCESS_SEEK_USER);
			
			engfunc(EngFunc_SetModel, env, "");
			
			new xArray[ITEM_DATA],
				Array:tArray = ArrayCreate(1,1),
				chances[100];

			arrayset(chances, TEDDYBEAR_ITEM, sizeof chances);
			
			for(new i; i < g_total_items; i++)
			{
				ArrayGetArray(array_items_data, i, xArray)
				
				ArrayPushCell(tArray, xArray[ITEM_CHANCES]);
			}
			
			for(new itemX, x, f; itemX < g_total_items; itemX++)
			{
				f = clamp( x + floatround(float( ArrayGetCell(tArray, itemX) ) / float( g_total_items )), 0, 100 );

				for(; x < f; x++)
				{
					chances[ x ] = itemX;
				}
			}

			SortIntegers(chances, sizeof chances, Sort_Random);
			
			ArrayDestroy(tArray);
			set_pev(env, PEV_MYSTERYBOX_CHOSEN_ITEM, chances[random(sizeof chances)]);
			set_pev(ent, pev_nextthink, (gtime + 3.0));
			iBeamLife = 35;
		}
		case MYSTERYBOX_PROCESS_VANISHING_25:
		{
			//Screen Shake
			static iMsgScreenShake = 0, player; player = 0;
			if(!iMsgScreenShake) iMsgScreenShake = get_user_msgid("ScreenShake");

			while( (player = engfunc(EngFunc_FindEntityInSphere, player, fOrigin, 300.0)) && player <= MAX_PLAYERS )
			{
				message_begin(MSG_ONE_UNRELIABLE, iMsgScreenShake, _, player);
				write_short( 0xFFFF ); // Amplitude
				write_short( 0xFFFF ); // Duration
				write_short( 0xFFFF ); // Frequency
				message_end();
			}

			set_pev(ent, pev_sequence, 1);
			set_pev(ent, pev_gaitsequence, 1);
			set_pev(ent, pev_frame, -1.0);
			set_pev(ent, pev_animtime, gtime + 0.3);
			set_pev(ent, pev_framerate, -0.5);
			
			set_pev(ent, pev_movetype, MOVETYPE_NOCLIP);
			fVec[0] = 0.0; fVec[1] = random_float(100.0,500.0); fVec[2] = 0.0;
			set_pev(ent, pev_avelocity, fVec);
			set_pev(ent, PEV_MYSTERYBOX_PROCESS, MYSTERYBOX_PROCESS_VANISHING_50)
			set_pev(ent, pev_velocity, Float:{0.0,0.0,15.0});
			set_pev(ent, pev_nextthink, (gtime + 2.0));
		}
		case MYSTERYBOX_PROCESS_VANISHING_50:
		{
			set_pev(ent, pev_velocity, Float:{0.0,0.0,0.0});
			fVec[0] = 0.0; fVec[1] = random_float(500.0,1000.0); fVec[2] = 0.0;
			set_pev(ent, pev_avelocity, fVec);
			set_pev(ent, PEV_MYSTERYBOX_PROCESS, MYSTERYBOX_PROCESS_VANISHING_85);
			set_pev(ent, pev_nextthink, (gtime + 2.0));

			// Lets make it a little creepy...
			emit_sound(ent, CHAN_AUTO, default_samanthas_laugh_sound, VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
		}
		case MYSTERYBOX_PROCESS_VANISHING_85:
		{
			fVec[0] = 0.0; fVec[1] = random_float(1000.0,2000.0); fVec[2] = 0.0;
			set_pev(ent, pev_avelocity, fVec);
			set_pev(ent, PEV_MYSTERYBOX_PROCESS, MYSTERYBOX_PROCESS_DEATH);
			set_pev(ent, pev_nextthink, (gtime + 2.0));
		}
		case MYSTERYBOX_PROCESS_DEATH:
		{
			if(contain(MYBOX_FLAGS, "d") > -1)
			{
				spawning_mybox_process();
			}
			
			static sBuff[48];
			formatex(sBuff, charsmax(sBuff), "%s_LOCATION_#%d", MAP_NAME, pev(ent, PEV_MYSTERYBOX_DISTRICT));
			TrieDeleteKey(Trie_locations_available, sBuff);
			
			remove_entity_safely(env);
			remove_entity_safely(ent);
		}
	}

	if( onground && iBeamLife > 0 )
	{
		static tr2, Float:fEnd[3];
		fEnd[0] = fOrigin[0];
		fEnd[1] = fOrigin[1];
		fEnd[2] = floatmin( fEnd[2] + 9999.0, 4096.0 );
		tr2 = create_tr2();
		engfunc(EngFunc_TraceLine, fOrigin, fEnd, (IGNORE_GLASS|IGNORE_MISSILE|IGNORE_MONSTERS), ent, tr2);
		get_tr2(tr2, TR_vecEndPos, fEnd);
		free_tr2(tr2);

		message_begin(MSG_BROADCAST, SVC_TEMPENTITY);
		write_byte(TE_BEAMPOINTS);
		engfunc(EngFunc_WriteCoord, fOrigin[0]);
		engfunc(EngFunc_WriteCoord, fOrigin[1]);
		engfunc(EngFunc_WriteCoord, fOrigin[2]);
		engfunc(EngFunc_WriteCoord, fEnd[0]);
		engfunc(EngFunc_WriteCoord, fEnd[1]);
		engfunc(EngFunc_WriteCoord, fEnd[2]);
		write_short(g_sprites[random(sizeof g_sprites)]); // sprite index
		write_byte(1); // starting frame
		write_byte(10); // frame rate
		write_byte(iBeamLife); // life
		write_byte(50); // line width
		write_byte(1); // noise
		write_byte(0); // r
		write_byte(0); // g
		write_byte(200); // b
		write_byte(255); // brightness
		write_byte(1); // scroll speed
		message_end();

		fOrigin[2] += (mysterybox_maxs[2] - mysterybox_mins[2]);
		dlight(fOrigin, 15, { 150, 100, 0 }, min(iBeamLife * 10, 255), 0, .dest = MSG_PVS);
	}
}

mysterybox_chosen_item(const ent)
{
	new env = pev(ent, PEV_MYSTERYBOX_ITEM_ENTITY);
	new item = pev(env, PEV_MYSTERYBOX_CHOSEN_ITEM);
	new xArray[ITEM_DATA];
	
	new szKey[48], Float:fValues[4];
	formatex(szKey, charsmax(szKey), "%s_LOCATION_#%d", MAP_NAME, pev(ent, PEV_MYSTERYBOX_DISTRICT));
	TrieGetArray(Trie_locations, szKey, fValues, sizeof fValues);
	
	if(item != TEDDYBEAR_ITEM)
	{
		ArrayGetArray(array_items_data, item, xArray);
		xArray[ITEM_MODEL_ANGLES][1] += fValues[3];
		set_pev(ent, PEV_MYSTERYBOX_PROCESS, MYSTERYBOX_PROCESS_SELECT_ITEM);
		if(xArray[ITEM_SOUND][0] != EOS) emit_sound(ent, CHAN_AUTO, xArray[ITEM_SOUND], VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
		set_pev(env, pev_angles, xArray[ITEM_MODEL_ANGLES]);
		set_pev(env, pev_scale, (xArray[ITEM_MODEL_ANGLES] / 100.0));
		set_pev(env, pev_body, xArray[ITEM_MODEL_BODY]);
		set_pev(env, pev_skin, xArray[ITEM_MODEL_SKIN]);
		set_pev(env, PEV_MYSTERYBOX_T_ABANDONED_ITEM, get_gametime() + 5.0);
	}
	else
	{
		new Float:fAngles[3], iModel = random(sizeof default_teddybear_models);
		fAngles = teddybear_angles;
		formatex(xArray[ITEM_MODEL], charsmax(xArray[ITEM_MODEL]), default_teddybear_models[iModel][MODEL_NAME]);
		set_pev(ent, PEV_MYSTERYBOX_PROCESS, MYSTERYBOX_PROCESS_TEDDYBEAR_FAREWELL);
		emit_sound(env, CHAN_BODY, default_teddybear_sound, VOL_NORM, ATTN_NORM, 0, PITCH_HIGH);
		fAngles[1] += fValues[3];
		set_pev(env, pev_angles, fAngles);
		set_pev(env, pev_body, default_teddybear_models[iModel][MODEL_BODY]);
		set_pev(env, pev_skin, default_teddybear_models[iModel][MODEL_SKIN]);
		set_pev(env, PEV_MYSTERYBOX_T_ABANDONED_ITEM, get_gametime() + 3.0);
	}
	
	engfunc(EngFunc_SetModel, env, xArray[ITEM_MODEL]);
	set_pev(env, pev_velocity, Float:{0.0,0.0,0.0});
}

show_mysterybox_spawners( )
{
	for(new i = 0; i < g_Total_loc; i++)
	{
		spawn_mysterybox_decoy( i );
	}

	if( !g_FW_FM_ADDTOFULLPACK_POST )
	{
		g_FW_FM_ADDTOFULLPACK_POST = register_forward(FM_AddToFullPack, "fw_AddToFullPack_post", ._post=true);
	}
}

mysterybox_remove_decoy_spawners( )
{
	new ent;
	while( ((ent = engfunc(EngFunc_FindEntityByString, ent, "classname", mysterybox_classname_decoy)) > 0) )
	{
		remove_entity_safely(ent);
	}
}

public fw_AddToFullPack_post(es_handle, e, ent, host, hostflags, player, pSet)
{
	if(g_FW_FM_ADDTOFULLPACK_POST && !user_editor_mode)
	{
		unregister_forward(FM_AddToFullPack, g_FW_FM_ADDTOFULLPACK_POST, .post=true);
		g_FW_FM_ADDTOFULLPACK_POST = 0;
		return FMRES_IGNORED;
	}

	if( !player && pev_valid(ent) && pev(ent, PEV_MYSTERYBOX_IDENTIFIER) == ID_MYSTERYBOX
				)
	{
		if(!check_flag(user_editor_mode, host))
		{
			set_es(es_handle, ES_RenderMode, kRenderTransAlpha);
			set_es(es_handle, ES_RenderAmt, 000);
			set_es(es_handle, ES_Effects, get_es(es_handle, ES_Effects) | EF_NODRAW);
			return FMRES_IGNORED;
		}
		else
		{
			set_es(es_handle, ES_RenderMode, kRenderTransAlpha);
			set_es(es_handle, ES_RenderAmt, 150);
			set_es(es_handle, ES_Effects, get_es(es_handle, ES_Effects) & ~EF_NODRAW);
			return FMRES_IGNORED;
		}
	}
	return FMRES_IGNORED;
}

dlight(const Float:fOrigin[3], iRadius, const iColor[3], const life, const iRate, const dest=MSG_BROADCAST, const host=0)
{
    engfunc(EngFunc_MessageBegin, dest, SVC_TEMPENTITY, fOrigin, host);
    write_byte(TE_DLIGHT)
    engfunc(EngFunc_WriteCoord, fOrigin[0]);
    engfunc(EngFunc_WriteCoord, fOrigin[1]);
    engfunc(EngFunc_WriteCoord, fOrigin[2]);
    write_byte(iRadius);
    write_byte(iColor[0]);
    write_byte(iColor[1]);
    write_byte(iColor[2]);
    write_byte(life);
    write_byte(iRate);
    message_end();
}


// Natives
public plugin_natives()
{
	register_native("mybox_place_mysterybox_spawner", "_place_mysterybox_spawner");
	register_native("mybox_destroy_mysterybox_spawner", "_destroy_mysterybox_spawner");
	register_native("mybox_destroy_boxes", "_destroy_boxes");
	register_native("mybox_spawn_mysterybox", "_spawn_box");
	register_native("mybox_get_locations_count", "native_loc_total");
}

public native_loc_total()
{
	return g_Total_loc;
}

public MYSTERYBOX_SPAWNER_PLACEMENT:_place_mysterybox_spawner(plugin, argc)
{
	new Float:fOrigin[3], Float:fvAngle[3], FallTypes:iFallType = FALL_TYPE_NONE;
	get_array_f(1, fOrigin, 3);
	get_array_f(2, fvAngle, 3);
	iFallType = FallTypes:get_param(3);
	return place_mysterybox_spawner(fOrigin, fvAngle, iFallType);
}

public MYSTERYBOX_SPAWNER_PLACEMENT:_destroy_mysterybox_spawner(plugin, argc)
{
	new Float:fOrigin[3];
	get_array_f(1, fOrigin, 3);
	return destroy_mysterybox_spawner(fOrigin);
}


public _destroy_boxes(plugin, argc)
{
	remove_task(TASK_LOOP_SPAWN);
	remove_all_myboxes();
	return 0;
}

public _spawn_box(plugin, argc)
{
	new iDistrict = get_param( 1 );

	if( iDistrict >= g_Total_loc || iDistrict < -1 )
	{
		log_error(AMX_ERR_NATIVE, "Invalid mysterybox district location ( %d )", iDistrict);
		return -1;
	}

	if(iDistrict == -1)
	{
		return spawning_mybox_process();
	}
	else if(is_spawn_location_available(iDistrict))
	{
		return spawn_mysterybox(iDistrict);
	}

	return 0;
}

// Forwards
_mysterybox_open_attempt(const user, const mybox)
{
	new ifwReturn;
	ExecuteForward(g_fw_mybox_open_attempt, ifwReturn, user, mybox);
	return ifwReturn;
}
