/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <nvault>
#include <jailbreak_core>

#define PLUGIN "[JB] MAPS System"
#define AUTHOR "Natsheh"

#define MAX_MAP_NAME_SIZE 64 
const MAX_MAPS_PER_VOTE = 5;
const MAX_RECENT_MAPS = 3
new const NVAULT_RECENT_MAPS_FILE_NAME[] = "jb_map_system_recentmaps";

#define TASK_VOTEMAP_TIMER 9001005
#define TASK_VOTEMAP_TIMER_END 900101

new Array:g_maps_array, g_szMaps[MAX_MAPS_PER_VOTE+1][MAX_MAP_NAME_SIZE], g_iVotes[MAX_MAPS_PER_VOTE+1], RockedTheVote[MAX_PLAYERS+1], g_cvar_timer, g_cvar_one,
VOTEMAP_MENU = INVALID_HANDLE, g_iVoters, g_iCounter, g_iNoms[2][MAX_MAPS_PER_VOTE], g_iNoms_num, mp_timelimit, g_iNEXTMAP = -1, Float:fTIMER, Float:fTIMELEFT, g_bHasVoteMenu,
g_pcvar_countdown, g_pcvar_mapextendtime, g_szRecentMaps[MAX_RECENT_MAPS][MAX_MAP_NAME_SIZE], g_iRecentMaps;

new const MAP_VOTING_ANNOUNCE_SOUNDS[][] = {
	"gman/gman_choose1.wav",
	"gman/gman_choose2.wav",
	"hostage/hos4.wav"
}

public plugin_precache()
{
	new iSounds = sizeof MAP_VOTING_ANNOUNCE_SOUNDS;

	while(iSounds--)
	{
		precache_sound(MAP_VOTING_ANNOUNCE_SOUNDS[iSounds]);
	}
}

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	g_maps_array = ArrayCreate(MAX_MAP_NAME_SIZE,1);
	
	mp_timelimit = get_cvar_pointer("mp_timelimit");
	
	new Trie:trie_ = TrieCreate();

	new pos, x, szMapname[MAX_MAP_NAME_SIZE];
	get_mapname(szMapname, charsmax(szMapname));
	TrieSetString(trie_, szMapname, "1"); // Make sure currentmap don't get into the voting menu.
	
	#if AMXX_VERSION_NUM > 182
	while( ( pos = read_dir("maps/", pos, szMapname, charsmax(szMapname) ) ) > 0 )
	#else
	new null;
	while( ( pos = read_dir("maps/", pos, szMapname, charsmax(szMapname), null ) ) > 0 )
	#endif
	{
		if((x=contain(szMapname, ".bsp")) == -1 || strlen(szMapname[x]) > 4) continue;
		szMapname[x] = 0;
		
		if(TrieKeyExists(trie_, szMapname)) continue;
		
		if(equali(szMapname, "jb_", 3) || equali(szMapname, "jail_", 5))
		{
			ArrayPushString(g_maps_array, szMapname);
			TrieSetString(trie_, szMapname, "1");
		}
	}
	
	TrieDestroy(trie_);
	
	register_clcmd("say", "clcmd_say");
	register_clcmd("say_team", "clcmd_say");
	register_concmd("listmaps", "concmd_listmaps");
	
	g_cvar_timer = register_cvar("jb_votemap_system_timer", "15");
	g_cvar_one = register_cvar("jb_votemap_system_rtv_percent", "70");
	g_pcvar_countdown = register_cvar("jb_votemap_countdown_enabled", "1");
	g_pcvar_mapextendtime = register_cvar("jb_votemap_extend_time", "15");

	get_mapname(szMapname, charsmax(szMapname));
	copy(g_szMaps[MAX_MAPS_PER_VOTE], charsmax(g_szMaps[]), szMapname);
}

public plugin_cfg()
{
	new pVault = nvault_open(NVAULT_RECENT_MAPS_FILE_NAME), iTimestamp;

	for(new i, szNum[4]; i < MAX_RECENT_MAPS; i++)
	{
		num_to_str(i + 1, szNum, charsmax(szNum));
		if(nvault_lookup(pVault, szNum, g_szRecentMaps[i], charsmax(g_szRecentMaps[]), iTimestamp))
		{
			g_iRecentMaps++;
		}
	}

	nvault_close(pVault);

	set_task(1.0, "start_thetask");
}

public concmd_listmaps(id)
{
	new szMap[MAX_MAP_NAME_SIZE];
	get_mapname(szMap, charsmax(szMap));
	console_print(id, "** Available list of maps **");
	console_print(id, "* %s", szMap);
	for(new i, maxloop = ArraySize(g_maps_array); i < maxloop; i++)
	{
		ArrayGetString(g_maps_array, i, szMap, charsmax(szMap));
		console_print(id, "* %s", szMap);
	}
	console_print(id, "** END **^n");
	return PLUGIN_HANDLED;
}

public clcmd_say(id)
{
	static szString[128]
	read_args(szString, charsmax(szString));
	remove_quotes(szString);

	if(equali(szString, "/recentmaps", 11) || equali(szString, "recentmaps", 10))
	{
		if(!g_iRecentMaps)
		{
			cprint_chat(id, _, "There're currently no recentmaps been played!");
			return 1;
		}
		else if(g_iRecentMaps == 1)
		{
			cprint_chat(id, _, "Recent map is %s.", g_szRecentMaps[0]);
		}
		else
		{
			new szText[MAX_CHAT_MESSAGE_LENGTH], maxloop, i = 0;
			new iLen = formatex(szText, charsmax(szText), "Recent maps are ");

			for(maxloop = g_iRecentMaps - 2; i < maxloop; i++)
			{
				iLen += formatex(szText[iLen], charsmax(szText)-iLen, "%s, ", g_szRecentMaps[i]);
			}

			for(maxloop = g_iRecentMaps - 1; i < maxloop; i++)
			{
				iLen += formatex(szText[iLen], charsmax(szText)-iLen, "%s and ", g_szRecentMaps[i]);
			}

			if(i < g_iRecentMaps)
			{
				iLen += formatex(szText[iLen], charsmax(szText)-iLen, "%s.", g_szRecentMaps[i]);
			}

			cprint_chat(id, _, szText);
		}
		return 1;
	}
	if(equali(szString, "/timeleft", 9) || equali(szString, "timeleft", 8))
	{
		if(g_iNEXTMAP != -1)
		{
			cprint_chat(id, _, "!tMap will be changed in the begining of the new round!");
			return 1;
		}
		
		if(task_exists(TASK_VOTEMAP_TIMER_END))
		{
			cprint_chat(id, _, "Map vote is already in progress!");
			return 1;
		}
		
		new Float:fTimeleft = (fTIMELEFT-get_gametime());
		
		if(fTimeleft >= 0.0)
		{
			new szText[40], szWord[3][16];
			
			new iTime, hours, minutes, seconds = iTime = floatround(fTimeleft);
			seconds -= (hours = seconds / 3600) * 3600;
			seconds -= (minutes = seconds / 60) * 60;
			
			num_to_word(hours, szWord[0], charsmax(szWord[]));
			num_to_word(minutes, szWord[1], charsmax(szWord[]));
			num_to_word(seconds, szWord[2], charsmax(szWord[]));
			
			if(hours > 0 && minutes > 0)
			{
				client_cmd(id, "spk ^"%s hours %s minutes and %s seconds remaining^"", szWord[0], szWord[1], szWord[2]);
				format_time(szText, charsmax(szText), "%H hours, %M minutes, %S seconds", iTime);
			}
			else if(!hours && minutes > 0) 
			{
				client_cmd(id, "spk ^"%s minutes and %s seconds remaining^"", szWord[1], szWord[2]);
				format_time(szText, charsmax(szText), "%M minutes, %S seconds", iTime);
			}
			else if(hours > 0 && !minutes)
			{
				client_cmd(id, "spk ^"%s hours and %s seconds remaining^"", szWord[0], szWord[2]);
				format_time(szText, charsmax(szText), "%H hours, %S seconds", iTime);
			}
			else if(!hours && !minutes)
			{
				client_cmd(id, "spk ^"%s seconds remaining^"", szWord[2]);
				format_time(szText, charsmax(szText), "%S seconds", iTime);
			}
			
			cprint_chat(id, _, "%s remaining!", szText);
		}
		
		return 1;
	}
	
	if(equali(szString, "/rtv", 4) || equali(szString, "rtv", 3))
	{
		if(g_iNEXTMAP != -1)
		{
			cprint_chat(id, _, "Map vote is already determined!");
			return 1;
		}
		
		if(task_exists(TASK_VOTEMAP_TIMER_END))
		{
			cprint_chat(id, _, "Map vote is already in progress!");
			return 1;
		}
		
		new players[32], pnum;
		get_players(players, pnum, "ch");
		new amount_required = floatround(Float:(pnum * (get_pcvar_float(g_cvar_one) / 100.0)))
		
		new szName[32];
		get_user_name(id, szName, charsmax(szName));
		
		new rtv_num = RockedTheVote[0];
		
		// lets rock that vote!
		if(amount_required <= rtv_num)
		{
			cprint_chat(0, _, "!g%s !yhas initiated the map vote!!!", szName);
			remove_task(TASK_VOTEMAP_TIMER);
			set_task(1.0, "prepare_votemenu", TASK_VOTEMAP_TIMER);
			return 1;
		}
		
		if(RockedTheVote[id])
		{
			cprint_chat(id, _, "You have already rocked the vote!");
			cprint_chat(0, _, "!g%d player !yhas rocked the vote, !t%d needed!", RockedTheVote[0], amount_required);
			return 1;
		}
		
		rtv_num = ++RockedTheVote[0];
		new rtv_left = amount_required - rtv_num;
		RockedTheVote[id] = 1;
		
		// lets rock that vote!
		if(amount_required <= rtv_num)
		{
			cprint_chat(0, _, "!g%s !yhas initiated the map vote!!!", szName);
			remove_task(TASK_VOTEMAP_TIMER);
			set_task(1.0, "prepare_votemenu", TASK_VOTEMAP_TIMER);
			return 1;
		}
		
		cprint_chat(0, _, "!g%s !thas rocked the vote!", szName);
		cprint_chat(0, _, "!yneed !g%d !t%s to rock the vote!", rtv_left, rtv_left <= 1 ? "person":"people" );
		return 1;
	}
	
	if(equali(szString, "/nom", 4) || equali(szString, "nom", 3))
	{
		if(g_iNEXTMAP != -1)
		{
			cprint_chat(id, _, "Map vote is already determined!");
			return 1;
		}
		
		if(task_exists(TASK_VOTEMAP_TIMER_END))
		{
			cprint_chat(id, _, "Map vote is already in progress!");
			return 1;
		}
		
		new szMapname[MAX_MAP_NAME_SIZE];
		#if AMXX_VERSION_NUM > 182
		argbreak(szString, "", 0, szMapname, charsmax(szMapname));
		#else
		strbreak(szString, "", 0, szMapname, charsmax(szMapname));
		#endif
		
		if(strlen(szMapname) < 3)
		{
			cprint_chat(id, _, "Please write atleast 3 letters of the map name!");
			return 1;
		}
		
		new szCurrentMap[MAX_MAP_NAME_SIZE];
		get_mapname(szCurrentMap, charsmax(szCurrentMap));

		new map = -1;
		for(new i, maxloop = ArraySize(g_maps_array); i < maxloop; i++)
		{
			ArrayGetString(g_maps_array, i, szString, charsmax(szString));
			if(containi(szString, szMapname) != -1)
			{
				if(equal(szString, szCurrentMap))
				{
					cprint_chat(id, _, "Cannot nominate the current map!");
					return 1;
				}

				map = i;
				break;
			}
		}
		
		if(map != -1)
		{
			// Check if the map was recently played!?
			for(new x; x < g_iRecentMaps; x++)
			{
				if(equal(szString, g_szRecentMaps[x]))
				{
					cprint_chat(id, _, "Cannot nominate because the map was recently played!");
					return 1;
				}
			}

			new szName[32];
			get_user_name(id, szName, charsmax(szName));
			
			new bool:bNomination = true;
			for(new i, nominator; i < g_iNoms_num; i++)
			{
				if(g_iNoms[0][i] == map)
				{
					nominator = g_iNoms[1][i];
					if(nominator != id && nominator > 0)
					{
						get_user_name(nominator, szName, charsmax(szName));
						cprint_chat(id, _, "'%s' was already nominated by %s !", szString, szName);
						return 0;
					}
					
					bNomination = false;
					g_iNoms_num--;
					g_iNoms[0][i] = g_iNoms[0][g_iNoms_num];
					g_iNoms[1][i] = g_iNoms[1][g_iNoms_num];
					break;
				}
			}
			
			if(bNomination)
			{
				if(g_iNoms_num >= MAX_MAPS_PER_VOTE)
				{
					cprint_chat(id, _, "Maximum map nominations has been reached cannot nominate!");
					return 1;
				}

				g_iNoms[0][g_iNoms_num] = map;
				g_iNoms[1][g_iNoms_num] = id;
				g_iNoms_num++;
				cprint_chat(0, _, "%s has nominated the map '%s' !", szName, szString);
			}
			else
			{
				cprint_chat(0, _, "%s has innominate the map '%s' its no longer in the nomination list !", szName, szString);
			}
		}
		else
		{
			cprint_chat(id, _, "Failed to nominate the map '%s' was not found!", szMapname);
		}
		
		return 0;
	}
	
	if(equali(szString, "/votemap"))
	{
		if(!is_user_admin(id))
		{
			cprint_chat(id, _, "You don't have access to this command!");
			return 1;
		}
		
		if(task_exists(TASK_VOTEMAP_TIMER_END))
		{
			cprint_chat(id, _, "Map vote is already in progress!");
			return 1;
		}
		
		if(g_iNEXTMAP != -1)
		{
			cprint_chat(id, _, "Map vote is already determined!");
			return 1;
		}
		
		remove_task(TASK_VOTEMAP_TIMER);
		set_task(1.0, "prepare_votemenu", TASK_VOTEMAP_TIMER);
		new szName[32];
		get_user_name(id, szName, charsmax(szName))
		cprint_chat(0, _, "Admin %s has started a map vote!", szName);
		return 1;
	}
	
	if(equali(szString, "/nextmap") || equali(szString, "nextmap"))
	{
		if(g_iNEXTMAP == -1)
		{
			cprint_chat(id, _, "!tNext map is still not determined!");
			return 1;
		}
		
		cprint_chat(id, _, "Next map will be '%s'", g_szMaps[g_iNEXTMAP]);
		return 1;
	}
	
	if(equali(szString, "/currentmap") || equali(szString, "currentmap"))
	{
		new szMapname[MAX_MAP_NAME_SIZE];
		get_mapname(szMapname, charsmax(szMapname));
		cprint_chat(id, _, "!tCurrent map: !g'%s'", szMapname);
		return 1;
	}
	return 0;
}

public start_thetask()
{
	fTIMER = get_pcvar_float(mp_timelimit) * 60.0;
	
	if(fTIMER > 0.0)
	{
		fTIMELEFT = fTIMER + get_gametime();
		set_task(fTIMER, "prepare_votemenu", TASK_VOTEMAP_TIMER);
		set_pcvar_num(mp_timelimit, 0);
	}
}

public plugin_end()
{
	if(get_pcvar_float(mp_timelimit) == 0.0) set_pcvar_float(mp_timelimit, fTIMER / 60.0);
	if(g_maps_array != Invalid_Array) ArrayDestroy(g_maps_array);
	if(VOTEMAP_MENU != INVALID_HANDLE)
	{
		menu_destroy(VOTEMAP_MENU);
		VOTEMAP_MENU = INVALID_HANDLE;
	}

	new szMapname[MAX_MAP_NAME_SIZE];

	new pVault = nvault_open(NVAULT_RECENT_MAPS_FILE_NAME);

	for(new i = g_iRecentMaps, szNum[4], iTimestamp; i >= 1; i--)
	{
		num_to_str(i, szNum, charsmax(szNum));
		nvault_lookup(pVault, szNum, szMapname, charsmax(szMapname), iTimestamp);
		num_to_str(i + 1, szNum, charsmax(szNum));
		nvault_set(pVault, szNum, szMapname);
	}

	get_mapname(szMapname, charsmax(szMapname));
	nvault_set(pVault, "1", szMapname);

	nvault_close(pVault);
}

public prepare_votemenu()
{
	new Array:temp_array = ArrayClone(g_maps_array), szMapname[MAX_MAP_NAME_SIZE], i;

	for(new j, iRecentMapsDeleted = 0, tempArraySize = ArraySize(temp_array); i < tempArraySize; i++)
	{
		ArrayGetString(temp_array, i, szMapname, charsmax(szMapname));
		for(j = 0; j < g_iRecentMaps; j++)
		{
			if(equal(szMapname, g_szRecentMaps[j]))
			{
				ArrayDeleteItem(temp_array, i--);
				tempArraySize--;
				iRecentMapsDeleted ++;
				break;
			}
		}

		if(iRecentMapsDeleted >= g_iRecentMaps)
		{
			break;
		}
	}

	i = max((MAX_MAPS_PER_VOTE - ArraySize(temp_array)), 0);

	for(new j, temp_size; i < MAX_MAPS_PER_VOTE; i++)
	{
		temp_size = ArraySize(temp_array);
		
		if(g_iNoms_num > 0)
		{
			g_iNoms_num--;
			ArrayGetString(g_maps_array, g_iNoms[0][g_iNoms_num], g_szMaps[i], charsmax(g_szMaps[]));
			
			for(j = 0; j < temp_size; j++)
			{
				ArrayGetString(temp_array, j, szMapname, charsmax(szMapname));
				if(equal(szMapname, g_szMaps[i]))
				{
					ArrayDeleteItem(temp_array, j);
					break;
				}
			}
			
			continue;
		}
		
		ArrayGetString(temp_array, (j=random(temp_size)), g_szMaps[i], charsmax(g_szMaps[]));
		ArrayDeleteItem(temp_array, j);
	}
	ArrayDestroy(temp_array);
	
	jb_logmessage("votemap has started!");
	const SizeOfSounds = sizeof MAP_VOTING_ANNOUNCE_SOUNDS;
	client_cmd(0, "spk ^"%s^"", MAP_VOTING_ANNOUNCE_SOUNDS[random(SizeOfSounds)]);
	g_bHasVoteMenu = 0xFFFFFFFF;
	g_iCounter = max(get_pcvar_num(g_cvar_timer),5);
	create_votemap_menu();
	set_task(1.0, "task_votemap_timer_end", TASK_VOTEMAP_TIMER_END, _, _, "b");
}

create_votemap_menu()
{
	new oldmenuID = VOTEMAP_MENU;
	
	new szText[128];
	formatex(szText, charsmax(szText), "\wVote for the \rnext map! ^n \y[ \r%d \y] \wSeconds remaning!", g_iCounter);
	VOTEMAP_MENU = menu_create(szText, "voting_handle");
	
	new iPercent[MAX_MAPS_PER_VOTE+1];
	for(new i = max((MAX_MAPS_PER_VOTE - ArraySize(g_maps_array)), 0); i <= MAX_MAPS_PER_VOTE; i++)
	{
		iPercent[i] = floatround((float(g_iVotes[i]) / floatmax(float(g_iVoters),1.0)) * 100.0);
	}
	
	for(new iLen, i = max((MAX_MAPS_PER_VOTE - ArraySize(g_maps_array)), 0); i < MAX_MAPS_PER_VOTE; i++)
	{
		iLen = formatex(szText, charsmax(szText), "\y%s     \w( \y[\r%d%%\y] \r%d Votes \w)", g_szMaps[i], iPercent[i], g_iVotes[i]);

		if(i == (MAX_MAPS_PER_VOTE-1))
		{
			iLen += formatex(szText[iLen], charsmax(szText) - iLen, "^n ");
		}

		menu_additem(VOTEMAP_MENU, szText);
	}

	formatex(szText, charsmax(szText), "Extend the current map by %d minutes^n\w( \y[\r%d%%\y] \r%d Votes \w)", max(get_pcvar_num(g_pcvar_mapextendtime), 1), iPercent[MAX_MAPS_PER_VOTE], g_iVotes[MAX_MAPS_PER_VOTE] );
	menu_additem(VOTEMAP_MENU, szText);
	
	new iMaxMapsPerVote = MAX_MAPS_PER_VOTE; // to get rid of the warning, etc....
	if(iMaxMapsPerVote <= 9)
	{
		menu_setprop(VOTEMAP_MENU, MPROP_PERPAGE, 0);
	}
	
	new players[32], pnum, id;
	get_players(players, pnum, "ch");
	
	while ( pnum-- > 0 )
	{
		id = players[ pnum ];
		if(check_flag(g_bHasVoteMenu, id))
		{
			menu_cancel(id);
			set_flag(g_bHasVoteMenu, id);
			menu_display(id, VOTEMAP_MENU);
		}
	}

	if(oldmenuID != INVALID_HANDLE)
	{
		menu_destroy(oldmenuID);
		oldmenuID = INVALID_HANDLE;
	}
}

public task_votemap_timer_end(taskid)
{
	new players[32], pnum, id, NULL, nMenu;
	get_players(players, pnum, "ch");
	
	while ( pnum-- > 0 )
	{
		id = players[ pnum ];
		if(player_menu_info(id, NULL, nMenu, NULL) > 0 &&  VOTEMAP_MENU == nMenu)
		{
			menu_cancel(id);
			show_menu(id, 0, " ^n ", 1);
			set_flag(g_bHasVoteMenu, id);
		}
	}
	
	if(g_iCounter == 0)
	{
		if(VOTEMAP_MENU != INVALID_HANDLE)
		{
			get_players(players, pnum, "ch");

			for(new i, iPlayer, iMenu, iNewMenu, iPage; i < pnum; i++)
			{
				iPlayer = players[i];
				if(player_menu_info(iPlayer, iMenu, iNewMenu, iPage) && iNewMenu == VOTEMAP_MENU)
				{
					menu_cancel( iPlayer );
					show_menu( iPlayer, 0, "^n", 1 );
				}
			}

			menu_destroy(VOTEMAP_MENU);
			VOTEMAP_MENU = INVALID_HANDLE;
		}
		
		remove_task(taskid);
		
		new iMaxMaps = ArraySize(g_maps_array), nextmap = max((MAX_MAPS_PER_VOTE - iMaxMaps), 0);
		
		for(new i = max((MAX_MAPS_PER_VOTE - iMaxMaps), 0) + 1; i <= MAX_MAPS_PER_VOTE; i++)
		{
			if(g_iVotes[i] > g_iVotes[nextmap])
			{
				nextmap = i;
			}
		}
		
		if(!g_iVotes[nextmap]) // invalid next map choose random.
		{
			nextmap = random_num(max((MAX_MAPS_PER_VOTE - iMaxMaps), 0), (MAX_MAPS_PER_VOTE - 1));
		}

		new szCurrentMap[MAX_MAP_NAME_SIZE];
		get_mapname(szCurrentMap, charsmax(szCurrentMap));
		if(equal(g_szMaps[nextmap], szCurrentMap))
		{
			g_iVoters = g_iNoms_num = 0;
			arrayset(g_iVotes, 0, sizeof g_iVotes);
			arrayset(RockedTheVote, 0, sizeof RockedTheVote);
			arrayset(g_iNoms[0], 0, sizeof g_iNoms[]);
			arrayset(g_iNoms[1], 0, sizeof g_iNoms[]);

			new iExtendedTimeInMinutes = max(get_pcvar_num(g_pcvar_mapextendtime), 1);
			fTIMELEFT = float(iExtendedTimeInMinutes * 60) + get_gametime();
			set_task(float(iExtendedTimeInMinutes * 60), "prepare_votemenu", TASK_VOTEMAP_TIMER);
			cprint_chat(0, _, "!tThe votemap has ended!");
			cprint_chat(0, _, "!tExtending the currentmap by '%d' minute%s!", iExtendedTimeInMinutes, (iExtendedTimeInMinutes == 1) ? "":"s");
			jb_logmessage("votemap has ended, extending the currentmap by '%d' minute%s!", iExtendedTimeInMinutes, (iExtendedTimeInMinutes == 1) ? "":"s");
			return;
		}
		
		g_iNEXTMAP = nextmap;
		cprint_chat(0, _, "!tThe votemap has ended!");
		if(g_iVoters > 0 ) cprint_chat(0, _, "!g%s !yhas won with a total of !g%d !tvotes !y(!g%d%%%% of the votes!y).", g_szMaps[nextmap], g_iVotes[nextmap], floatround((float(g_iVotes[nextmap]) / floatmax(float(g_iVoters),1.0)) * 100.0));
		cprint_chat(0, _, "The map will be changed to !g%s !ton the start of the new round.", g_szMaps[nextmap]);

		jb_logmessage("votemap has ended '%s' '%d'", g_szMaps[g_iNEXTMAP], g_iVotes[nextmap]);
		return;
	}
	
	// audio countdown
	if(get_pcvar_num(g_pcvar_countdown) > 0)
	{
		new word[ 10 ];
		num_to_word( g_iCounter, word, 9 );

		const VOICE_MALE = 1;
		static iVoiceGender = 0; if(!iVoiceGender) iVoiceGender = random_num(1, 2);
		client_cmd( 0, "spk ^"%s/%s^"", iVoiceGender == VOICE_MALE ? "vox":"fvox", word );
	}

	g_iCounter--;
	create_votemap_menu();
}

public jb_round_end()
{
	if(g_iNEXTMAP != -1)
	{
		static bool:bMapChanging = false;

		if(bMapChanging)
		{
			return;
		}

		bMapChanging = true;

		client_cmd(0, "spk ^"loading environment on to your computer^"");
		set_task(5.0, "task_changelevel");
	}
}

public task_changelevel()
{
	if( g_iNEXTMAP > -1 )
	{
		server_cmd("changelevel %s", g_szMaps[g_iNEXTMAP]);
	}

	g_iNEXTMAP = -1;
}

public voting_handle(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		if( menu == VOTEMAP_MENU )
		{
			remove_flag(g_bHasVoteMenu,id);
		}
		return PLUGIN_HANDLED;
	}

	static bool:user_voted[MAX_PLAYERS+1] = { false, false, ... };

	if(!g_iVoters)
	{
		arrayset(user_voted, false, sizeof user_voted);
	}
	
	if(!user_voted[id])
	{
		item += max((MAX_MAPS_PER_VOTE - ArraySize(g_maps_array)), 0);

		new szName[32];
		get_user_name(id, szName, charsmax(szName));
		
		g_iVotes[item] ++;
		g_iVoters++;
		
		user_voted[id] = true;
		
		cprint_chat(0, _, "!g#%s !yhas voted for !t%s", szName, g_szMaps[item]);
		
		new szText[128];
		formatex(szText, charsmax(szText), "has voted for '%s' to be the nextmap", g_szMaps[item]);
		jb_logmessage_action(szText, id);
		
		// updating the menu;
		create_votemap_menu();
	}
	else if(VOTEMAP_MENU != -1)
	{
		menu_display(id, VOTEMAP_MENU);
	}
	else { // VOTEMAP_MENU does not exist ?
		new temp = g_bHasVoteMenu;
		// updating the menu;
		create_votemap_menu();
		g_bHasVoteMenu = temp;
	}
	
	return PLUGIN_HANDLED;
}

#if AMXX_VERSION_NUM > 182
public client_disconnected(id)
#else
public client_disconnect(id)
#endif
{
	if( g_iNoms_num > 0 )
	{
		for(new nominator, i; i < g_iNoms_num; i++)
		{
			nominator = g_iNoms[1][i];

			if(id == nominator)
			{
				new szString[64], szName[32];
				ArrayGetString(g_maps_array, g_iNoms[0][i], szString, charsmax(szString));
				get_user_name(id, szName, charsmax(szName));

				cprint_chat(0, _, "%s has innominate the map '%s' its no longer in the nomination list !", szName, szString);

				g_iNoms_num--;
				g_iNoms[0][i] = g_iNoms[0][g_iNoms_num];
				g_iNoms[1][i] = g_iNoms[1][g_iNoms_num];

				break;
			}
		}
	}
}

#if AMXX_VERSION_NUM <= 182
Array:ArrayClone(Array:which)
{
	new Array:Return = ArrayCreate(MAX_MAP_NAME_SIZE,1);
	
	for(new i, maxloop = ArraySize(which), szString[MAX_MAP_NAME_SIZE]; i < maxloop; i++)
	{
		ArrayGetString(which, i, szString, MAX_MAP_NAME_SIZE-1);
		ArrayPushString(Return, szString);
	}
	
	return Return;
}
#endif

