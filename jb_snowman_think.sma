/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <fakemeta>
#include <engine>
#include <xs>
#include <hamsandwich>
#include <jailbreak_core>
#include <npc_library>

#define PLUGIN "[JB] Snowman Brain"
#define AUTHOR "Natsheh"

#define SNOWFLAKE_ID 45672
#define PEV_SNOWFLAKE_LIFE pev_fuser4

enum(+=1)
{
	SNOWMAN_PHASE_FINAL = 0,
	SNOWMAN_PHASE_MID,
	SNOWMAN_PHASE_INIT
}

enum any:CVARS_SNOWMAN
{
	CVAR_SNOWMAN_ATTACK_DAMAGE,
	CVAR_SNOWMAN_TRACE_ATTACK,
	CVAR_SNOWMAN_ATTACK_DELAY
}

new const NPC_CLAWS_MISS_SOUNDS[][] = {
	"zombie/claw_miss1.wav",
	"zombie/claw_miss2.wav"
}

new const NPC_CLAWS_STRIKE_SOUNDS[][] = {
	"zombie/claw_strike1.wav",
	"zombie/claw_strike2.wav",
	"zombie/claw_strike3.wav"
}

new const SNOWMAN_CLASSNAME[] = "snowman";
new const SNOWFLAKE_CLASSNAME[] = "snow_splash";

#if !defined IsPlayer
#define IsPlayer(%1) (1 <= %1 <= 32)
#endif

new SNOWMAN_MODEL[64] = "models/jailbreak/snowman.mdl",
	Array:g_animArrays[NPC_ACTIVITY], g_sizeAnimArrays[NPC_ACTIVITY],
	g_cvar_snowball_snowman_create, g_iCvars[CVARS_SNOWMAN], g_iSNOWMAN_ModelIndex;

public plugin_end()
{
	NPC_FREE_HOOKS(SNOWMAN_CLASSNAME);
	MDL_STUDIO_FREE_DATA(g_animArrays, g_sizeAnimArrays);
	MDL_STUDIO_DESTROY_HOOKS(engfunc(EngFunc_ModelIndex, SNOWMAN_MODEL));
}

public plugin_precache()
{
	for(new i; i < sizeof NPC_CLAWS_STRIKE_SOUNDS; i++)
	{
		PRECACHE_SOUND(NPC_CLAWS_STRIKE_SOUNDS[i]);
	}

	for(new i; i < sizeof NPC_CLAWS_MISS_SOUNDS; i++)
	{
		PRECACHE_SOUND(NPC_CLAWS_MISS_SOUNDS[i]);
	}

	jb_ini_get_keyvalue("SNOWBALL_DAY", "SNOWMAN", SNOWMAN_MODEL, charsmax(SNOWMAN_MODEL));
	g_iSNOWMAN_ModelIndex = PRECACHE_WORLD_ITEM_I(SNOWMAN_MODEL);
}

public plugin_init()
{
	new PluginID = register_plugin(PLUGIN, VERSION, AUTHOR);

	g_cvar_snowball_snowman_create = register_cvar("jb_day_snowball_snowman_creation", "5");
	g_iCvars[CVAR_SNOWMAN_ATTACK_DAMAGE] = register_cvar("jb_snowman_attack_damage", "25");
	g_iCvars[CVAR_SNOWMAN_TRACE_ATTACK] = register_cvar("jb_snowman_traceattk", "100");
	g_iCvars[CVAR_SNOWMAN_ATTACK_DELAY] = register_cvar("jb_snowman_attack_delay", "1.0");

	MDL_STUDIO_LOAD_ANIMATIONS(SNOWMAN_MODEL, g_animArrays, g_sizeAnimArrays);
	MDL_STUDIO_HOOK_EVENT(engfunc(EngFunc_ModelIndex, SNOWMAN_MODEL), "task_npc_event");

	NPC_Hook_Event(SNOWMAN_CLASSNAME, NPC_EVENT_TAKEDAMAGE, "snowman_takedmg", PluginID);
	NPC_Hook_Event(SNOWMAN_CLASSNAME, NPC_EVENT_DEATH, "snowman_killed", PluginID);

	register_think(SNOWMAN_CLASSNAME, "snowman_thinks");
	register_think(SNOWFLAKE_CLASSNAME, "snowflakes_think");
}

public snowman_killed(id, killer, gibs)
{
	new szClass[32];
	pev(id, PEV_WEAPON_INFLICTOR, szClass, charsmax(szClass));
	Initiate_NPC_DEATHMSG(id, killer, false, szClass);

	set_rendering(id, .fx=kRenderFxFadeSlow, .r=255, .g=255, .b=255, .render=kRenderGlow, .amount=50);
}

public snowman_takedmg(id, inflictor, attacker, Float:fDamage, damagebits)
{
	if(damagebits & DMG_FREEZE)
	{
		static Float:fHealth;
		pev(id, pev_health, fHealth);
		set_pev(id, pev_health, fHealth + fDamage);
	}
}

public snowman_thinks(id)
{
	if(!pev_valid(id)) return;

	static Float:fGtime, Float:fViewOffset[3], Float:fVelocity[3], Float:fNPCViewAngles[3], Float:fOrigin[3],
		Float:fTraceAttackOrigin[3], iOwner, Float:fNPCspeed = 250.0, Float:fMAX_SIZE[3], Float:fMIN_SIZE[3],
		Float:fNPCJspeed = 380.0, iTask;

	fGtime = get_gametime();
	iTask = pev(id, PEV_TASK);
	pev(id, pev_velocity, fVelocity);
	pev(id, pev_angles, fNPCViewAngles);
	pev(id, pev_origin, fOrigin);
	pev(id, pev_view_ofs, fViewOffset);
	pev(id, pev_maxs, fMAX_SIZE);
	pev(id, pev_mins, fMIN_SIZE);
	iOwner = pev(id, pev_owner);
	xs_vec_add(fOrigin, fViewOffset, fTraceAttackOrigin);

	switch( iTask )
	{
		case NPC_KILLSELF:
		{
			set_pev(id, pev_flags, FL_KILLME);
			dllfunc(DLLFunc_Think, id);
		}
		case NPC_DEATH:
		{
			set_pev(id, pev_deadflag, DEAD_DYING);
			set_pev(id, pev_solid, SOLID_NOT);
			set_pev(id, pev_movetype, MOVETYPE_TOSS);
			set_pev(id, pev_takedamage, DAMAGE_NO);
			set_pev(id, PEV_TASK, NPC_KILLSELF);

			NPC_animation(id, g_animArrays, g_sizeAnimArrays);

			set_pev(id, pev_nextthink, fGtime + NPC_KILLSELF_THINK_LEN);
		}
		case NPC_IDLE:
		{
			NPC_animation(id, g_animArrays, g_sizeAnimArrays);
			set_pev(id, pev_nextthink, fGtime + NPC_THINK_LEN);
		}
		case NPC_SEEK_TARGET:
		{
			static ent, iTarget, Float:fMaxDistance, Float:fDist, Float:fOriginDest[3];
			ent = iTarget = 0;
			fMaxDistance = 1000.0;

			while( (ent=find_ent_in_sphere(ent, fTraceAttackOrigin, fMaxDistance)) > 0)
			{
				if( ent != iOwner &&
					IsPlayer(ent) &&
					entity_takedamage_type(ent) != DAMAGE_NO &&
					IsEntityVisible(fTraceAttackOrigin, fOriginDest, ent, id) &&
					fMaxDistance > (fDist = get_distance_f(fTraceAttackOrigin,fOriginDest)) )
				{
					fMaxDistance = fDist;
					iTarget = ent;
				}
			}

			static Float:fRoamingDelay, Float:fTeleportDelay;
			pev(id, PEV_NPC_ACTION_DELAY, fRoamingDelay);
			pev(id, PEV_TELEPORTING_COOLDOWN, fTeleportDelay);

			if(iTarget) // We Found a target? engage !
			{
				set_pev(id, PEV_TARGET_LAST_TIME_SEEN, fGtime);
				set_pev(id, PEV_PREVIOUS_TASK, NPC_SEEK_TARGET);
				set_pev(id, NPC_TARGET, iTarget);
				set_pev(id, PEV_TASK, NPC_ATTACK);
			}
			else if( fRoamingDelay < fGtime ) // lets roam and find us a target.
			{
				static i, Float:vfTemp[3] = { 0.0, 0.0, 0.0 }, Float:fChosenAngle, Float:fCurrAngle;
				fMaxDistance = fChosenAngle = 0.0; // 1k unit should be enf for us to find the longest path.
				fOriginDest[2] = fTraceAttackOrigin[2];

				for ( i = 0, fCurrAngle = -45.0;  i < 3; i ++ )
				{
					fDist = 9999.0;
					xs_vec_set(vfTemp, 0.0, fNPCViewAngles[1] + fCurrAngle, 0.0);
					angle_vector(vfTemp, ANGLEVECTOR_FORWARD, vfTemp);
					xs_vec_mul_scalar(vfTemp, fDist, vfTemp);

					fOriginDest[0] = fOrigin[0] + vfTemp[0];
					fOriginDest[1] = fOrigin[1] + vfTemp[1];
					NPC_traceattack(id, fTraceAttackOrigin, fOriginDest, fDist, .HullType=HULL_HUMAN);

					if(fDist > fMaxDistance)
					{
						fMaxDistance = fDist;
						fChosenAngle = fNPCViewAngles[1] + fCurrAngle;
					}

					fCurrAngle += 45.0;
				}

				if( fMaxDistance > ((xs_vec_len(fMAX_SIZE) + xs_vec_len(fMIN_SIZE)) * 0.5) )
				{
					vfTemp[ 0 ] = vfTemp[ 2 ] = 0.0;
					vfTemp[ 1 ] = fChosenAngle;
					angle_vector(vfTemp, ANGLEVECTOR_FORWARD, vfTemp);
					xs_vec_mul_scalar(vfTemp, fMaxDistance, vfTemp);
					fOriginDest[0] = fOrigin[0] + vfTemp[0];
					fOriginDest[1] = fOrigin[1] + vfTemp[1];
					LookAtOrigin(id, fOriginDest);
					set_pev(id, PEV_NPC_ACTION_DELAY, fGtime + MoveToOrigin(id, fOriginDest, fNPCspeed, fNPCJspeed, fVelocity));
				}
				else // no way to go ? lets turn 45 degrees to the right.
				{
					xs_vec_set(vfTemp, 0.0, fNPCViewAngles[1] + 45.0, 0.0);
					angle_vector(vfTemp, ANGLEVECTOR_FORWARD, vfTemp);
					fOriginDest[0] = fOrigin[0] + vfTemp[0];
					fOriginDest[1] = fOrigin[1] + vfTemp[1];
					LookAtOrigin(id, fOriginDest);
					set_pev(id, PEV_NPC_ACTION_DELAY, fGtime + 0.5); // turning right takes time.
				}
			}

			NPC_animation(id, g_animArrays, g_sizeAnimArrays);
			set_pev(id, pev_nextthink, fGtime + NPC_THINK_LEN);
		}
		case NPC_ATTACK:
		{
			static iVictim, Float:fHealth; fHealth = 0.0;
			if(pev_valid((iVictim = pev(id, NPC_TARGET))))
			{
				pev(iVictim, pev_health, fHealth);
			}

			if(fHealth > 0.0 && entity_takedamage_type(iVictim) != DAMAGE_NO)
			{
				static Float:fOriginDest[3], Float:fDelay = -1.0, Float:fVicViewOfs[3], Float:fVicVelocity[3], Float:fTraceAttack;
				pev(iVictim, pev_origin, fOriginDest);
				pev(iVictim, pev_view_ofs, fVicViewOfs);
				fOriginDest[2] += fVicViewOfs[2];
				xs_vec_copy(fOriginDest, fVicVelocity);
				fTraceAttack = get_pcvar_float(g_iCvars[CVAR_SNOWMAN_TRACE_ATTACK]);

				pev(id, PEV_NPC_ACTION_DELAY, fDelay);

				// NPC has no visual of the target.
				if( !IsEntityVisible(fTraceAttackOrigin, fVicVelocity, iVictim, id) )
				{
					/* npc cannot see the target. */
					static Float:fLastSeen;
					pev(id, PEV_TARGET_LAST_TIME_SEEN, fLastSeen);
					if(fGtime > (fLastSeen + 3.0) && !IsEntityVisible(fTraceAttackOrigin, fVicVelocity, iVictim, id))
					{
						set_pev(id, NPC_TARGET, 0);
					}

					fDelay = -1.0;
					NPC_animation(id, g_animArrays, g_sizeAnimArrays);
				}
				else // Enemy is visible
				{
					set_pev(id, PEV_TARGET_LAST_TIME_SEEN, fGtime);

					static Float:fAttackDelay, Float:fVicSpeed, Float:fDirection[3];
					fAttackDelay = get_pcvar_float(g_iCvars[CVAR_SNOWMAN_ATTACK_DELAY]);
					if(fAttackDelay <= 0.0) fAttackDelay = 1.0;
					pev(iVictim, pev_velocity, fVicVelocity);

					if((fVicSpeed=xs_vec_len_2d(fVicVelocity)) > 0.0)
					{
						xs_vec_sub(fOriginDest, fTraceAttackOrigin, fDirection);
						xs_vec_normalize(fDirection, fDirection);
						xs_vec_normalize(fVicVelocity, fVicVelocity);
						fVicSpeed *= xs_vec_dot(fDirection, fVicVelocity);

						if(fVicSpeed < 0.0)
						{
							fVicSpeed *= -1.0;
						}
					}

					LookAtOrigin(id, fOriginDest);

					if((get_distance_f(fTraceAttackOrigin, fOriginDest) + (fVicSpeed * fAttackDelay)) <= fTraceAttack)
					{
						if(fDelay < fGtime)
						{
							fDelay = fGtime + fAttackDelay;

							if(g_sizeAnimArrays[ACT_MELEE_ATTACK1] > 0)
							{
								static xArray[ANIMATION_DATA], Float:fFrameRate;
								ArrayGetArray(Array:g_animArrays[ACT_MELEE_ATTACK1], random(g_sizeAnimArrays[ACT_MELEE_ATTACK1]), xArray);
								fFrameRate = ( xArray[ANIMATION_FRAMES] / xArray[ANIMATION_FPS] ) / fAttackDelay;
								PlayAnimation(id, xArray[ANIMATION_SEQUENCE],
					                xArray[ANIMATION_FPS], fFrameRate, xArray[ANIMATION_FRAMES], ACT_MELEE_ATTACK1,
					                .bInLOOP=false,
					                .pArrayEvent=Array:xArray[ANIMATION_EVENT_ARRAY],
					                .pArrayEventSize=xArray[ANIMATION_EVENTS]);
							}
						}
					}
					else // Target is out of range, order to go to.
					{
						xs_vec_sub(fOriginDest, fVicViewOfs, fOriginDest);

						MoveToOrigin(id, fOriginDest, fNPCspeed, fNPCJspeed, fVelocity);
						NPC_animation(id, g_animArrays, g_sizeAnimArrays);
						fDelay = -1.0;
					}
				}
				set_pev(id, PEV_NPC_ACTION_DELAY, fDelay);
			}
			else
			{
				if(!iVictim && pev(id, PEV_PREVIOUS_TASK) == NPC_FOLLOW_PLAYER)
				{
					set_pev(id, PEV_PREVIOUS_TASK, NPC_IDLE);
				}

				set_pev(id, PEV_TASK, pev(id, PEV_PREVIOUS_TASK));
				set_pev(id, NPC_TARGET, 0);
			}

			set_pev(id, pev_nextthink, fGtime + NPC_THINK_LEN);
		}
	}
}

public task_npc_event(const Params[ANIMATION_EVENTS_DATA], const id)
{
	switch( Params[EVENT_NUMBER] )
	{
		case 1, 2, 3:
		{
			if(NPC_MeleeAttack1(id, get_pcvar_float(g_iCvars[CVAR_SNOWMAN_ATTACK_DAMAGE]), get_pcvar_float(g_iCvars[CVAR_SNOWMAN_TRACE_ATTACK]), DMG_SLASH))
			{
				emit_sound(id, CHAN_BODY, NPC_CLAWS_STRIKE_SOUNDS[random(sizeof NPC_CLAWS_STRIKE_SOUNDS)], VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
			}
			else
			{
				emit_sound(id, CHAN_BODY, NPC_CLAWS_MISS_SOUNDS[random(sizeof NPC_CLAWS_MISS_SOUNDS)], VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
			}
		}
	}
}

public snowflakes_think(ent)
{
	if(!pev_valid(ent) || pev(ent, pev_flags) & FL_KILLME)
	{
		return;
	}

	new Float:fOrigin[3], snowflakes = 0, search_ent = -1, aBoxes[ 10 ], SnowmanSnowFlakesConsumption = min(get_pcvar_num(g_cvar_snowball_snowman_create),sizeof aBoxes), Float:fGameTime = get_gametime(), Float:fLife;
	pev(ent, pev_origin, fOrigin);
	pev(ent, PEV_SNOWFLAKE_LIFE, fLife);

	while((search_ent=find_ent_in_sphere(search_ent, fOrigin, 30.0)) > 0)
	{
		if(pev(search_ent, PEV_IDENTITY) != SNOWFLAKE_ID) continue;

		aBoxes[snowflakes++] = search_ent;
		set_pev(search_ent, PEV_SNOWFLAKE_LIFE, fLife);

		if(snowflakes >= SnowmanSnowFlakesConsumption)
		{
			break;
		}
	}

	if(snowflakes >= SnowmanSnowFlakesConsumption)
	{
		for(new i, snowflake; i < snowflakes; i++)
		{
			snowflake = aBoxes[i];
			set_pev(snowflake, pev_flags, FL_KILLME);
			dllfunc(DLLFunc_Think, snowflake);
		}

		new Snowman; search_ent = -1;
		while((search_ent=find_ent_in_sphere(search_ent, fOrigin, 100.0)) > 0)
		{
			if( pev(search_ent, pev_modelindex) != g_iSNOWMAN_ModelIndex || pev(search_ent, pev_body) == SNOWMAN_PHASE_FINAL)
			{
				continue;
			}

			Snowman = search_ent;
			break;
		}

		if( !Snowman )
		{
			create_snowman(.fOrigin=fOrigin, .iPhase=SNOWMAN_PHASE_INIT);
		}
		else
		{
			switch( pev(Snowman, pev_body) )
			{
				case SNOWMAN_PHASE_INIT: set_snowman_phase(Snowman, .iPhase=SNOWMAN_PHASE_MID);
				case SNOWMAN_PHASE_MID: set_snowman_phase(Snowman, .iPhase=SNOWMAN_PHASE_FINAL);
			}
		}
	}
}

set_snowman_phase(const ent, const iPhase)
{
	new iTr2 = create_tr2(), target, Float:fOrigin[3];
	pev(ent, pev_origin, fOrigin);

	switch( iPhase )
	{
		case SNOWMAN_PHASE_INIT:
		{
			fOrigin[2] += 40.0;
		}
		case SNOWMAN_PHASE_MID:
		{
			fOrigin[2] += 64.0;
		}
		case SNOWMAN_PHASE_FINAL:
		{
			fOrigin[2] += 72.0
		}
	}

	engfunc(EngFunc_TraceHull, fOrigin, fOrigin, IGNORE_MISSILE|DONT_IGNORE_MONSTERS, HULL_HEAD, ent, iTr2);

	target = get_tr2(iTr2, TR_pHit);

	if( pev_valid(target) || get_tr2(iTr2, TR_AllSolid) || !get_tr2(iTr2, TR_InOpen) || get_tr2(iTr2, TR_StartSolid) )
	{
		free_tr2(iTr2);
		return 0;
	}

	free_tr2(iTr2);

	new Float:fViewOffset[3];

	switch( iPhase )
	{
		case SNOWMAN_PHASE_INIT:
		{
			set_pev(ent, PEV_PREVIOUS_TASK, NPC_IDLE);
			xs_vec_set(fViewOffset, 0.0, 0.0, 50.0);
			set_pev(ent, pev_view_ofs, fViewOffset);
			engfunc(EngFunc_SetSize, ent, Float:{ -16.0, -16.0, -0.0}, Float:{ 16.0, 16.0, 50.0 });
			set_pev(ent, pev_health, 50.0);
			set_pev(ent, pev_flags, pev(ent, pev_flags) & ~FL_ALWAYSTHINK);
			set_pev(ent, pev_nextthink, get_gametime() + 999999.0);
		}
		case SNOWMAN_PHASE_MID:
		{
			xs_vec_set(fViewOffset, 0.0, 0.0, 64.0);
			set_pev(ent, pev_view_ofs, fViewOffset);
			engfunc(EngFunc_SetSize, ent, Float:{ -16.0, -16.0, -0.0}, Float:{ 16.0, 16.0, 68.0 });
			set_pev(ent, pev_health, 100.0);
		}
		case SNOWMAN_PHASE_FINAL:
		{
			set_pev(ent, PEV_PREVIOUS_TASK, NPC_SEEK_TARGET);
			set_pev(ent, PEV_TASK, NPC_SEEK_TARGET);
			xs_vec_set(fViewOffset, 0.0, 0.0, 72.0);
			set_pev(ent, pev_view_ofs, fViewOffset);
			engfunc(EngFunc_SetSize, ent, Float:{ -16.0, -16.0, -0.0}, Float:{ 16.0, 16.0, 80.0 });
			set_pev(ent, pev_health, 150.0);
			set_pev(ent, pev_flags, pev(ent, pev_flags) | FL_ALWAYSTHINK);
			set_pev(ent, pev_nextthink, get_gametime() + 1.0);
		}
	}

	set_pev(ent, pev_body, iPhase);
	return 1;
}

create_snowman(Float:fOrigin[3], iPhase=SNOWMAN_PHASE_INIT)
{
	new iTr2 = create_tr2(), target;
	fOrigin[2] += 40.0;
	engfunc(EngFunc_TraceHull, fOrigin, fOrigin, IGNORE_MISSILE|DONT_IGNORE_MONSTERS, HULL_HEAD, -1, iTr2);

	target = get_tr2(iTr2, TR_pHit);

	if( pev_valid(target) || get_tr2(iTr2, TR_AllSolid) || !get_tr2(iTr2, TR_InOpen) || get_tr2(iTr2, TR_StartSolid) )
	{
		free_tr2(iTr2);
		return 0;
	}

	free_tr2(iTr2);

	new Float:fMAX_SIZE[3], Float:fMIN_SIZE[3];
	NPC_SIZE(HUMAN_SIZE, fMAX_SIZE, fMIN_SIZE);

	new ent = NPC_SPAWN(  .class=SNOWMAN_CLASSNAME,
					.name="Snowy",
					.szModel=SNOWMAN_MODEL,
					.fOrigin=fOrigin,
					.fViewOFS=Float:{0.0,0.0,0.0},
					.fMaxSpeed=250.0,
					.fMaxHealth=50.0,
					.NPC_MOVETYPE=MOVETYPE_PUSHSTEP,
					.fMaxS=fMAX_SIZE, .fMinS=fMIN_SIZE
						 );

	set_snowman_phase(ent, iPhase);
	return 1;
}
