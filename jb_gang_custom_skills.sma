/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <jailbreak_core>
#include <jailbreak_gangs>
#include <fun>
#include <hamsandwich>
#include <fakemeta>
#include <nvault>

#define PLUGIN "[JB] Gang-CustomSkills"
#define AUTHOR "Natsheh"

#if AMXX_VERSION_NUM > 182
#define client_disconnect client_disconnected
#endif

#define USER_DEFAULT_GRAVITY 1.0
#define USER_DEFAULT_MAXSPEED 250.0

enum SKILLS_INFO(+=1)
{
	SKILL_NAME[32],
	SKILL_INFO[64],
	SKILL_UPGRADE_COST,
	SKILL_CVAR_MAXUPG[32],
	SKILL_MAX_UPGRADE,
	SKILL_CVAR_INCREMENT[32],
	SKILL_VALUE_INCREMENT
}

enum (+=1)
{
	SKILL_STAMINA = 0,
	SKILL_GRAVITY,
	SKILL_EVASION,
	SKILL_HEALTH,
	SKILL_DAMAGE,
	SKILL_DISARMAMENT
}

new gang_skills_info[][SKILLS_INFO] = {
	{ "Stamina", "Speed increment!", 100000, "STAMINA_MAXUPG", 25, "jb_gskill_incr_stamina", 15 }, // maxspeed
	{ "Gravity", "Gravity decrement!", 125000, "GRAVITY_MAXUPG", 25, "jb_gskill_decr_gravity", 10 }, // spawn
	{ "Evasion", "a Chance for evading attacks", 135000, "EVASION_MAXUPG", 25, "jb_gskill_incr_evasion", 1 }, // traceattack
	{ "Health", "Health increment!", 150000, "HP_MAXUPG", 25, "jb_gskill_incr_health", 2 }, // spawn
	{ "Damage", "Increase attack damage!", 165000, "DMG_MAXUPG", 25, "jb_gskill_incr_damage", 2 }, // traceattack
	{ "Disarmament", "a Chance for disarming an opponent on attack!", 75000, "DISARM_MAXUPG", 25, "jb_gskill_incr_disarmament", 1 } // traceattack
}

new g_item_pointer[sizeof gang_skills_info];
new g_maxupg_cvar_value[sizeof gang_skills_info];
new g_increment_cvar_pointer[sizeof gang_skills_info];
new g_user_skills[MAX_PLAYERS + 1][sizeof gang_skills_info];

const BITS_UNDROPPABLE_WEAPONS = (1<<CSW_KNIFE)|(1<<CSW_HEGRENADE)|(1<<CSW_FLASHBANG)|(1<<CSW_SMOKEGRENADE);
const m_pPlayer = 41;

new Evasion_snd[64], bool:eva_snd_on;
new disarm_snd[64], bool:disarm_snd_on;
new g_BitsUserAuthorized, g_BitsUserHasPutInServer;

new	HamHook:Ham_fw_TraceAttackPlayer,
	HamHook:Ham_fw_TakeDamagePlayer,
	HamHook:Ham_fw_SpawnPost,
	HamHook:Ham_fw_ItemGetMaxSpeed[CSW_P90+1];

public plugin_precache()
{
	jb_ini_get_keyvalue("GANG_SKILLS_CUSTOM", "EVASION_SND", Evasion_snd, charsmax(Evasion_snd));
	if(Evasion_snd[0] != EOS)
	{
		eva_snd_on = true;
		replace(Evasion_snd, charsmax(Evasion_snd), "sound/", ""); // Remove "sound/" Directory
		PRECACHE_SOUND(Evasion_snd);
	}
	
	jb_ini_get_keyvalue("GANG_SKILLS_CUSTOM", "DISARM_SND", disarm_snd, charsmax(disarm_snd));
	if(disarm_snd[0] != EOS)
	{
		disarm_snd_on = true;
		replace(disarm_snd, charsmax(disarm_snd), "sound/", ""); // Remove "sound/" Directory
		PRECACHE_SOUND(disarm_snd);
	}
}

public client_authorized(id)
{
	set_flag(g_BitsUserAuthorized, id);
}

public client_putinserver(id)
{
	if( check_flag(id, g_BitsUserHasPutInServer) )
	{
		return;
	}

	if( !check_flag(g_BitsUserAuthorized,id) )
	{
		set_task(1.0, "client_putinserver", id);
		return;
	}
	
	LoadPlayerGangSkills(id);
	set_flag(g_BitsUserHasPutInServer, id);
}

LoadPlayerGangSkills(id)
{
	if(jb_get_user_gang_status(id) == _:NOT_INGANG)
	{
		return;
	}

	new sGangname[32];
	jb_get_user_gang_name(id, sGangname, charsmax(sGangname));

	for(new x, maxloop = sizeof gang_skills_info; x < maxloop; x++)
	{
		g_user_skills[id][x] = jb_get_gang_current_upg_level(gang_skills_info[x][SKILL_NAME], sGangname);
	}
}

public client_disconnect(id)
{
	if( !check_flag(g_BitsUserAuthorized,id) || !check_flag(g_BitsUserHasPutInServer, id) )
	{
		return;
	}

	for(new x, maxloop = sizeof gang_skills_info; x < maxloop; x++)
	{
		g_user_skills[id][x] = 0;
	}

	remove_flag(g_BitsUserAuthorized, id);
	remove_flag(g_BitsUserHasPutInServer, id);
}

public jb_gang_user_left(const GangID, const GangName[], const UserAuthID[], const UserGangStatus)
{
	new id = find_player("c", UserAuthID);

	if(!id) return;

	if(g_user_skills[id][SKILL_GRAVITY] > 0)
	{
		set_user_gravity(id, 1.0);
	}
	
	if(g_user_skills[id][SKILL_STAMINA] > 0)
	{
		set_user_maxspeed(id, 250.0);
	}

	arrayset(g_user_skills[id], 0, sizeof g_user_skills[]);
}

public jb_gang_user_joined(const GangID, const GangName[], const UserAuthID[], const UserGangStatus)
{
	new id = find_player("c", UserAuthID);

	if(!id) return;

	for(new x, maxloop = sizeof gang_skills_info; x < maxloop; x++)
	{
		g_user_skills[id][x] = jb_get_gang_current_upg_level(gang_skills_info[x][SKILL_NAME], GangName);
	}

	if(g_user_skills[id][SKILL_GRAVITY] > 0)
	{
		set_user_gravity(id, (USER_DEFAULT_GRAVITY-((g_user_skills[id][SKILL_GRAVITY] * floatmax(get_pcvar_float(g_increment_cvar_pointer[SKILL_GRAVITY]),1.0))/floatmax(get_cvar_float("sv_gravity"),1.0))));
	}
	
	if(g_user_skills[id][SKILL_STAMINA] > 0)
	{
		set_user_maxspeed(id, (USER_DEFAULT_MAXSPEED + floatmax(get_pcvar_float(g_increment_cvar_pointer[SKILL_STAMINA]),1.0) * g_user_skills[id][SKILL_STAMINA]))
	}
}

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	for(new i, szString[128], szKey[32], szValue[16]; i < sizeof gang_skills_info; i++)
	{
		num_to_str(gang_skills_info[i][SKILL_MAX_UPGRADE], szString, charsmax(szString));
		jb_ini_get_keyvalue("GANG_SKILLS_CUSTOM", gang_skills_info[i][SKILL_CVAR_MAXUPG], szString, charsmax(szString));
		g_maxupg_cvar_value[i] = str_to_num(szString);
		
		num_to_str(gang_skills_info[i][SKILL_VALUE_INCREMENT], szString, charsmax(szString));
		g_increment_cvar_pointer[i] = register_cvar(gang_skills_info[i][SKILL_CVAR_INCREMENT], szString);
		
		formatex(szKey, charsmax(szKey), "%s_upgrade_cost", gang_skills_info[i][SKILL_NAME]);
		strtoupper(szKey);
		num_to_str(gang_skills_info[i][SKILL_UPGRADE_COST], szValue, charsmax(szValue));
		jb_ini_get_keyvalue("GANG_SKILLS_CUSTOM", szKey, szValue, charsmax(szValue));
		formatex(szString, charsmax(szString), "%s \r%s\y$", gang_skills_info[i][SKILL_INFO], szValue);
		gang_skills_info[i][SKILL_UPGRADE_COST] = str_to_num(szValue);
		
		g_item_pointer[i] = jb_register_gang_upgrade(gang_skills_info[i][SKILL_NAME], szString, g_maxupg_cvar_value[i], "upgrade_skill");
	}
	
	Ham_fw_TraceAttackPlayer = RegisterHam(Ham_TraceAttack, "player", "fw_player_traceattack_pre");
	Ham_fw_TakeDamagePlayer = RegisterHam(Ham_TakeDamage, "player", "fw_player_takedamage_pre");
	Ham_fw_SpawnPost = RegisterHam(Ham_Spawn, "player", "fw_player_spawn_post", 1);
	
	for(new i = CSW_P228, sWpname[32]; i <= CSW_P90; i++)
	{
		get_weaponname(i, sWpname, charsmax(sWpname));
		
		if(equal(sWpname, "weapon_",7))
		{
			Ham_fw_ItemGetMaxSpeed[i] = RegisterHam(Ham_CS_Item_GetMaxSpeed, sWpname, "fw_weapon_maxspeed_pre");
		}
	}
}

public jb_lr_duel_started(prisoner, guard, duelid)
{
	DisableSkillsEffects();
}

public jb_day_started(iDayid)
{
	DisableSkillsEffects();
}

DisableSkillsEffects()
{
	DisableHamForward(Ham_fw_TraceAttackPlayer);
	DisableHamForward(Ham_fw_TakeDamagePlayer);
	DisableHamForward(Ham_fw_SpawnPost);

	for(new i = CSW_P228, sWpname[32]; i <= CSW_P90; i++)
	{
		get_weaponname(i, sWpname, charsmax(sWpname));
		if(equal(sWpname, "weapon_",7))
		{
			DisableHamForward(Ham_fw_ItemGetMaxSpeed[i]);
		}
	}
}

EnableSkillsEffects()
{
	EnableHamForward(Ham_fw_TraceAttackPlayer);
	EnableHamForward(Ham_fw_TakeDamagePlayer);
	EnableHamForward(Ham_fw_SpawnPost);

	for(new i = CSW_P228, sWpname[32]; i <= CSW_P90; i++)
	{
		get_weaponname(i, sWpname, charsmax(sWpname));
		if(equal(sWpname, "weapon_",7))
		{
			EnableHamForward(Ham_fw_ItemGetMaxSpeed[i]);
		}
	}
}

public jb_lr_duel_ended(prisoner, guard, duelid)
{
	EnableSkillsEffects();
}

public jb_day_ended()
{
	EnableSkillsEffects();
}

public fw_player_takedamage_pre(vic, inflictor, attacker, Float:damage, dmgbits)
{
	if(is_user_connected(attacker))
	{
		if(g_user_skills[attacker][SKILL_DAMAGE] > 0 && damage > 0.0)
		{
			SetHamParamFloat(4, damage + g_user_skills[attacker][SKILL_DAMAGE] * get_pcvar_float(g_increment_cvar_pointer[SKILL_DAMAGE]));
			return HAM_IGNORED;
		}
	}
	
	return HAM_IGNORED;
}

public fw_player_traceattack_pre(vic, attacker, Float:damage, Float:direction[3], traceresult, damagebits)
{
	if(g_user_skills[vic][SKILL_EVASION] > 0)
	{
		new xRandom[100];
		for(new i, maxloop = clamp(g_user_skills[vic][SKILL_EVASION] * get_pcvar_num(g_increment_cvar_pointer[SKILL_EVASION]), 1, 100); i < maxloop; i++)
		{
			xRandom[random(sizeof xRandom)] = 1;
		}
		
		if(xRandom[random(sizeof xRandom)] == 1)
		{
			if(eva_snd_on)
			{
				emit_sound(vic, CHAN_AUTO, Evasion_snd, VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
			}
			
			new Float:fEnd[3];
			get_tr2(traceresult, TR_vecEndPos, fEnd);
			
			engfunc(EngFunc_MessageBegin, MSG_PVS, SVC_TEMPENTITY, fEnd, 0);
			write_byte(TE_SPARKS);
			engfunc(EngFunc_WriteCoord, fEnd[0]);
			engfunc(EngFunc_WriteCoord, fEnd[1]);
			engfunc(EngFunc_WriteCoord, fEnd[2]);
			message_end();
			
			SetHamParamFloat(3, 0.0);
			return HAM_SUPERCEDE;
		}
	}
	
	if(is_user_connected(attacker))
	{
		if(g_user_skills[attacker][SKILL_DISARMAMENT] > 0)
		{
			if(get_tr2(traceresult, TR_iHitgroup) != HIT_LEFTARM &&
			   get_tr2(traceresult, TR_iHitgroup) != HIT_RIGHTARM) return HAM_IGNORED;
			
			if((1<<get_user_weapon(vic)) & BITS_UNDROPPABLE_WEAPONS) return HAM_IGNORED;
			
			new xRandom[100];
			for(new i, maxloop = clamp(g_user_skills[attacker][SKILL_DISARMAMENT] * get_pcvar_num(g_increment_cvar_pointer[SKILL_DISARMAMENT]), 1, 100); i < maxloop; i++)
			{
				xRandom[random(sizeof xRandom)] = 1;
			}
			
			if(xRandom[random(sizeof xRandom)] == 1)
			{
				new wpnid = get_user_weapon(vic);
				if(!wpnid || wpnid == CSW_KNIFE ||
					     wpnid == CSW_HEGRENADE ||
					     wpnid == CSW_FLASHBANG ||
					     wpnid == CSW_SMOKEGRENADE) return HAM_IGNORED;
				
				if(disarm_snd_on)
				{
					emit_sound(vic, CHAN_AUTO, disarm_snd, VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
				}
				
				new Float:fEnd[3];
				get_tr2(traceresult, TR_vecEndPos, fEnd);
				
				message_begin(MSG_PVS, SVC_TEMPENTITY);
				write_byte(TE_SPARKS);
				engfunc(EngFunc_WriteCoord, fEnd[0]);
				engfunc(EngFunc_WriteCoord, fEnd[1]);
				engfunc(EngFunc_WriteCoord, fEnd[2]);
				message_end();
				
				new szWeaponname[32];
				get_weaponname(wpnid, szWeaponname, charsmax(szWeaponname))
				engclient_cmd(vic, "drop", szWeaponname);
				SetHamParamFloat(3, 0.0);
				return HAM_SUPERCEDE;
			}
		}
	}
	return HAM_IGNORED;
}

public fw_player_spawn_post(const player)
{
	if(!is_user_alive(player)) return;
	
	if(g_user_skills[player][SKILL_HEALTH] > 0)
	{
		new maxhealth = get_user_health(player) + g_user_skills[player][SKILL_HEALTH] * clamp(get_pcvar_num(g_increment_cvar_pointer[SKILL_HEALTH]),1,999999);
		set_user_health(player, maxhealth);
		set_pev(player, pev_max_health, float(maxhealth));
	}
	
	if(g_user_skills[player][SKILL_GRAVITY] > 0)
	{
		set_user_gravity(player,
		(get_user_gravity(player)-(g_user_skills[player][SKILL_GRAVITY] * max(get_pcvar_num(g_increment_cvar_pointer[SKILL_GRAVITY]), 1))/floatmax(get_cvar_float("sv_gravity"),1.0)));
	}
}

public fw_weapon_maxspeed_pre(const ent)
{
	new x, id = get_pdata_cbase(ent, m_pPlayer, 4);
	if(id && id <= MAX_PLAYERS && (x=g_user_skills[id][SKILL_STAMINA]) > 0)
	{
		new Float:fSpeed;
		ExecuteHam(Ham_CS_Item_GetMaxSpeed, ent, fSpeed);
		SetHamReturnFloat( (fSpeed + x * floatmax(get_pcvar_float(g_increment_cvar_pointer[SKILL_STAMINA]),1.0)) );
		return HAM_SUPERCEDE;
	}
	
	return HAM_IGNORED;
}

public upgrade_skill( const id, const gangid, const gangname[], const CurrentUpgrade, const maxupgrade, const itemid )
{
	for(new x, maxloop = sizeof gang_skills_info; x < maxloop; x++)
	{
		if(itemid == g_item_pointer[x])
		{
			if(CurrentUpgrade >= maxupgrade)
			{
				cprint_chat(id, _, "Max upgrades have been reached %d/%d", maxupgrade, maxupgrade);
				return PLUGIN_HANDLED;
			}
			
			new z;
			if((z=jb_get_user_cash(id)) < gang_skills_info[x][SKILL_UPGRADE_COST])
			{
				client_print(id, print_center, "Insufficient funds!");
				return PLUGIN_HANDLED;
			}
			
			jb_set_user_cash(id, z - gang_skills_info[x][SKILL_UPGRADE_COST]);
			
			new sName[32];
			get_user_name(id, sName, charsmax(sName));
			
			cprint_chat(0, _, "!t~( !g%s !t)~ !g%s !yhas upgraded his !t%s !ygang skill to !g%d!t/!g%d", gangname, sName, gang_skills_info[x][SKILL_NAME], CurrentUpgrade + 1, maxupgrade);
			
			g_user_skills[id][x] ++;
			update_gangs_members();
			
			return PLUGIN_CONTINUE;
		}
	}
	
	return PLUGIN_CONTINUE;
}

update_gangs_members()
{
	new players[32], pnum,
	Float:fGravity = floatmax(get_cvar_float("sv_gravity"), 1.0),
	Float:fGravityLevelIncrement = floatmax(get_pcvar_float(g_increment_cvar_pointer[SKILL_GRAVITY]), 1.0),
	Float:fStaminaLevelIncrement = floatmax(get_pcvar_float(g_increment_cvar_pointer[SKILL_STAMINA]), 1.0);
	get_players(players, pnum, "h");
	
	for(new i, player; i < pnum; i++)
	{
		player = players[i];
		
		LoadPlayerGangSkills(player);
		
		if(is_user_alive(player))
		{
			if(g_user_skills[player][SKILL_GRAVITY] > 0)
			{
				set_user_gravity(player, (USER_DEFAULT_GRAVITY - ((g_user_skills[player][SKILL_GRAVITY] * fGravityLevelIncrement) / fGravity)));
			}
			
			if(g_user_skills[player][SKILL_STAMINA] > 0)
			{
				set_user_maxspeed(player, (USER_DEFAULT_MAXSPEED + fStaminaLevelIncrement * g_user_skills[player][SKILL_STAMINA]));
			}
		}
	}
}
