/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <fakemeta>
#include <cstrike>
#include <jailbreak_core>
#include <hamsandwich>
#include <xs>
#include <engine>
#include <fun>
#include <npc_library>

#if AMXX_VERSION_NUM <= 182
#include <dhudmessage>
#endif

native npc_spawn_revenant_boss();
native npc_despawn_revenant_boss();

enum any:FallTypes (+=1)
{
	FALL_TYPE_NONE = 0,
	FALL_TYPE_PARACHUTE,
	FALL_TYPE_DROP,
	FALL_TYPE_BOUNCE
}

native mybox_get_locations_count();
native mybox_place_mysterybox_spawner(const Float:fOrigin[3], const Float:fAngles[3], const FallTypes:iFallType = FALL_TYPE_NONE);
native mybox_spawn_mysterybox( const iDistrict = -1 );
native mybox_destroy_boxes();
forward mysterybox_open_attempt(const user, const mybox);

#define PLUGIN "[JB] Zombie Pet"
#define AUTHOR "Natsheh"

#if AMXX_VERSION_NUM > 182
#define client_disconnect client_disconnected
#endif

#define PEV_NPC_CLASS pev_iuser2

#define NPC_CUSTOM_CLASSNAME "npc_zombie"

#define TASK_NEW_WAVE 34005
#define TASK_ZOMBIE_SPAWNING 3005
#define TASK_REVENANT_BOSS_SPAWN 2005
#define TASK_DISPLAY_GPOINTS 9035
#define TASK_ZOMBIE_RESPAWNING 4005
#define NPC_CONTROL_BUTTON_ID 69626
#define NPC_ZOMBIE_GROUND_EXTRACTION 99609

#define TELEPORTING_COOLDOWN_INTERVAL random_float(5.0,20.0)

enum (+=1)
{
	ZM_CLASS_SOURCE = 0,
	ZM_CLASS_GONOME
}

#define ZM_FIRST_ZOMBIE_CLASS ZM_CLASS_SOURCE
#define ZM_LAST_ZOMBIE_CLASS ZM_CLASS_GONOME

new iITEM_ID, NPC_ZOMBIE_MODEL[][64] =
{
	"models/jailbreak/npc_zombie.mdl",
	"models/jailbreak/npc_gonome.mdl",
};

new const NPC_ZOMBIE_NAME[][] = { "Zombie", "Gonome" };

new const ZA_WAVE_START_SOUND[] = "sound/jailbreak/ZA/cod_wave_start.mp3";
new const ZA_WAVE_OVER_SOUND[] = "sound/jailbreak/ZA/cod_wave_end.mp3";

new const NPC_ZOMBIE_STRIKE_SOUNDS[][] =
{
	"jailbreak/npc_zombie/attack_00.wav",
	"jailbreak/npc_zombie/attack_01.wav",
	"jailbreak/npc_zombie/attack_02.wav",
	"jailbreak/npc_zombie/attack_03.wav",
	"jailbreak/npc_zombie/attack_04.wav",
	"jailbreak/npc_zombie/attack_05.wav",
	"jailbreak/npc_zombie/attack_06.wav",
	"jailbreak/npc_zombie/attack_07.wav",
	"jailbreak/npc_zombie/attack_08.wav",
	"jailbreak/npc_zombie/attack_09.wav",
	"jailbreak/npc_zombie/attack_10.wav"
}

new const NPC_ZOMBIE_DEATH_SOUNDS[][] =
{
	"jailbreak/npc_zombie/death_00.wav",
	"jailbreak/npc_zombie/death_01.wav",
	"jailbreak/npc_zombie/death_02.wav",
	"jailbreak/npc_zombie/death_03.wav",
	"jailbreak/npc_zombie/death_04.wav",
	"jailbreak/npc_zombie/death_05.wav",
	"jailbreak/npc_zombie/death_06.wav",
	"jailbreak/npc_zombie/death_07.wav",
	"jailbreak/npc_zombie/death_08.wav",
	"jailbreak/npc_zombie/death_09.wav",
	"jailbreak/npc_zombie/death_10.wav"
}

new const NPC_ZOMBIE_PAIN_SOUNDS[][] =
{
	"aslave/slv_pain1.wav",
	"aslave/slv_pain2.wav"
}

new const NPC_GONOME_GIBS_CLASSNAME[] = "gonome_gibs";
new const NPC_GONOME_GIBS_MODEL[] = "models/gib_skull.mdl";

new const Float:g_fNPCViewOFS[3] = { 0.0, 0.0, 55.0 };

new g_user_alive, g_iGPoints[MAX_PLAYERS+1], Float:g_fAttackDelay;
new Float:g_fMAX_SIZE[3];
new Float:g_fMIN_SIZE[3];
new spr_blood_drop, spr_blood_spray, g_sprite_beam, g_p_gibs_model;
new g_iZombieWave, g_iWaveZombiesCount, g_iMaxplayers, g_ZombieKills[MAX_PLAYERS+1], Float:g_fUserMaxSpeed[MAX_PLAYERS+1];
new Trie:g_Trie_NPCData = Invalid_Trie;

public plugin_precache()
{
	PRECACHE_WORLD_ITEM("models/gib_skull.mdl");

	PRECACHE_FILE(ZA_WAVE_START_SOUND);
	PRECACHE_FILE(ZA_WAVE_OVER_SOUND);

	g_sprite_beam = PRECACHE_SPRITE_I("sprites/laserbeam.spr");
	g_p_gibs_model = PRECACHE_WORLD_ITEM_I("models/hgibs.mdl");
	
	PRECACHE_SPRITE_I("sprites/b-tele1.spr");
	precache_sound("jailbreak/nc_teleport.wav");
	
	spr_blood_drop = PRECACHE_SPRITE_I("sprites/blood.spr");
	spr_blood_spray = PRECACHE_SPRITE_I("sprites/bloodspray.spr");
	
	for(new i; i < sizeof NPC_ZOMBIE_STRIKE_SOUNDS; i++) precache_sound(NPC_ZOMBIE_STRIKE_SOUNDS[i]);
	for(new i; i < sizeof NPC_ZOMBIE_DEATH_SOUNDS; i++) precache_sound(NPC_ZOMBIE_DEATH_SOUNDS[i]);
	for(new i; i < sizeof NPC_ZOMBIE_PAIN_SOUNDS; i++) precache_sound(NPC_ZOMBIE_PAIN_SOUNDS[i]);

	new const szFormat[] = "NPC_ZOMBIE_MODEL";

	for(new i, szBuffer[64], szName[32]; i < sizeof NPC_ZOMBIE_NAME; i++)
	{
		copy(szName, charsmax(szName), NPC_ZOMBIE_NAME[i]);
		strtoupper(szName);
		formatex(szBuffer, charsmax(szBuffer), "%s_#%s", szFormat, szName);
		jb_ini_get_keyvalue("NPC_ZOMBIE", szBuffer, NPC_ZOMBIE_MODEL[i], charsmax(NPC_ZOMBIE_MODEL[]));
		PRECACHE_WEAPON_WORLD_MODEL(NPC_ZOMBIE_MODEL[i]);
	}
	
	NPC_SIZE(HUMAN_SIZE, g_fMAX_SIZE, g_fMIN_SIZE);
}

enum _:CVARS_NPC_ZOMBIE
{
	CVAR_NPC_HP,
	CVAR_NPC_LOYAL,
	CVAR_NPC_SPEED,
	CVAR_NPC_JSPEED,
	CVAR_NPC_STUCK_TELE,
	CVAR_NPC_ATTACK_DELAY,
	CVAR_NPC_ATTACK_DAMAGE,
	CVAR_NPC_TRACE_ATTACK,
	CVAR_ZA_DAY_NPC_ATTACK_MAX_DELAY,
	CVAR_ZA_DAY_ATTK_DELAY_DECREMENT,
	CVAR_ZA_DAY_BOSS_WAVE_PER,
	CVAR_NPC_GONOME_THROW_FORCE,
	CVAR_NPC_GONOME_GIB_DMG
}

new g_iCvars[CVARS_NPC_ZOMBIE], g_DAY_ID,
	Array:g_animArrays[sizeof NPC_ZOMBIE_MODEL][NPC_ACTIVITY], g_sizeAnimArrays[sizeof NPC_ZOMBIE_MODEL][NPC_ACTIVITY];

new g_zombie_index_naming[MAX_PLAYERS+1], g_user_viewing[MAX_PLAYERS+1];

public plugin_end()
{
	NPC_FREE_HOOKS(NPC_CUSTOM_CLASSNAME);

	for(new i; i < sizeof NPC_ZOMBIE_MODEL; i++)
	{
		MDL_STUDIO_DESTROY_HOOKS(engfunc(EngFunc_ModelIndex, NPC_ZOMBIE_MODEL[i]));
		MDL_STUDIO_FREE_DATA(g_animArrays[i], g_sizeAnimArrays[i]);
	}

	TrieDestroy(g_Trie_NPCData);
}

public plugin_init()
{
	new iPluginID = register_plugin(PLUGIN, VERSION, AUTHOR);

	for(new i; i < sizeof NPC_ZOMBIE_MODEL; i++)
	{
		MDL_STUDIO_LOAD_ANIMATIONS(NPC_ZOMBIE_MODEL[i], g_animArrays[i], g_sizeAnimArrays[i]);
		MDL_STUDIO_HOOK_EVENT(engfunc(EngFunc_ModelIndex, NPC_ZOMBIE_MODEL[i]), "task_npc_event");

	}
	
	iITEM_ID = register_jailbreak_shopitem("Zombie Pet", "He takes care of you", 25000, TEAM_PRISONERS); 

	register_think("trigger_camera", "camera_think");
	register_think(NPC_CUSTOM_CLASSNAME, "npc_brain");
	NPC_Hook_Event(NPC_CUSTOM_CLASSNAME, NPC_EVENT_DEATH, "npc_killed", iPluginID);
	NPC_Hook_Event(NPC_CUSTOM_CLASSNAME, NPC_EVENT_TAKEDAMAGE, "npc_takedmg", iPluginID);
	NPC_Hook_Event(NPC_CUSTOM_CLASSNAME, NPC_EVENT_TRACEATTACK, "npc_traceattack", iPluginID);
	RegisterHam(Ham_Use, "func_button", "npc_use_pre", .Post=false);

	register_think(NPC_GONOME_GIBS_CLASSNAME, "GonomeChestGibs_think");
	register_touch(NPC_GONOME_GIBS_CLASSNAME, "*", "GonomeChestGibs_touch");
	NPC_Hook_Event(NPC_GONOME_GIBS_CLASSNAME, NPC_EVENT_DEATH, "npc_gonome_gibs_destroyed", iPluginID);

	RegisterHam(Ham_TakeDamage, "player", "player_takedmg_post", 1);
	RegisterHam(Ham_Spawn, "player", "player_spawn_post", 1);
	RegisterHam(Ham_Killed, "player", "player_killed_post", 1);
	
	g_iCvars[CVAR_NPC_HP] = register_cvar("jb_npc_zombie_health", "300");
	g_iCvars[CVAR_NPC_LOYAL] = register_cvar("jb_npc_zombie_loyal", "1");
	g_iCvars[CVAR_NPC_SPEED] = register_cvar("jb_npc_zombie_speed", "320");
	g_iCvars[CVAR_NPC_JSPEED] = register_cvar("jb_npc_zombie_jumpspeed", "400");
	g_iCvars[CVAR_NPC_STUCK_TELE] = register_cvar("jb_npc_zombie_stuck_tele", "1");
	g_iCvars[CVAR_NPC_ATTACK_DELAY] = register_cvar("jb_npc_zombie_att_delay", "1.0");
	g_iCvars[CVAR_NPC_ATTACK_DAMAGE] = register_cvar("jb_npc_zombie_att_dmg", "25");
	g_iCvars[CVAR_NPC_TRACE_ATTACK] = register_cvar("jb_npc_zombie_traceattack", "100.0");
	g_iCvars[CVAR_ZA_DAY_NPC_ATTACK_MAX_DELAY] = register_cvar("jb_day_za_zombie_max_att_delay", "1.5");
	g_iCvars[CVAR_ZA_DAY_ATTK_DELAY_DECREMENT] = register_cvar("jb_day_za_att_delay_decrement", "0.05");
	g_iCvars[CVAR_ZA_DAY_BOSS_WAVE_PER] = register_cvar("jb_day_za_boss_per_waves", "5");
	g_iCvars[CVAR_NPC_GONOME_THROW_FORCE] = register_cvar("jb_npc_gonome_gibs_throwforce", "600");
	g_iCvars[CVAR_NPC_GONOME_GIB_DMG] = register_cvar("jb_npc_gonome_gibs_damage", "50");
	
	register_clcmd("name_your_npc_zombie", "clcmd_naming");
	
	register_forward(FM_SetView, "SetView_post", 1);

	new ent;
	while((ent=find_ent_by_class(ent, "trigger_multiple")))
	{
		set_pev(ent, pev_spawnflags, pev(ent, pev_spawnflags)|SF_TRIGGER_ALLOWMONSTERS);
		DispatchSpawn(ent);
	}

	while((ent=find_ent_by_class(ent, "trigger_hurt")))
	{
		set_pev(ent, pev_spawnflags, pev(ent, pev_spawnflags)|SF_TRIGGER_ALLOWMONSTERS);
		DispatchSpawn(ent);
	}

	while((ent=find_ent_by_class(ent, "trigger_teleport")))
	{
		set_pev(ent, pev_spawnflags, pev(ent, pev_spawnflags)|SF_TRIGGER_ALLOWMONSTERS);
		DispatchSpawn(ent);
	}

	register_clcmd("spawn_npc", "clcmd_spawn_npc", ADMIN_IMMUNITY);

	g_DAY_ID = register_jailbreak_day("Zombie Apocalypse", 0, 500.0, DAY_ONE_SURVIVOR);

	g_iMaxplayers = get_maxplayers();

	register_clcmd("say /whereis", "clcmd_whereis");
	register_clcmd("say /kzombie", "kill_zombies", ADMIN_IMMUNITY);

	g_Trie_NPCData = TrieCreate();
}

public plugin_cfg()
{
	ZA_MysteryBoxConfiguration();
	DisableMonsterCollisions("func_wall");

	g_fAttackDelay = get_pcvar_float(g_iCvars[CVAR_NPC_ATTACK_DELAY]);

	set_task(3.0, "TaskEnableNPCSemiClip");
}

public TaskEnableNPCSemiClip()
{
	register_forward(FM_ShouldCollide, "pfnShouldCollide_Pre", ._post = false);
}

public pfnShouldCollide_Pre(touched, passedict)
{
	static iTouchedIdentity;
	iTouchedIdentity = pev(touched, PEV_IDENTITY);

	if(iTouchedIdentity != 0 && iTouchedIdentity == pev(passedict, PEV_IDENTITY))
	{
		forward_return(FMV_CELL, 0);
		return FMRES_SUPERCEDE;
	}
	return FMRES_IGNORED;
}

DisableMonsterCollisions(const name[])
{
	new ent = -1;
	while( (ent = find_ent_by_class(ent, name)) > 0)
	{
		set_pev(ent, pev_flags, pev(ent, pev_flags) & ~FL_MONSTERCLIP);
	}
}

ZA_MysteryBoxConfiguration()
{
	new iMysteryBoxTotalLoc = mybox_get_locations_count(),

	iRemainingSpawns = 5 - iMysteryBoxTotalLoc;

	if( iRemainingSpawns > 0 )
	{
		new Float:fOrigin[3], Float:fAngles[3], Array:pArrLocations = Invalid_Array, iItem;
		new Float:mysterybox_maxs[3] = { 14.0 ,  100.0,  200.0 };
		new Float:mysterybox_mins[3] = { -14.0, -100.0,  -2.0  };
		new iTotalLoc = find_location_around_origin(fOrigin, mysterybox_maxs, mysterybox_mins, 4096.0, .pArrayLocations = pArrLocations, .bInSight = false);

		if(pArrLocations != Invalid_Array)
		{
			new Float:fEnd[3], Float:fBackwardVector[3], Float:fDownVector[3], Float:fRightVector[3], Float:fLeftVector[3], Float:fVOrigin[3], ArrSize, Float:fVecPlane[3], Float:flFraction;
			angle_vector(fAngles, ANGLEVECTOR_FORWARD, fBackwardVector);
			angle_vector(fAngles, ANGLEVECTOR_UP, fDownVector);
			angle_vector(fAngles, ANGLEVECTOR_RIGHT, fRightVector);
			fDownVector[2] *= -1.0;
			fBackwardVector[0] *= -1.0;
			xs_vec_mul_scalar(fBackwardVector, 200.0, fBackwardVector);
			xs_vec_mul_scalar(fDownVector, 9999.0, fDownVector);
			xs_vec_mul_scalar(fRightVector, 14.0, fRightVector);
			xs_vec_mul_scalar(fRightVector, -14.0, fLeftVector);

			iRemainingSpawns = min(iRemainingSpawns, iTotalLoc);

			while( iRemainingSpawns-- > 0 )
			{
				ArrSize = ArraySize(pArrLocations);

				if(ArrSize <= 0)
				{
					break;
				}

				ArrayGetArray(pArrLocations, ( iItem = random(ArrSize) ), fOrigin);

				xs_vec_add(fOrigin, fDownVector, fEnd);
				trace_line(-1, fOrigin, fEnd, fOrigin);
				traceresult(TR_PlaneNormal, fVecPlane);

				if(traceresult(TR_Hit) > 0 || !traceresult(any:TR_InOpen) || traceresult(any:TR_AllSolid) || traceresult(any:TR_StartSolid) || fVecPlane[2] < 1.0)
				{
					iRemainingSpawns++;
					ArrayDeleteItem(pArrLocations, iItem);
					continue;
				}

				xs_vec_add(fOrigin, fBackwardVector, fEnd);
				trace_line(-1, fOrigin, fEnd, fEnd);
				traceresult(TR_PlaneNormal, fVecPlane);
				if(traceresult(TR_Hit) > 0 || !traceresult(any:TR_InOpen) || traceresult(any:TR_AllSolid) || traceresult(any:TR_StartSolid) || fVecPlane[2] != 0.0 || !(20.0 >= get_distance_f(fOrigin, fEnd) >= 16.0))
				{
					iRemainingSpawns++;
					ArrayDeleteItem(pArrLocations, iItem);
					continue;
				}

				xs_vec_sub(fOrigin, fBackwardVector, fEnd);
				trace_line(-1, fOrigin, fEnd, fEnd);
				traceresult(TR_Fraction, flFraction);
				if(traceresult(TR_Hit) > 0 || !traceresult(any:TR_InOpen) || traceresult(any:TR_AllSolid) || traceresult(any:TR_StartSolid) || flFraction != 1.0)
				{
					iRemainingSpawns++;
					ArrayDeleteItem(pArrLocations, iItem);
					continue;
				}

				xs_vec_add(fOrigin, fRightVector, fVOrigin);
				xs_vec_add(fVOrigin, fBackwardVector, fEnd);
				trace_line(-1, fVOrigin, fEnd, fEnd);
				traceresult(TR_PlaneNormal, fVecPlane);
				if(traceresult(TR_Hit) > 0 || !traceresult(any:TR_InOpen) || traceresult(any:TR_AllSolid) || traceresult(any:TR_StartSolid) || fVecPlane[2] != 0.0 || !(20.0 >= get_distance_f(fVOrigin, fEnd) >= 16.0))
				{
					iRemainingSpawns++;
					ArrayDeleteItem(pArrLocations, iItem);
					continue;
				}

				xs_vec_add(fOrigin, fLeftVector, fVOrigin);
				xs_vec_add(fVOrigin, fBackwardVector, fEnd);
				trace_line(-1, fVOrigin, fEnd, fEnd);
				traceresult(TR_PlaneNormal, fVecPlane);
				if(traceresult(TR_Hit) > 0 || !traceresult(any:TR_InOpen) || traceresult(any:TR_AllSolid) || traceresult(any:TR_StartSolid) || fVecPlane[2] != 0.0 || !(20.0 >= get_distance_f(fVOrigin, fEnd) >= 16.0))
				{
					iRemainingSpawns++;
					ArrayDeleteItem(pArrLocations, iItem);
					continue;
				}

				mybox_place_mysterybox_spawner(fOrigin, Float:{0.0, 0.0, 0.0}, .iFallType = FALL_TYPE_NONE);
				server_print("* Placing a MYSTERYBOX SPAWNER Coordinates X: %.2f Y: %.2f Z: %.2f", fOrigin[0], fOrigin[1], fOrigin[2]);

				ArrayDeleteItem(pArrLocations, iItem);
			}

			ArrayDestroy(pArrLocations);
		}
	}
}

public mysterybox_open_attempt(const user, const mybox)
{
	if(jb_get_current_day() != g_DAY_ID)
	{
		return PLUGIN_CONTINUE;
	}

	if(g_iGPoints[user] < 750)
	{
		set_dhudmessage(200, 200, 200, -1.0, 0.80, 0, 1.0, 1.0);
		show_dhudmessage(user, "Require at least 750 [GP] to open the mysterybox!");
		return PLUGIN_HANDLED;
	}

	g_iGPoints[user] -= 750;
	return PLUGIN_CONTINUE;
}

public npc_gonome_gibs_destroyed(const id, const killer)
{
	new Float:fOrigin[3];
	pev(id, pev_origin, fOrigin);
	gib(fOrigin);

	set_pev(id, pev_flags, FL_KILLME);
}

gib(const Float:f_v_Origin[3])
{
	engfunc(EngFunc_MessageBegin, MSG_PVS, SVC_TEMPENTITY, f_v_Origin, 0);
	write_byte(TE_BREAKMODEL);
	engfunc(EngFunc_WriteCoord, f_v_Origin[0]);
	engfunc(EngFunc_WriteCoord, f_v_Origin[1]);
	engfunc(EngFunc_WriteCoord, f_v_Origin[2]);
	write_coord(04); //size.x
	write_coord(04); //size.y
	write_coord(04); //size.z
	write_coord(0); //velocity.x
	write_coord(0); //velocity.y
	write_coord(15); //velocity.z
	write_byte(20); // random velo in 10s
	write_short(g_p_gibs_model); // model
	write_byte(random_num(3, 5)); // count
	write_byte(30); // life
	const BREAK_SKULL   =    31;
	write_byte(BREAK_SKULL); // flags
	message_end();
}

public npc_killed(const id, const killer)
{
	emit_sound(id, CHAN_AUTO, NPC_ZOMBIE_DEATH_SOUNDS[random(sizeof NPC_ZOMBIE_DEATH_SOUNDS)], VOL_NORM, ATTN_NORM, 0, PITCH_NORM);

	if(is_user_connected(killer))
	{
		g_ZombieKills[killer] ++;
		set_user_frags(killer, get_user_frags(killer) + 1);
	}

	if( g_iWaveZombiesCount )
	{
		if( !(--g_iWaveZombiesCount) )
		{
			Terminate_wave( );
		}
		else
		{
			set_dhudmessage(.red=200, .green=0, .blue=0, .x=0.15, .y=0.40, .holdtime=3.0, .fadeintime=0.1, .fadeouttime=2.0);
			show_dhudmessage(0, "* %02d Zombies left...", g_iWaveZombiesCount);
		}
	}

	NPC_DestroyAttachments(id);

	new szClass[32];
	pev(id, PEV_WEAPON_INFLICTOR, szClass, charsmax(szClass));
	Initiate_NPC_DEATHMSG(id, killer, false, szClass);
}

public kill_zombies(id, level)
{
	if(level != 0 && !(get_user_flags(id) & level))
	{
		return 1;
	}

	static ent; ent = -1;
	while( (ent=engfunc(EngFunc_FindEntityByString, ent, "classname", NPC_CUSTOM_CLASSNAME)) > 0 )
	{
		set_pev(ent, PEV_WEAPON_INFLICTOR, "THE FORCE");
		ExecuteHamB(Ham_Killed, ent, id, GIB_NORMAL);
	}

	return 1;
}

public clcmd_whereis(id)
{
	new ent = find_ent_by_class(-1, NPC_CUSTOM_CLASSNAME);
	if(!ent)
	{
		cprint_chat(id, _, "Zombies left: !g%02d !t!", g_iWaveZombiesCount);
		return 1;
	}

	new Float:fOrigin[3];
	pev(id, pev_origin, fOrigin);
	engfunc(EngFunc_MessageBegin, MSG_ONE, SVC_TEMPENTITY, {0.0,0.0,0.0}, id);
	write_byte(TE_BEAMENTPOINT);
	write_short(ent);
	engfunc(EngFunc_WriteCoord, fOrigin[0]);
	engfunc(EngFunc_WriteCoord, fOrigin[1]);
	engfunc(EngFunc_WriteCoord, fOrigin[2]);
	write_short(g_sprite_beam);
	write_byte(0)
	write_byte(10)
	write_byte(255)
	write_byte(10)
	write_byte(1)
	write_byte(0)
	write_byte(255)
	write_byte(0)
	write_byte(255)
	write_byte(1)
	message_end();
	return 1;
}

public task_show_gpoints(taskid)
{
	new id = taskid - TASK_DISPLAY_GPOINTS, target = id;

	if(!is_user_alive(target))
	{
		// get spectator.
		target = pev(id, pev_iuser2);

		if( !( 1 <= target <= g_iMaxplayers ) )
		{
			return;
		}
	}

	set_dhudmessage(50, 50, 50, 0.8, 0.85, 0, 1.0, 1.0);
	show_dhudmessage(id, "GP: %d", g_iGPoints[target]);
}

public jb_day_started(iDayID)
{
	new players[MAX_PLAYERS], pnum;
	get_players(players, pnum, "ah");

	for(new i; i < pnum; i++)
	{
		eliminate_zm_pets(players[i]);
	}

	if(iDayID == g_DAY_ID)
	{
		set_lights("d");
		g_fAttackDelay = get_pcvar_float(g_iCvars[CVAR_ZA_DAY_NPC_ATTACK_MAX_DELAY]);

		//Destroy & Spawn mysterybox/s
		mybox_destroy_boxes();
		mybox_spawn_mysterybox();

		Initiate_wave( (g_iZombieWave = 1) );

		// Lets arm the players.
		for ( new i, id; i < pnum; i++ )
		{
			id = players[i];
			strip_user_weapons(id);
			give_item(id, "weapon_knife");
			cs_set_user_bpammo(id, CSW_USP, 100);
			give_item(id, "weapon_usp");

			set_task(1.0, "task_show_gpoints", id + TASK_DISPLAY_GPOINTS, _, _, "b");
		}

		for( new i = 1; i <= g_iMaxplayers; i++ )
		{
			g_iGPoints[ i ] = 500;
			g_ZombieKills[ i ] = 0;
			jb_set_user_allies(i, JB_ALLIES_EVERYONE);
			jb_set_user_enemies(i, JB_ENEMIES_DEFAULT);
		}
	}
}

public jb_day_ended(iDayID)
{
	if(iDayID == g_DAY_ID)
	{
		new MostKills = g_ZombieKills[ 1 ], MostKillsID = 1;
		for(new i = 2; i <= g_iMaxplayers; i++)
		{
			if(g_ZombieKills[i] > MostKills)
			{
				MostKillsID = i;
				MostKills = g_ZombieKills[i];
			}
		}

		if(g_ZombieKills[ MostKillsID ] && is_user_connected(MostKillsID))
		{
			new szName[32];
			get_user_name(MostKillsID, szName, 31);
			cprint_chat(0, _, "Most zombie slaughter was done by !g%s !ykilled over !g%d !tzombies!", szName, MostKills);

			jb_set_user_cash(MostKillsID, jb_get_user_cash(MostKillsID) + (250 * MostKills));
			cprint_chat(0, _, "!t%s !ywas rewarded with %d!g$.", szName, (250 * MostKills));
		}

		set_lights("#OFF");
		remove_task(TASK_ZOMBIE_SPAWNING);
		remove_task(TASK_REVENANT_BOSS_SPAWN);
		remove_task(TASK_ZOMBIE_RESPAWNING);
		remove_task(TASK_NEW_WAVE);
		g_iWaveZombiesCount = g_iZombieWave = 0;
		g_fAttackDelay = get_pcvar_float(g_iCvars[CVAR_NPC_ATTACK_DELAY]);

		for( new i = 1; i <= g_iMaxplayers; i++ )
		{
			jb_set_user_allies(i, JB_ALLIES_DEFAULT);
			g_ZombieKills[ i ] = 0;

			remove_task(i + TASK_DISPLAY_GPOINTS);
		}

		eliminate_zm_pets( );
		npc_despawn_revenant_boss( );
		mybox_destroy_boxes();
	}
}

Terminate_wave()
{
	// Play end wave sound...
	client_cmd(0, "mp3 play ^"%s^"", ZA_WAVE_OVER_SOUND);

	set_task(10.0, "task_initiate_new_wave", TASK_NEW_WAVE);
}

public task_initiate_new_wave()
{
	// Reviving dead clients...
	new players[MAX_PLAYERS], pnum;
	get_players(players, pnum, "bh");

	for(new i, id; i < pnum; i++)
	{
		id = players[ i ];

		switch( get_user_team(id) )
		{
			case TEAM_GUARDS, TEAM_PRISONERS:
			{
				ExecuteHamB(Ham_CS_RoundRespawn, id);
				cs_set_user_bpammo(id, CSW_USP, 100);
				give_item(id, "weapon_usp");
				remove_task(id + TASK_DISPLAY_GPOINTS);
				set_task(1.0, "task_show_gpoints", id + TASK_DISPLAY_GPOINTS, _, _, "b");
			}
		}
	}

	Initiate_wave( ++g_iZombieWave );
}

Initiate_wave(const wave)
{
	// Play end wave sound...
	client_cmd(0, "mp3 play ^"%s^"", ZA_WAVE_START_SOUND);

	// annunciation !
	set_dhudmessage(.red=200, .green=0, .blue=0, .y=0.35, .holdtime=6.0, .fadeintime=3.0, .fadeouttime=3.0);
	show_dhudmessage(0, ".: * WAVE %02d * :.", wave);

	set_task(10.0, "task_Initate_zombie_spawning", TASK_ZOMBIE_SPAWNING);

	g_fAttackDelay = floatmax(g_fAttackDelay - (g_fAttackDelay * get_pcvar_float(g_iCvars[CVAR_ZA_DAY_ATTK_DELAY_DECREMENT])), 0.1);

	// Spawning a Boss Every 5 rounds.
	if( (wave % get_pcvar_num(g_iCvars[CVAR_ZA_DAY_BOSS_WAVE_PER])) == 0 )
	{
		set_task( 10.0, "task_spawn_revenant_boss", TASK_REVENANT_BOSS_SPAWN );
	}
}

public task_spawn_revenant_boss(taskid)
{
	npc_spawn_revenant_boss();
}

public task_Initate_zombie_spawning(taskid)
{
	new players[MAX_PLAYERS], pnum;
	get_players(players, pnum, "ah");

	if(!pnum)
	{
		return;
	}

	static iSpawnableZombies, iPlayerSpawnableZombies[MAX_PLAYERS+1];

	if(taskid == TASK_ZOMBIE_SPAWNING)
	{
		iSpawnableZombies = 0;
	}

	if(!iSpawnableZombies)
	{
		// every new zombie wave spawn zombies extra
		g_iWaveZombiesCount = iSpawnableZombies = g_iZombieWave * pnum;

		for( new i, iPlayerZombies = iSpawnableZombies / pnum; i < pnum; i++ )
		{
			iPlayerSpawnableZombies[ players[ i ] ] = iPlayerZombies;
		}
	}
	else
	{
		for(new i = 1; i <= g_iMaxplayers; i++)
		{
			if(iPlayerSpawnableZombies[ i ] > 0 && !is_user_alive( i ))
			{
				// Haha add the dead player zombies to a random alive one muhaha...!
				iPlayerSpawnableZombies[ players[random(pnum)] ] += iPlayerSpawnableZombies[ i ];
				iPlayerSpawnableZombies[ i ] = 0;
			}
		}
	}

	for(new i, id, Float:fOrigin[3], Float:fHealth = g_iZombieWave * 100.0, Float:fSpeed = (g_iZombieWave * 20.0) + 80.0; i < pnum; i++)
	{
		id = players[ i ];

		if(iPlayerSpawnableZombies[ id ])
		{
			pev(id, pev_origin, fOrigin);
			if(spawn_npcs_nearby_origin(1, fOrigin, 300.0, fHealth, floatmin(fSpeed, get_pcvar_float(g_iCvars[CVAR_NPC_SPEED]))))
			{
				iPlayerSpawnableZombies[ id ]--;
				iSpawnableZombies--;
			}
		}
	}

	if(iSpawnableZombies)
	{
		set_task(3.0, "task_Initate_zombie_spawning", TASK_ZOMBIE_RESPAWNING);
	}
}

spawn_npcs_nearby_origin(const amount, Float:fOrigin[3], const Float:fDist, const Float:fHealth=100.0, const Float:fSpeed=100.0, const NPC_Type=-1)
{
	new Array:tempArray = Invalid_Array, iAvailableLocationsCount, iZombiesCount = 0;
	iAvailableLocationsCount = find_location_around_origin(fOrigin, g_fMAX_SIZE, g_fMIN_SIZE, fDist, false, any:tempArray);
	for(new i, Float:fGtime = get_gametime(), iClass = NPC_Type, ent_zm, iItem, loop = min(amount, iAvailableLocationsCount); i < loop; i++)
	{
		ArrayGetArray(tempArray, (iItem=random(iAvailableLocationsCount--)), fOrigin);
		ArrayDeleteItem(tempArray, iItem);

		if(NPC_Type == -1) iClass = random_num(ZM_FIRST_ZOMBIE_CLASS, ZM_LAST_ZOMBIE_CLASS);

		if((ent_zm = NPC_SPAWN(NPC_CUSTOM_CLASSNAME, NPC_ZOMBIE_NAME[iClass], NPC_ZOMBIE_MODEL[iClass], fOrigin, g_fNPCViewOFS,
			fSpeed, fHealth, .task=NPC_ZOMBIE_GROUND_EXTRACTION, .NPC_MOVETYPE=MOVETYPE_PUSHSTEP,
			.fMaxS=g_fMAX_SIZE, .fMinS=g_fMIN_SIZE)) > 0 )
		{
			set_pev(ent_zm, PEV_NPC_CLASS, iClass);
			set_pev(ent_zm, PEV_IDENTITY, NPC_ID + iClass + 1);
			set_pev(ent_zm, PEV_TELEPORTING_COOLDOWN, fGtime + TELEPORTING_COOLDOWN_INTERVAL);

			switch(iClass)
			{
				case ZM_CLASS_GONOME:
				{
					NPC_SetData(ent_zm, "RANGE_ATTACK1_AMMO", random_num(5, 10));
					NPC_SetData(ent_zm, "RANGE_ATTACK2_AMMO", random_num(5, 10));
				}
			}

			set_pev(ent_zm, PEV_PREVIOUS_TASK, NPC_SEEK_TARGET);
			iZombiesCount ++;
		}
	}

	if(tempArray != Invalid_Array)
	{
		ArrayDestroy(tempArray);
	}

	return iZombiesCount;
}

public clcmd_spawn_npc(id, level, cid)
{
	if(!(get_user_flags(id) & level))
	{
		console_print(id, "No access/authorization!");
		return 1;
	}

	new szAmount[4], szDist[4], Float:fOrigin[3], szType[16], iNPCType = -1;
	read_argv(1, szType, charsmax(szType));
	read_argv(2, szAmount, charsmax(szAmount));
	read_argv(3, szDist, charsmax(szDist));

	for(new i; i < sizeof NPC_ZOMBIE_NAME; i++)
	{
		if(equali(NPC_ZOMBIE_NAME[i], szType))
		{
			iNPCType = i; break;
		}
	}


	pev(id, pev_origin, fOrigin);
	fOrigin[2] -= 36.0;

	new iNPCsCount = spawn_npcs_nearby_origin(max(str_to_num(szAmount), 1), fOrigin, floatmax( floatstr(szDist), 100.0 ), get_pcvar_float(g_iCvars[CVAR_NPC_SPEED]), .NPC_Type = iNPCType);

	if(iNPCType > -1)
		console_print(id, "%d NPCs %s has been spawned!", iNPCsCount, NPC_ZOMBIE_NAME[iNPCType]);
	else
		console_print(id, "%d NPCs has been spawned!", iNPCsCount);
	return PLUGIN_HANDLED;
}

public player_spawn_post(id)
{
	if(!is_user_alive(id)) return;

	set_flag(g_user_alive,id);
}

public player_killed_post(victim, killer)
{
	remove_flag(g_user_alive,victim);
}

public client_disconnect(id)
{
	g_ZombieKills[id] = 0;
	remove_flag(g_user_alive,id);
	remove_task(id);
	remove_task(id + TASK_DISPLAY_GPOINTS);
}

pet_control_menu(id, pet)
{
	new szText[128], szName[32], Float:fHealth;
	pev(pet, pev_netname, szName, charsmax(szName))
	pev(pet, pev_health, fHealth);
	formatex(szText, charsmax(szText), "\yStatus \r'%s' ^n \wHealth: \r%.2f", szName, fHealth)
	new menu = menu_create(szText, "petcontrol_m_handle");
	
	new szInfo[5];
	num_to_str(pet, szInfo, charsmax(szInfo));
	
	menu_additem(menu, "Order him to Follow !", szInfo, 0)
	menu_additem(menu, "Order him to Stay !", szInfo, 0)
	menu_additem(menu, "Fully control your pet !", szInfo, 0)
	menu_additem(menu, "Order him to attack anyone !", szInfo, 0)
	
	menu_display(id, menu);
}

public petcontrol_m_handle(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	new null, sData[5];
	menu_item_getinfo(menu, item, null, sData, charsmax(sData), "", _, null);
	
	menu_destroy(menu);
	
	new pet = str_to_num(sData);
	
	if(!pev_valid(pet) || pev(pet, PEV_OWNER) != id || pev(pet, PEV_IDENTITY) != NPC_ID)
	{
		return PLUGIN_HANDLED;
	}

	new Float:fHealth;
	pev(pet, pev_health, fHealth);

	if(fHealth <= 0.0)
	{
		return PLUGIN_HANDLED;
	}
	
	new szName[32];
	pev(pet, pev_netname, szName, charsmax(szName));
	
	switch( item )
	{
		case 0:
		{
			cprint_chat(id, _, "You ordered !g'%s' !tto follow you!", szName);
			set_pev(pet, PEV_PREVIOUS_TASK, NPC_FOLLOW_PLAYER);
			set_pev(pet, PEV_TASK, NPC_FOLLOW_PLAYER);
			set_pev(pet, NPC_TARGET, id);
		}
		case 1:
		{
			cprint_chat(id, _, "You ordered !g'%s' !tto stay!", szName);
			set_pev(pet, PEV_PREVIOUS_TASK, NPC_IDLE);
			set_pev(pet, PEV_TASK, NPC_IDLE);
		}
		case 2:
		{
			cprint_chat(id, _, "You, now have a full control on !g%s!t!", szName);
			set_pev(pet, PEV_TASK, NPC_MANUAL_CONTROL);
		}
		case 3:
		{
			cprint_chat(id, _, "You set !g%s!t to seek for targets!", szName);
			set_pev(pet, PEV_PREVIOUS_TASK, NPC_SEEK_TARGET);
			set_pev(pet, PEV_TASK, NPC_SEEK_TARGET);
		}
	}
	
	return PLUGIN_HANDLED;
}

public npc_use_pre(id, caller, activator, use_type, Float:value)
{
	if(pev(id, PEV_IDENTITY) != NPC_CONTROL_BUTTON_ID)
	{
		return HAM_IGNORED;
	}

	new NPCIndex = pev(id, pev_owner);

	if(pev(NPCIndex, PEV_IDENTITY) != NPC_ID)
	{
		return HAM_IGNORED;
	}
	
	pet_control_menu(caller, NPCIndex);
	return HAM_SUPERCEDE;
}

public SetView_post(id, iEnt) 
{
	g_user_viewing[id] = iEnt;
}

public camera_think(ent)
{
	static iNPC;
	iNPC = pev(ent, pev_owner);

	if( !iNPC )
	{
		return;
	}

	static iOwner;
	iOwner = pev(iNPC, PEV_OWNER);

	if( !IsPlayer(iOwner) || g_user_viewing[iOwner] != ent )
	{
		return;
	}

	static Float:fNPCOrigin[3], Float:fCameraOrig[3], Float:fVec[3], Float:fAngle[3];
	pev(iNPC, pev_origin, fNPCOrigin);
	pev(iNPC, pev_view_ofs, fVec);
	xs_vec_add(fNPCOrigin, fVec, fNPCOrigin);
	pev(iOwner, pev_v_angle, fAngle);
	xs_vec_copy(fNPCOrigin, fCameraOrig);
	set_pev(ent, pev_angles, fAngle);
	set_pev(ent, pev_fixangle, 2);

	fAngle[0] *= -1.0;
	angle_vector(fAngle, ANGLEVECTOR_FORWARD, fVec);

	fCameraOrig[0] += -fVec[0] * (50.0 + (g_fMAX_SIZE[0] - g_fMIN_SIZE[0]));
	fCameraOrig[1] += -fVec[1] * (50.0 + (g_fMAX_SIZE[1] - g_fMIN_SIZE[1]));
	fCameraOrig[2] +=  fVec[2] * (12.0 + (g_fMAX_SIZE[2] - g_fMIN_SIZE[2]));

	trace_line(iNPC, fNPCOrigin, fCameraOrig, fCameraOrig);
	engfunc(EngFunc_SetOrigin, ent, fCameraOrig);
}

create_3d_camera(iOwner, iduser)
{ 
	new iEnt = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "trigger_camera") );
	
	if(!iEnt) return 0;
	
	set_kvd(0, KV_ClassName, "trigger_camera");
	set_kvd(0, KV_fHandled, 0);
	set_kvd(0, KV_KeyName, "wait");
	set_kvd(0, KV_Value, "9999999");
	dllfunc(DLLFunc_KeyValue, iEnt, 0);
	
	set_pev(iEnt, pev_spawnflags, (SF_CAMERA_PLAYER_TARGET|SF_CAMERA_PLAYER_POSITION) & ~SF_CAMERA_PLAYER_TAKECONTROL);
	set_pev(iEnt, pev_flags, pev(iEnt, pev_flags) | FL_ALWAYSTHINK);
	
	dllfunc(DLLFunc_Spawn, iEnt);
	
	set_pev(iEnt, pev_owner, iOwner);

	ExecuteHam(Ham_Use, iEnt, iduser, iduser, USE_ON, 1.0);
	
	new Float:fSpeed;
	pev(iOwner, pev_maxspeed, fSpeed);
	set_pev(iEnt, pev_maxspeed, fSpeed);

	return iEnt;
}

public clcmd_naming(id, level, cid)
{
	new ent = g_zombie_index_naming[id];
	
	if(!pev_valid(ent)) return 1;
	
	if(pev(ent, PEV_OWNER) == id)
	{
		new szArg[32];
		read_argv(1, szArg, charsmax(szArg))
		remove_quotes(szArg);
		trim(szArg);
		
		if(!szArg[0]) copy(szArg, charsmax(szArg), "Unnamed");
		
		cprint_chat(id, _, "You named your zombie pet !g%s!t.", szArg);
		set_pev(ent, pev_netname, szArg);
		g_zombie_index_naming[id] = 0;
	}
	return 1;
}

public jb_shop_item_bought(id, itemid)
{
	if(itemid == iITEM_ID)
	{
		new Float:fOrigin[3], ent;
		pev(id, pev_origin, fOrigin);
		fOrigin[2] -= 36.0;
		find_location_around_origin(fOrigin, g_fMAX_SIZE, g_fMIN_SIZE, 200.0, .bRandom=true);
		new iClass =	random_num(ZM_FIRST_ZOMBIE_CLASS, ZM_LAST_ZOMBIE_CLASS);
		ent = g_zombie_index_naming[id] = NPC_SPAWN(NPC_CUSTOM_CLASSNAME, "pet", NPC_ZOMBIE_MODEL[iClass], fOrigin, g_fNPCViewOFS,
			.owner=id, .fMaxSpeed=get_pcvar_float(g_iCvars[CVAR_NPC_SPEED]), .fMaxHealth=get_pcvar_float(g_iCvars[CVAR_NPC_HP]),
			.fMaxS=g_fMAX_SIZE, .fMinS=g_fMIN_SIZE, .task = NPC_ZOMBIE_GROUND_EXTRACTION);
		set_pev( ent, PEV_PREVIOUS_TASK, NPC_IDLE );
		set_pev( ent, PEV_NPC_CLASS, iClass );
		set_pev( NPC_CreateControlButton( ent ), PEV_OWNER, id );
		client_cmd(id, "messagemode ^"name_your_npc_zombie^"");
	}
}

public jb_round_end()
{
	new players[32],pnum;
	get_players(players, pnum, "ah");
	
	for(new i; i < pnum; i++)
	{
		eliminate_zm_pets(players[i]);
	}
}

public jb_lr_duel_started(prisoner, guard, duelid)
{
	eliminate_zm_pets(prisoner);
}

get_player_npc(id, ent_start=0)
{
	static ent; ent = ent_start;
	while( (ent=engfunc(EngFunc_FindEntityByString, ent, "classname", NPC_CUSTOM_CLASSNAME)) > 0 )
	{
		if(pev(ent, PEV_OWNER) == id)
		{
			return ent;
		}
	}
	
	return 0;
}

eliminate_zm_pets(const id = 0)
{
	static ent, Float:fTime; ent = -1; fTime = get_gametime();
	while( (ent=engfunc(EngFunc_FindEntityByString, ent, "classname", NPC_CUSTOM_CLASSNAME)) > 0 )
	{
		if(pev(ent, PEV_OWNER) == id)
		{
			set_pev(ent, PEV_TASK, NPC_DEATH);
			set_pev(ent, pev_nextthink, fTime + 0.1);
		}
	}
}

NPC_DestroyAttachments( const iNPC )
{
	new Float:fOrigin[3], Float:fVec[3], ent = -1;
	xs_vec_sub(g_fMAX_SIZE, g_fMIN_SIZE, fVec);
	pev(iNPC, pev_origin, fOrigin);
	// Lets remove all the npc attachment.
	while( (ent = find_ent_in_sphere(ent, fOrigin, xs_vec_len(fVec))) > 0 )
	{
		if(pev(ent, PEV_OWNER) == iNPC || pev(ent, pev_aiment) == iNPC)
		{
			set_pev(ent, pev_flags, FL_KILLME);
			dllfunc(DLLFunc_Think, ent);
		}
	}
}

NPC_DestroyControlButton( const iNPC )
{
	new ent = -1;
	while( (ent = find_ent_by_class(ent, "func_button")) > 0 )
	{
		if(pev(ent, pev_owner) == iNPC && pev(ent, PEV_IDENTITY) == NPC_CONTROL_BUTTON_ID)
		{
			set_pev(ent, pev_flags, FL_KILLME);
			dllfunc(DLLFunc_Think, ent);
			break;
		}
	}
}

NPC_CreateControlButton( const iNPC_index )
{
	new ent = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "func_button"));

	if( !ent )
	{
		return 0;
	}

	new szName[32];
	pev(iNPC_index, pev_netname, szName, charsmax(szName));

	set_pev(ent, pev_target, szName);
	set_pev(ent, pev_movetype, MOVETYPE_FOLLOW);
	set_pev(ent, pev_solid, SOLID_NOT);
	set_pev(ent, pev_aiment, iNPC_index);
	set_pev(ent, pev_owner, iNPC_index);
	set_pev(ent, PEV_IDENTITY, NPC_CONTROL_BUTTON_ID);
	set_rendering(ent, .render=kRenderTransAlpha, .amount=255);

	engfunc(EngFunc_SetModel, ent, NPC_ZOMBIE_MODEL[0]);
	engfunc(EngFunc_SetSize, ent, g_fMIN_SIZE, g_fMAX_SIZE);

	set_pev(ent, pev_spawnflags, SF_BUTTON_TOGGLE);

	return ent;
}

public player_takedmg_post(id, inflictor, attacker, Float:damage, damagebits)
{
	if(id == attacker || !get_player_npc(id))
	{
		return HAM_IGNORED;
	}

	if(pev_valid(inflictor) && entity_takedamage_type(inflictor) != DAMAGE_NO)
	{
		static Float:fHealth;
		pev(inflictor, pev_health, fHealth);

		if(fHealth > 0.0)
		{
			static ent, iTask; ent = 0;
			while( (ent=get_player_npc(id, ent)) > 0 )
			{
				iTask = pev(ent, PEV_TASK);
				if( ent != inflictor && iTask != NPC_DEATH && iTask != NPC_KILLSELF && iTask != NPC_ATTACK )
				{
					set_pev(ent, NPC_TARGET, inflictor);
					set_pev(ent, PEV_TASK, NPC_ATTACK);
				}
			}

			return HAM_IGNORED;
		}
	}

	if(is_user_alive(attacker) && entity_takedamage_type(attacker) != DAMAGE_NO && damage > 0.0)
	{
		static ent, iTask; ent = 0;
		while( (ent=get_player_npc(id, ent)) > 0 )
		{
			iTask = pev(ent, PEV_TASK);
			if( ent != inflictor && iTask != NPC_DEATH && iTask != NPC_KILLSELF && iTask != NPC_ATTACK )
			{
				set_pev(ent, NPC_TARGET, inflictor);
				set_pev(ent, PEV_TASK, NPC_ATTACK);
			}
		}
	}

	return HAM_IGNORED;
}

public npc_traceattack(id, attacker, Float:Damage, Float:fDirection[3], trace_handle, damagebits)
{
	if(damagebits & (DMG_SLASH|DMG_BULLET|DMG_CRUSH|DMG_BLAST|DMG_ENERGYBEAM))
	{
		fDirection[0] *= Damage;
		fDirection[1] *= Damage;
		fDirection[2] *= Damage;
		
		static Float:fHit[3];
		get_tr2(trace_handle, TR_vecEndPos, fHit);
		EFF_SPILL_BLOOD(fHit, fDirection, spr_blood_spray, spr_blood_drop);
	}
}

public npc_takedmg(id, inflictor, attacker, Float:fDamage, damagebits)
{
	if(IsPlayer(attacker))
	{
		g_iGPoints[attacker] += floatround(fDamage);
	}

	emit_sound(id, CHAN_AUTO, NPC_ZOMBIE_PAIN_SOUNDS[random(sizeof NPC_ZOMBIE_PAIN_SOUNDS)], VOL_NORM, ATTN_NORM, 0, PITCH_NORM);

	static Float:fHealth;
	pev(id, pev_health, fHealth);

	if(!attacker || entity_takedamage_type(attacker) == DAMAGE_NO || fDamage > fHealth)
	{
		return;
	}

	if((get_pcvar_num(g_iCvars[CVAR_NPC_LOYAL]) > 0 && pev(id, PEV_OWNER) == attacker))
			return;

	static iTask;
	iTask = pev(id, PEV_TASK);

	if(iTask != NPC_ATTACK && iTask != NPC_MANUAL_CONTROL)
	{
		if(pev(id, PEV_OWNER) == attacker)
		{
			NPC_DestroyControlButton(id);
			set_pev(id, PEV_OWNER, 0);
			set_pev(id, pev_owner, 0);
			set_pev(id, NPC_TARGET, 0);
		}

		set_pev(id, NPC_TARGET, attacker);
		set_pev(id, PEV_TASK, NPC_ATTACK);
	}
}

public npc_brain(id)
{
	if(!pev_valid(id)) return;
	
	static Float:fGtime, iOwner, Float:fVelocity[3], Float:fNPCViewAngles[3], Float:fOrigin[3], Float:fTraceAttackOrigin[3], Float:fViewOffset[3], iFlags, Float:fNPCspeed, Float:fNPCJspeed, iTask, ZTYPE;
	fGtime = get_gametime();
	iTask = pev(id, PEV_TASK);
	iOwner = pev(id, PEV_OWNER);
	pev(id, pev_velocity, fVelocity);
	pev(id, pev_angles, fNPCViewAngles);
	pev(id, pev_origin, fOrigin);
	pev(id, pev_view_ofs, fViewOffset);
	xs_vec_add(fOrigin, fViewOffset, fTraceAttackOrigin);
	iFlags = pev(id, pev_flags);
	pev(id, pev_maxspeed, fNPCspeed);
	fNPCJspeed = get_pcvar_float(g_iCvars[CVAR_NPC_JSPEED]);

	static iCameraEntityIndex;
	ZTYPE = pev(id, PEV_NPC_CLASS);
	
	if((iCameraEntityIndex=pev(id, PEV_NPC_3RDCAMERA_ENT)) && iOwner && iTask != NPC_MANUAL_CONTROL)
	{
		engfunc(EngFunc_SetView, iOwner, iOwner);
		g_user_viewing[iOwner] = iOwner;

		set_pev(iCameraEntityIndex, pev_flags, FL_KILLME);
		dllfunc(DLLFunc_Think, iCameraEntityIndex);

		set_pev(id, PEV_NPC_3RDCAMERA_ENT, 0);
		iCameraEntityIndex = 0;
		
		set_user_maxspeed(iOwner, g_fUserMaxSpeed[iOwner]);
	}
	
	switch( iTask )
	{
		case NPC_ZOMBIE_GROUND_EXTRACTION:
		{
			set_pev(id, PEV_TASK, pev(id, PEV_PREVIOUS_TASK));

			if(g_sizeAnimArrays[ZTYPE][ACT_STAND] <= 0)
			{
				NPC_animation(id, g_animArrays[ZTYPE], g_sizeAnimArrays[ZTYPE]);
				set_pev(id, pev_nextthink, fGtime + NPC_THINK_LEN);
				return;
			}

			static xArray[ANIMATION_DATA], Float:fLength, Float:fFrameRate;
			pev(id, pev_framerate, fFrameRate);

			fNPCViewAngles[1] = random_float(0.0, 360.0);
			set_pev(id, pev_angles, fNPCViewAngles);

			if(fFrameRate <= 0.0)
				fFrameRate = 1.0;

			ArrayGetArray(Array:g_animArrays[ZTYPE][ACT_STAND], random(g_sizeAnimArrays[ZTYPE][ACT_STAND]), xArray);
			PlayAnimation(id, xArray[ANIMATION_SEQUENCE],
				xArray[ANIMATION_FPS], fFrameRate, xArray[ANIMATION_FRAMES], ACT_STAND,
				.bInLOOP=false,
				.pArrayEvent=Array:xArray[ANIMATION_EVENT_ARRAY],
				.pArrayEventSize=xArray[ANIMATION_EVENTS]);

			fLength = ( xArray[ANIMATION_FRAMES] / floatmax(xArray[ANIMATION_FPS] * fFrameRate, 1.0) );

			set_pev(id, pev_nextthink, fGtime + fLength);
		}
		case NPC_DEATH:
		{
			if( iCameraEntityIndex )
			{
				if(g_user_viewing[iOwner] == iCameraEntityIndex)
				{
					engfunc(EngFunc_SetView, iOwner, iOwner);
					g_user_viewing[iOwner] = iOwner;
				}

				if(pev_valid(iCameraEntityIndex))
				{
					set_pev(iCameraEntityIndex, pev_flags, FL_KILLME);
					dllfunc(DLLFunc_Think, iCameraEntityIndex);
				}

				set_pev(id, PEV_NPC_3RDCAMERA_ENT, 0);
				iCameraEntityIndex = 0;
				
				set_user_maxspeed(iOwner, g_fUserMaxSpeed[iOwner]);
			}
			
			fVelocity[0] = fVelocity[1] = 0.0;
			set_pev(id, pev_velocity, fVelocity);
			
			set_pev(id, pev_deadflag, DEAD_DYING);
			set_pev(id, pev_solid, SOLID_NOT);
			set_pev(id, pev_movetype, MOVETYPE_TOSS);
			set_pev(id, pev_takedamage, DAMAGE_NO);
			set_pev(id, PEV_TASK, NPC_KILLSELF);

			NPC_animation(id, g_animArrays[ZTYPE], g_sizeAnimArrays[ZTYPE]);

			set_pev(id, pev_nextthink, fGtime + NPC_KILLSELF_THINK_LEN);
		}
		case NPC_IDLE:
		{
			NPC_animation(id, g_animArrays[ZTYPE], g_sizeAnimArrays[ZTYPE]);
			set_pev(id, pev_nextthink, fGtime + NPC_THINK_LEN);
		}
		case NPC_SEEK_TARGET:
		{
			static ent, iTarget, Float:fMaxDistance, Float:fDist, Float:fOriginDest[3];
			ent = iTarget = 0;
			fMaxDistance = 1000.0;

			while( (ent=find_ent_in_sphere(ent, fTraceAttackOrigin, fMaxDistance)) > 0)
			{
				if( ent != iOwner &&
					IsPlayer(ent) &&
					entity_takedamage_type(ent) != DAMAGE_NO &&
					IsEntityVisible(fTraceAttackOrigin, fOriginDest, ent, id) &&
					fMaxDistance > (fDist = get_distance_f(fTraceAttackOrigin,fOriginDest)) )
				{
					fMaxDistance = fDist;
					iTarget = ent;
				}
			}

			static Float:fRoamingDelay, Float:fTeleportDelay;
			pev(id, PEV_NPC_ACTION_DELAY, fRoamingDelay);
			pev(id, PEV_TELEPORTING_COOLDOWN, fTeleportDelay);

			if(iTarget) // We Found a target? engage !
			{
				set_pev(id, PEV_TARGET_LAST_TIME_SEEN, fGtime);
				set_pev(id, PEV_PREVIOUS_TASK, NPC_SEEK_TARGET);
				set_pev(id, NPC_TARGET, iTarget);
				set_pev(id, PEV_TASK, NPC_ATTACK);
			}
			else if(fTeleportDelay < fGtime && fMaxDistance >= 1000.0)
			{
				// lets teleport to nearby enemy :)
				static players[32], pnum;
				get_players(players, pnum, "ach");

				if( pnum > 0 )
				{
					ent = 0;
					while( (ent = find_ent_by_class(ent, NPC_CUSTOM_CLASSNAME)) > 0 )
					{
						if(ent == id)
						{
							continue;
						}

						pev(ent, PEV_TELEPORTING_COOLDOWN, fTeleportDelay);
						set_pev(ent, PEV_TELEPORTING_COOLDOWN, fTeleportDelay + 1.0);
					}

					pev(players[random(pnum)], pev_origin, fOriginDest);
					fOriginDest[2] -= 36.0;
					if(find_location_around_origin(fOriginDest, g_fMAX_SIZE, g_fMIN_SIZE, 500.0, .bRandom=true))
					{
						set_pev(id, PEV_TELEPORTING_COOLDOWN, fGtime + TELEPORTING_COOLDOWN_INTERVAL); // teleportation cool down!
						teleport_entity(id, fOriginDest, g_fMAX_SIZE, g_fMIN_SIZE);
					}
				}
			}
			else if( fRoamingDelay < fGtime ) // lets roam and find us a target.
			{
				static i, Float:vfTemp[3] = { 0.0, 0.0, 0.0 }, Float:fChosenAngle, Float:fCurrAngle;
				fMaxDistance = fChosenAngle = 0.0; // 1k unit should be enf for us to find the longest path.
				fOriginDest[2] = fTraceAttackOrigin[2];

				for ( i = 0, fCurrAngle = -45.0;  i < 3; i ++ )
				{
					fDist = 9999.0;
					xs_vec_set(vfTemp, 0.0, fNPCViewAngles[1] + fCurrAngle, 0.0);
					angle_vector(vfTemp, ANGLEVECTOR_FORWARD, vfTemp);
					xs_vec_mul_scalar(vfTemp, fDist, vfTemp);

					fOriginDest[0] = fOrigin[0] + vfTemp[0];
					fOriginDest[1] = fOrigin[1] + vfTemp[1];
					NPC_traceattack(id, fTraceAttackOrigin, fOriginDest, fDist, .HullType=HULL_HUMAN);

					if(fDist > fMaxDistance)
					{
						fMaxDistance = fDist;
						fChosenAngle = fNPCViewAngles[1] + fCurrAngle;
					}

					fCurrAngle += 45.0;
				}

				if( fMaxDistance > ((xs_vec_len(g_fMAX_SIZE) + xs_vec_len(g_fMIN_SIZE)) * 0.5) )
				{
					vfTemp[ 0 ] = vfTemp[ 2 ] = 0.0;
					vfTemp[ 1 ] = fChosenAngle;
					angle_vector(vfTemp, ANGLEVECTOR_FORWARD, vfTemp);
					xs_vec_mul_scalar(vfTemp, fMaxDistance, vfTemp);
					fOriginDest[0] = fOrigin[0] + vfTemp[0];
					fOriginDest[1] = fOrigin[1] + vfTemp[1];
					LookAtOrigin(id, fOriginDest);
					set_pev(id, PEV_NPC_ACTION_DELAY, fGtime + MoveToOrigin(id, fOriginDest, fNPCspeed, fNPCJspeed, fVelocity));
				}
				else // no way to go ? lets turn 45 degrees to the right.
				{
					xs_vec_set(vfTemp, 0.0, fNPCViewAngles[1] + 45.0, 0.0);
					angle_vector(vfTemp, ANGLEVECTOR_FORWARD, vfTemp);
					fOriginDest[0] = fOrigin[0] + vfTemp[0];
					fOriginDest[1] = fOrigin[1] + vfTemp[1];
					LookAtOrigin(id, fOriginDest);
					set_pev(id, PEV_NPC_ACTION_DELAY, fGtime + 0.5); // turning right takes time.
				}
			}

			NPC_animation(id, g_animArrays[ZTYPE], g_sizeAnimArrays[ZTYPE]);
			set_pev(id, pev_nextthink, fGtime + NPC_THINK_LEN);
		}
		case NPC_MANUAL_CONTROL:
		{
			if(!iCameraEntityIndex)
			{
				g_fUserMaxSpeed[iOwner] = get_user_maxspeed(iOwner);
				iCameraEntityIndex = create_3d_camera(id, iOwner);

				if(iCameraEntityIndex > 0)
				{
					set_pev(id, PEV_NPC_3RDCAMERA_ENT, iCameraEntityIndex);
					g_user_viewing[iOwner] = iCameraEntityIndex;
					set_pev(id, PEV_NPC_ACTION_DELAY, -1.0);
				}
			}
			
			static iButton;
			iButton = pev(iOwner, pev_button);
			
			if(g_user_viewing[iOwner] != iCameraEntityIndex || !iCameraEntityIndex || (iButton & IN_RELOAD))
			{
				engfunc(EngFunc_SetView, iOwner, iOwner);
				g_user_viewing[iOwner] = iOwner;

				if(pev_valid(iCameraEntityIndex))
				{
					set_pev(iCameraEntityIndex, pev_flags, FL_KILLME);
					dllfunc(DLLFunc_Think, iCameraEntityIndex);
				}

				set_pev(id, PEV_NPC_3RDCAMERA_ENT, 0);
				iCameraEntityIndex = 0;

				set_pev(id, PEV_TASK, pev(id, PEV_PREVIOUS_TASK));
				
				new weaponindex = find_ent_by_owner(-1, "weapon_knife", iOwner);
				set_user_maxspeed(iOwner, g_fUserMaxSpeed[iOwner]);
				if(weaponindex > 0) ExecuteHamB(Ham_Item_Deploy, weaponindex);

				set_pev(id, pev_nextthink, fGtime + NPC_THINK_LEN);
				return;
			}
			
			set_user_maxspeed(iOwner, -1.0);
			
			static Float:fVec[3], Float:fOriginDest[3], Float:fAngle[3];
			xs_vec_copy(fOrigin, fOriginDest);
			pev(iOwner, pev_v_angle, fAngle);
			fAngle[0] = fAngle[2] = 0.0;

			if(iButton & IN_FORWARD)
			{
				angle_vector(fAngle, ANGLEVECTOR_FORWARD, fVec);
				xs_vec_mul_scalar(fVec, fNPCspeed, fVec);
				xs_vec_add(fOriginDest, fVec, fOriginDest);
			}
			else if(iButton & IN_BACK)
			{
				angle_vector(fAngle, ANGLEVECTOR_FORWARD, fVec);
				xs_vec_mul_scalar(fVec, -fNPCspeed, fVec);
				xs_vec_add(fOriginDest, fVec, fOriginDest);
			}
			
			if(iButton & IN_MOVERIGHT)
			{
				angle_vector(fAngle, ANGLEVECTOR_RIGHT, fVec);
				xs_vec_mul_scalar(fVec, fNPCspeed, fVec);
				xs_vec_add(fOriginDest, fVec, fOriginDest);
			}
			else if(iButton & IN_MOVELEFT)
			{
				angle_vector(fAngle, ANGLEVECTOR_RIGHT, fVec);
				xs_vec_mul_scalar(fVec, -fNPCspeed, fVec);
				xs_vec_add(fOriginDest, fVec, fOriginDest);
			}
			
			if((iButton & IN_JUMP) && (iFlags & FL_ONGROUND))
			{
				fOriginDest[2] += fNPCJspeed;
			}

			static Float:fDelay = -1.0;
			pev(id, PEV_NPC_ACTION_DELAY, fDelay);
			
			if((iButton & (IN_ATTACK|IN_ATTACK2)) > 0)
			{
				if(fDelay < fGtime)
				{
					static Float:fAttackDelay; fAttackDelay = get_pcvar_float(g_iCvars[CVAR_NPC_ATTACK_DELAY]);

					if(g_sizeAnimArrays[ZTYPE][ACT_MELEE_ATTACK1] > 0)
					{
						static xArray[ANIMATION_DATA], Float:fFrameRate;
						ArrayGetArray(Array:g_animArrays[ZTYPE][ACT_MELEE_ATTACK1], random(g_sizeAnimArrays[ZTYPE][ACT_MELEE_ATTACK1]), xArray);
						fFrameRate = ( xArray[ANIMATION_FRAMES] / xArray[ANIMATION_FPS] ) / fAttackDelay;
						PlayAnimation(id, xArray[ANIMATION_SEQUENCE],
						xArray[ANIMATION_FPS], fFrameRate, xArray[ANIMATION_FRAMES], ACT_MELEE_ATTACK1,
						.bInLOOP=false,
						.pArrayEvent=Array:xArray[ANIMATION_EVENT_ARRAY],
						.pArrayEventSize=xArray[ANIMATION_EVENTS]);
					}

					set_pev(id, PEV_NPC_ACTION_DELAY, fGtime + fAttackDelay);
				}
			}
			else
			{
				// The NPC really has some where to go more than 1 unit.
				if(get_distance_f(fOrigin, fOriginDest) > 1.0)
				{
					MoveToOrigin(id, fOriginDest, fNPCspeed, fNPCJspeed, fVelocity);
				}

				NPC_animation(id, g_animArrays[ZTYPE], g_sizeAnimArrays[ZTYPE]);
			}

			if(xs_vec_distance_2d(fOrigin, fOriginDest) != 0.0)
			{
				LookAtOrigin(id, fOriginDest);
			}

			set_pev(id, pev_nextthink, fGtime + NPC_THINK_LEN);
		}
		case NPC_ATTACK:
		{
			static iVictim, Float:fHealth; fHealth = 0.0;
			if(pev_valid((iVictim = pev(id, NPC_TARGET))))
			{
				pev(iVictim, pev_health, fHealth);
			}

			if(fHealth > 0.0 && entity_takedamage_type(iVictim) != DAMAGE_NO)
			{
				static Float:fOriginDest[3], Float:fDelay = -1.0, Float:fVicViewOfs[3], Float:fVicVelocity[3], Float:fTraceAttack;
				pev(iVictim, pev_origin, fOriginDest);
				pev(iVictim, pev_view_ofs, fVicViewOfs);
				fOriginDest[2] += fVicViewOfs[2];
				xs_vec_copy(fOriginDest, fVicVelocity);
				fTraceAttack = get_pcvar_float(g_iCvars[CVAR_NPC_TRACE_ATTACK]);

				pev(id, PEV_NPC_ACTION_DELAY, fDelay);

				// NPC has no visual of the target.
				if( !IsEntityVisible(fTraceAttackOrigin, fVicVelocity, iVictim, id) )
				{
					/* npc cannot see the target. */
					static Float:fLastSeen;
					pev(id, PEV_TARGET_LAST_TIME_SEEN, fLastSeen);
					if(fGtime > (fLastSeen + 3.0) && !IsEntityVisible(fTraceAttackOrigin, fVicVelocity, iVictim, id))
					{
						set_pev(id, NPC_TARGET, 0);
					}

					fDelay = -1.0;
					NPC_animation(id, g_animArrays[ZTYPE], g_sizeAnimArrays[ZTYPE]);
				}
				else // Enemy is visible
				{
					set_pev(id, PEV_TARGET_LAST_TIME_SEEN, fGtime);

					LookAtOrigin(id, fOriginDest);

					static NPC_ACTIVITY:iAttackType, Float:fAttackDelay; fAttackDelay = g_fAttackDelay;
					iAttackType = NPCGetAttackType(id, iVictim, fTraceAttack, fTraceAttack, 800.0, 800.0, 300.0, 300.0);

					if(iAttackType != ACT_INVALID)
					{
						if(fDelay < fGtime)
						{
							fDelay = fGtime + fAttackDelay;

							if(g_sizeAnimArrays[ZTYPE][iAttackType] > 0)
							{
								static xArray[ANIMATION_DATA], Float:fFrameRate;
								ArrayGetArray(Array:g_animArrays[ZTYPE][iAttackType], random(g_sizeAnimArrays[ZTYPE][iAttackType]), xArray);
								fFrameRate = ( xArray[ANIMATION_FRAMES] / xArray[ANIMATION_FPS] ) / fAttackDelay;
								PlayAnimation(id, xArray[ANIMATION_SEQUENCE],
					                xArray[ANIMATION_FPS], fFrameRate, xArray[ANIMATION_FRAMES], iAttackType,
					                .bInLOOP=false,
					                .pArrayEvent=Array:xArray[ANIMATION_EVENT_ARRAY],
					                .pArrayEventSize=xArray[ANIMATION_EVENTS]);
							}
						}
					}
					else // Target is out of range, order to go to.
					{
						xs_vec_sub(fOriginDest, fVicViewOfs, fOriginDest);

						if(IsPlayer(iVictim))
						{
							fOriginDest[2] -= 36.0;
						}

						MoveToOrigin(id, fOriginDest, fNPCspeed, fNPCJspeed, fVelocity);
						NPC_animation(id, g_animArrays[ZTYPE], g_sizeAnimArrays[ZTYPE]);
						fDelay = -1.0;
					}
				}

				set_pev(id, PEV_NPC_ACTION_DELAY, fDelay);
			}
			else
			{
				if(!iVictim && pev(id, PEV_PREVIOUS_TASK) == NPC_FOLLOW_PLAYER)
				{
					set_pev(id, PEV_PREVIOUS_TASK, NPC_IDLE);
				}

				set_pev(id, PEV_TASK, pev(id, PEV_PREVIOUS_TASK));
				set_pev(id, NPC_TARGET, 0);
			}
			
			set_pev(id, pev_nextthink, fGtime + NPC_THINK_LEN);
		}
		case NPC_FOLLOW_PLAYER:
		{
			static Float:fOriginDest[3], iTarget;
			iTarget = pev(id, NPC_TARGET);
			pev(iTarget, pev_origin, fOriginDest);
			if(IsPlayer(iTarget)) fOriginDest[2] -= 36.0;
			
			if(!NPC_NearPlayer(iTarget, id , 150.0))
			{
				MoveToOrigin(id, fOriginDest, fNPCspeed, fNPCJspeed, fVelocity);
			}
			
			LookAtOrigin(id, fOriginDest);
			NPC_animation(id, g_animArrays[ZTYPE], g_sizeAnimArrays[ZTYPE]);
			set_pev(id, pev_nextthink, fGtime + NPC_THINK_LEN);
		}
		case NPC_KILLSELF:
		{
			new ent = MAX_PLAYERS;
			while( (ent = find_ent_by_owner(ent, NPC_GONOME_GIBS_CLASSNAME, id)) > 0)
			{
				set_pev(ent, pev_owner, 0);
			}

			remove_task(id);
			set_pev(id, pev_flags, FL_KILLME);
			dllfunc(DLLFunc_Think, id);
			return;
		}
	}

	// Lets reload ammo.
	if(!NPC_GetData(id, "RANGE_ATTACK1_AMMO"))
	{
		if(NPC_GetData(id, "RANGE_ATTACK1_RELOAD_TIME") < fGtime)
		{
			NPC_SetData(id, "RANGE_ATTACK1_AMMO", random_num(3,5));
		}
	}
}

any:NPC_GetData(const iNPC, const szDataType[])
{
	new szKey[40], any:value;
	formatex(szKey, charsmax(szKey), "#%d_%s", iNPC, szDataType);
	TrieGetCell(g_Trie_NPCData, szKey, value);
	return value;
}

NPC_SetData(const iNPC, const szDataType[], any:value)
{
	new szKey[40];
	formatex(szKey, charsmax(szKey), "#%d_%s", iNPC, szDataType);
	TrieSetCell(g_Trie_NPCData, szKey, value);
}

NPC_ACTIVITY:NPCGetAttackType(const iNPC, const iTarget,
	const Float:fTraceMeleeAttack1=0.0,   const Float:fTraceMeleeAttack2=0.0,
	const Float:fTraceRangeAttack1=0.0,   const Float:fTraceRangeAttack2=0.0,
	const Float:fTraceSpecialAttack1=0.0, const Float:fTraceSpecialAttack2=0.0)
{
	static ZTYPE, Float:fAttackDelay, Float:fVicSpeed, Float:fDelay, Float:fGameTime,
	Float:fOriginDest[3], Float:fTraceAttackOrigin[3],
	Float:fVicVelocity[3], Float:fDirection[3], Float:fViewOffset[3];

	fGameTime = get_gametime();
	pev(iNPC, pev_origin, fTraceAttackOrigin);
	pev(iNPC, pev_view_ofs, fViewOffset);
	xs_vec_add(fTraceAttackOrigin, fViewOffset, fTraceAttackOrigin);
	pev(iTarget, pev_origin, fOriginDest);
	pev(iTarget, pev_view_ofs, fViewOffset);
	fOriginDest[2] += fViewOffset[2];
	fAttackDelay = g_fAttackDelay;
	if(fAttackDelay <= 0.0) fAttackDelay = 1.0;
	pev(iTarget, pev_velocity, fVicVelocity);
	ZTYPE = pev(iNPC, PEV_NPC_CLASS);

	if(g_sizeAnimArrays[ZTYPE][ACT_SPECIAL_ATTACK1] > 0)
	{
		fDelay = NPC_GetData(iNPC, "SPECIAL_ATTACK1_DELAY");
		if(get_distance_f(fTraceAttackOrigin, fOriginDest) <= fTraceSpecialAttack1 && fDelay <= fGameTime)
		{
			return ACT_SPECIAL_ATTACK1;
		}
	}

	if(g_sizeAnimArrays[ZTYPE][ACT_SPECIAL_ATTACK2] > 0)
	{
		fDelay = NPC_GetData(iNPC, "SPECIAL_ATTACK2_DELAY");
		if(get_distance_f(fTraceAttackOrigin, fOriginDest) <= fTraceSpecialAttack2 && fDelay <= fGameTime)
		{
			return ACT_SPECIAL_ATTACK2;
		}
	}

	if(g_sizeAnimArrays[ZTYPE][ACT_RANGE_ATTACK1] > 0)
	{
		if(get_distance_f(fTraceAttackOrigin, fOriginDest) <= fTraceRangeAttack1 && NPC_GetData(iNPC, "RANGE_ATTACK1_AMMO") > 0)
		{
			return ACT_RANGE_ATTACK1;
		}
	}

	if(g_sizeAnimArrays[ZTYPE][ACT_RANGE_ATTACK2] > 0)
	{
		if(get_distance_f(fTraceAttackOrigin, fOriginDest) <= fTraceRangeAttack2 && NPC_GetData(iNPC, "RANGE_ATTACK2_AMMO") > 0)
		{
			return ACT_RANGE_ATTACK2;
		}
	}

	if(g_sizeAnimArrays[ZTYPE][ACT_MELEE_ATTACK1] > 0)
	{
		if((fVicSpeed=xs_vec_len_2d(fVicVelocity)) > 0.0)
		{
			xs_vec_sub(fOriginDest, fTraceAttackOrigin, fDirection);
			xs_vec_normalize(fDirection, fDirection);
			xs_vec_normalize(fVicVelocity, fVicVelocity);
			fVicSpeed *= xs_vec_dot(fDirection, fVicVelocity);

			if(fVicSpeed < 0.0)
			{
				fVicSpeed *= -1.0;
			}
		}

		if((get_distance_f(fTraceAttackOrigin, fOriginDest) + (fVicSpeed * fAttackDelay)) <= fTraceMeleeAttack1)
		{
			return ACT_MELEE_ATTACK1;
		}
	}

	if(g_sizeAnimArrays[ZTYPE][ACT_MELEE_ATTACK2] > 0)
	{
		if((fVicSpeed=xs_vec_len_2d(fVicVelocity)) > 0.0)
		{
			xs_vec_sub(fOriginDest, fTraceAttackOrigin, fDirection);
			xs_vec_normalize(fDirection, fDirection);
			xs_vec_normalize(fVicVelocity, fVicVelocity);
			fVicSpeed *= xs_vec_dot(fDirection, fVicVelocity);

			if(fVicSpeed < 0.0)
			{
				fVicSpeed *= -1.0;
			}
		}

		if((get_distance_f(fTraceAttackOrigin, fOriginDest) + (fVicSpeed * fAttackDelay)) <= fTraceMeleeAttack2)
		{
			return ACT_MELEE_ATTACK2;
		}
	}

	return ACT_INVALID;
}

#define ATTACHMENT_GONOME_RIGHT_HAND 0

public GonomeChestGibs_think(const ent)
{
	static Float:fVelocity[3];
	pev(ent, pev_velocity, fVelocity);
	if(xs_vec_len(fVelocity) > 0)
	{
		xs_vec_normalize(fVelocity, fVelocity);
		vector_to_angle(fVelocity, fVelocity);
		set_pev(ent, pev_angles, fVelocity);
	}
	set_pev(ent, pev_nextthink, get_gametime() + 0.01);
}

public GonomeChestGibs_touch(ent, other)
{
	if( (pev(ent, pev_flags) & FL_KILLME) || pev(other, pev_solid) == SOLID_TRIGGER )
	{
		return;
	}

	new iNPC = pev(ent, pev_owner);

	if(other > 0 && entity_takedamage_type(other) != DAMAGE_NO)
	{
		new Float:fHealth;
		pev(other, pev_health, fHealth);

		if(fHealth > 0.0)
	    {
			new iDamageBits, Float:fDamage;
			pev(ent, pev_dmg, iDamageBits);
			pev(ent, pev_dmg_save, fDamage);

			ExecuteHamB(Ham_TakeDamage, other, ent, (iNPC > 0) ? iNPC : ent, fDamage, iDamageBits);
		}
	}

	ExecuteHamB(Ham_TakeDamage, ent, other, other, 1.0, DMG_CRUSH);
}

GonomeThrowChestGibs(id)
{
	new iAmmo = NPC_GetData(id, "RANGE_ATTACK1_AMMO");
	NPC_SetData(id, "RANGE_ATTACK1_AMMO", --iAmmo);

	if(!iAmmo)
		NPC_SetData(id, "RANGE_ATTACK1_RELOAD_TIME", get_gametime() + random_float(10.0, 20.0));


	new Float:fOrigin[3], Float:fAttackOFS[3], Float:fDirection[3], Float:fVelo[3], Float:fOriginTarget[3],
	Float:fLength, Float:fHorizontalSpeed, Float:fVerticalSpeed = get_pcvar_float(g_iCvars[CVAR_NPC_GONOME_THROW_FORCE]);
	pev(id, pev_origin, fOrigin);
	pev(id, PEV_TARGET_ANGLE_DIRECTION, fDirection);
	angle_vector(fDirection, ANGLEVECTOR_FORWARD, fDirection);

	new Float:fVecStart[3], Float:fVecEnd[3], tr2 = create_tr2();
	GetAttachmentData(id, ATTACHMENT_GONOME_RIGHT_HAND, fVecStart, fVelo);
	xs_vec_mul_scalar(fDirection, 800.0, fVecEnd);

	fAttackOFS[0] = fOrigin[0];
	fAttackOFS[1] = fOrigin[1];
	fAttackOFS[2] = fVecStart[2];
	xs_vec_add(fVecEnd, fAttackOFS, fVecEnd);
	engfunc(EngFunc_TraceLine, fAttackOFS, fVecEnd, 0, id, tr2);

	get_tr2(tr2, TR_vecEndPos, fOriginTarget);
	xs_vec_sub(fOriginTarget, fVecStart, fDirection);
	xs_vec_normalize(fDirection, fDirection);
	free_tr2(tr2);

	fLength = get_distance_f(fOrigin, fOriginTarget) / fVerticalSpeed;
	fHorizontalSpeed = ((fOriginTarget[2] - fVecStart[2]) + (0.5 * 400.0 * floatpower(fLength, 2.0))) / fLength;
	fVelo[0] = fDirection[0] * fVerticalSpeed;
	fVelo[1] = fDirection[1] * fVerticalSpeed;
	fVelo[2] = fHorizontalSpeed;
	xs_vec_normalize(fVelo, fDirection);
	vector_to_angle(fDirection, fDirection);
	fDirection[0] *= -1.0;

	set_pev(id, PEV_TARGET_ANGLE_DIRECTION, fDirection);
	xs_vec_sub(fVecStart, fOrigin, fAttackOFS);
	new proj = NPC_RangeAttack1(id, fAttackOFS, get_pcvar_float(g_iCvars[CVAR_NPC_GONOME_GIB_DMG]), NPC_GONOME_GIBS_CLASSNAME, xs_vec_len(fVelo), DMG_POISON, NPC_GONOME_GIBS_MODEL, Float:{-2.0,-2.0,-2.0,2.0,2.0,2.0});
	set_pev(proj, pev_solid, SOLID_SLIDEBOX);
	set_pev(proj, pev_health, 1.0);
	set_pev(proj, pev_takedamage, DAMAGE_YES);
	set_pev(proj, pev_gravity, 0.5);
	set_pev(proj, pev_nextthink, get_gametime() + 0.01);
}

GetAttachmentData(const id, const iAttachmentID, Float:fRetOrigin[3], Float:fRetAngles[3])
{
    static szModel[64], xArray[ANIMATION_DATA], Float:fAnimeTime, Float:fFrame;
    pev(id, pev_model, szModel, charsmax(szModel));
    getSequenceData( szModel, pev(id, pev_sequence), xArray );
    pev( id, pev_animtime, fAnimeTime);
    pev( id, pev_frame, fFrame );
    set_pev( id, pev_frame, (get_gametime() - fAnimeTime) * xArray[ANIMATION_FPS] );

    static Float:fStart[3], Float:fVAngles[3], Float:fOrigin[3], Float:fVec[3];
    xs_vec_copy(fVAngles, Float:{0.0, 0.0, 0.0});
    engfunc(EngFunc_GetAttachment, id, iAttachmentID, fStart, fVAngles);
    set_pev( id, pev_frame, fFrame );

    pev(id, pev_origin, fOrigin);
    fOrigin[2] = fStart[2];

    xs_vec_sub(fStart, fOrigin, fVec);
    xs_vec_normalize(fVec, fVec);
    vector_to_angle(fVec, fVec);
    xs_vec_add(fVec, fVAngles, fVAngles);
    pev(id, pev_angles, fVec);
    xs_vec_add(fVAngles, fVec, fVAngles);

    xs_vec_copy(fStart, fRetOrigin);
    xs_vec_copy(fVAngles, fRetAngles);
}

public task_npc_event(const Params[ANIMATION_EVENTS_DATA], const id)
{
	static xArray[ANIMATION_DATA], szModel[64], NPCClass;
	pev(id, pev_model, szModel, charsmax(szModel));
	getSequenceData(szModel, pev(id, pev_sequence), xArray);
	NPCClass = pev(id, PEV_NPC_CLASS);

	switch(xArray[ANIMATION_ACTIVITY])
    {
    	case ACT_SPECIAL_ATTACK1: NPC_SetData(id, "SPECIAL_ATTACK1_DELAY", get_gametime() + 30.0);
    	case ACT_SPECIAL_ATTACK2: NPC_SetData(id, "SPECIAL_ATTACK2_DELAY", get_gametime() + 30.0);
    	case ACT_RANGE_ATTACK1:
    	{
    		if(NPCClass == ZM_CLASS_GONOME)
    		{
	    		#define ZOMBIE_GONOME_THROW_GIBS 4
	    		if(Params[EVENT_NUMBER] == ZOMBIE_GONOME_THROW_GIBS)
	    		{
	    			GonomeThrowChestGibs(id);
	    		}
	    	}
    	}
    	case ACT_RANGE_ATTACK2:
    	{
    		NPC_SetData(id, "RANGE_ATTACK2_AMMO", NPC_GetData(id, "RANGE_ATTACK2_AMMO") - 1);
    	}
    	case ACT_MELEE_ATTACK1:
    	{
    		switch(NPCClass)
    		{
	    		case ZM_CLASS_GONOME: {
		    		#define ZOMBIE_GONOME_ATTACK1_COMBO_1 1
		    		#define ZOMBIE_GONOME_ATTACK1_COMBO_2 2
		    		#define ZOMBIE_GONOME_ATTACK2_COMBO_1 19
		    		#define ZOMBIE_GONOME_ATTACK2_COMBO_2 20
		    		#define ZOMBIE_GONOME_ATTACK2_COMBO_3 21
		    		#define ZOMBIE_GONOME_ATTACK2_COMBO_4 22

		    		switch( Params[EVENT_NUMBER] )
		    		{
		    			case ZOMBIE_GONOME_ATTACK1_COMBO_1, ZOMBIE_GONOME_ATTACK1_COMBO_2,
		    			ZOMBIE_GONOME_ATTACK2_COMBO_1, ZOMBIE_GONOME_ATTACK2_COMBO_2,
		    			ZOMBIE_GONOME_ATTACK2_COMBO_3, ZOMBIE_GONOME_ATTACK2_COMBO_4:
		    			{
							emit_sound(id, CHAN_AUTO, NPC_ZOMBIE_STRIKE_SOUNDS[random(sizeof NPC_ZOMBIE_STRIKE_SOUNDS)], VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
							NPC_MeleeAttack1(id, get_pcvar_float(g_iCvars[CVAR_NPC_ATTACK_DAMAGE]), get_pcvar_float(g_iCvars[CVAR_NPC_TRACE_ATTACK]), DMG_SLASH);
		    			}
		    		}
		    	}
			    case ZM_CLASS_SOURCE: {
		    		#define ZOMBIE_SOURCE_ATTACK1_COMBO_1 1
		    		#define ZOMBIE_SOURCE_ATTACK2_COMBO_1 3
					switch( Params[EVENT_NUMBER] )
					{
						case ZOMBIE_SOURCE_ATTACK1_COMBO_1, ZOMBIE_SOURCE_ATTACK2_COMBO_1:
						{
							emit_sound(id, CHAN_AUTO, NPC_ZOMBIE_STRIKE_SOUNDS[random(sizeof NPC_ZOMBIE_STRIKE_SOUNDS)], VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
							NPC_MeleeAttack1(id, get_pcvar_float(g_iCvars[CVAR_NPC_ATTACK_DAMAGE]), get_pcvar_float(g_iCvars[CVAR_NPC_TRACE_ATTACK]), DMG_SLASH);
						}
					}
				}
	    	}
    	}
    }
}

stock beam_bet_2origin(Float:fOrigin[3], Float:fEnd[3])
{
	engfunc(EngFunc_MessageBegin, MSG_PVS, SVC_TEMPENTITY, fOrigin, 0);
	write_byte(TE_BEAMPOINTS);
	engfunc(EngFunc_WriteCoord, fOrigin[0]);
	engfunc(EngFunc_WriteCoord, fOrigin[1]);
	engfunc(EngFunc_WriteCoord, fOrigin[2]);
	engfunc(EngFunc_WriteCoord, fEnd[0]);
	engfunc(EngFunc_WriteCoord, fEnd[1]);
	engfunc(EngFunc_WriteCoord, fEnd[2]);
	write_short(g_sprite_beam);
	write_byte(0)
	write_byte(10)
	write_byte(5)
	write_byte(10)
	write_byte(1)
	write_byte(0)
	write_byte(255)
	write_byte(0)
	write_byte(255)
	write_byte(1)
	message_end();
}
