/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <sqlx>

#define PLUGIN "[ VIP ] System"
#define VERSION "2.1"
#define AUTHOR "Natsheh"

#define VIP_FILE_NAME "users_vip.ini"
#define VIP_FILE_NAME_SQL "users_vip_sql.ini"

#define MAX_FILE_DIRECTORY_LEN 64
#define INVALID_CATEGORY -1
#define INVALID_KEY -1
#define INVALID_LINE -1

enum (+=1) {
	FILE_ERROR = 0,
	FILE_CATEGORY_CREATED,
	FILE_KEYVALUE_BUFFERED,
	FILE_KEYVALUE_UPDATED,
	FILE_KEYVALUE_CREATED,
	FILE_KEYVALUE_EMPTY
}

enum _:VIP_FLAG_DATA (+=1)
{
	VIP_FLAG = 0,
	Array:VIP_FLAG_INFO
}

enum _:VIP_USER_DATA
{
	bool:VIP_USER,
	VIP_FLAGS,
	VIP_ACCESS_FLAGS,
	VIP_PASSWORD[16],
	VIP_EXPIRATION[40],
	VIP_NAME[32]
}

enum any:VIP_USER_DATA_FLAGS (<<= 1)
{
	FLAG_V_FLAGS = 1,
	FLAG_V_ACCESS,
	FLAG_V_PASSWORD,
	FLAG_V_EXPIRATION,
	FLAG_V_NAME
}

enum _:VIP_LOGIN_STATUS (<<= 1)
{
	VLOGIN_PASS = 1,
	VLOGIN_NAME,
	VLOGIN_STEAMID,
	VLOGIN_IP
}

enum _:iVIP_ACCESSFLAG (+=1)
{
	ACCESSFLAG_PASSWORD = 0,
	ACCESSFLAG_NAME,
	ACCESSFLAG_STEAMID,
	ACCESSFLAG_IPADDRESS
}

new const szVIP_ACCESSFLAG[][] = {
	"a", // include password
	"b", // name
	"c", // steamid
	"d" // ip address
}

new user_data[33][VIP_USER_DATA];

new vip_file[32] = "users_vip.ini";
new USERS_VIP_FILE[128], CONFIGS_DIR[64], TABLE_NAME[64];

new pcvar_vpassword_field, g_iMaxplayers, g_cvar_savetype, g_savetype, g_cvar_vip_sqltable;

new fw_dummy_results
new fw_vflag_creation

new Trie:g_trie_loadedvips, Trie:g_trie_flags, Array:g_array_flags, vip_flags_num, vip_existed_flags, Handle:SqlTuple = Empty_Handle;

public plugin_natives()
{
	g_trie_flags = TrieCreate();
	g_array_flags = ArrayCreate(VIP_FLAG_DATA, 1);
	g_trie_loadedvips = TrieCreate();
	
	register_library("vip_core")
	
	register_native("register_vip_flag", "_register_vip_flag");
	register_native("get_user_vip", "_get_user_vip");
	register_native("set_user_vip", "_set_user_vip");
	register_native("remove_user_vip", "_remove_user_vip");
}

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR);
	
	get_configsdir(CONFIGS_DIR, charsmax(CONFIGS_DIR));
	
	pcvar_vpassword_field = register_cvar("vip_password_field", "_vpw", FCVAR_SERVER|FCVAR_PROTECTED|FCVAR_SPONLY)
	
	register_concmd("amx_reloadvips", "concmd_reload_vips", ADMIN_IMMUNITY, "Reload vips file")
	register_concmd("amx_available_vip_flags", "concmd_check_vip_flags", ADMIN_IMMUNITY, "Check vip flags")
	register_concmd("amx_addvip", "concmd_add_vip", ADMIN_IMMUNITY, "<name/steamid/ip> <flags> <accessflags> <password> <expire>")
	register_clcmd("amx_modifievips_menu", "clcmd_modifievips_menu", ADMIN_IMMUNITY, "Modifing vips from a menu!")
	
	fw_vflag_creation = CreateMultiForward("vip_flag_creation", ET_IGNORE)
	
	ExecuteForward(fw_vflag_creation, fw_dummy_results);
	
	g_iMaxplayers = get_maxplayers();
	
	g_cvar_savetype = register_cvar("vip_save_type", "0", ADMIN_IMMUNITY);
	g_cvar_vip_sqltable = register_cvar("vip_sql_table_prefix", "vips", ADMIN_IMMUNITY);
}

new const szTimeLength[][] = {
	"Second",
	"Minute",
	"Hour",
	"Day",
	"Week",
	"Month",
	"Year",
	"Permanent"
}

new const iLengthMultiplier[] = {
	1,
	60,
	3600,
	86400,
	604800,
	2592000,
	31536000,
	0
}

public concmd_add_vip(id, level, cid)
{
	if(!cmd_access(id, level, cid, 4))
		return 1;
	
	new userid[32], userflags[64], userpassword[16], usermethod[4], expiredate[64];
	read_argv(1, userid, charsmax(userid));
	read_argv(2, userflags, charsmax(userflags));
	read_argv(3, usermethod, charsmax(usermethod));
	read_argv(4, userpassword, charsmax(userpassword));
	read_argv(5, expiredate, charsmax(expiredate));
	
	new uid = cmd_target(id, userid, (CMDTARGET_ALLOW_SELF|CMDTARGET_NO_BOTS))
	
	if(!is_user_connected(uid))
	{
		console_print(id, "user with this information is not found!")
		return 1;
	}
	
	new iExpireLength;
	trim(expiredate);
	
	for(new szTimeLength_Size = sizeof szTimeLength, i, c, x, iLen = strlen(expiredate), szNum[20], g, szTime[11]; i < iLen; i++)
	{
		if(isdigit(expiredate[i]))
		{
			if(g > 0) c = g = 0;
			
			szNum[c] = expiredate[i];
			c++;
		}
		else if( sizeof szTime > c >= 0 && isalpha(expiredate[i]) )
		{
			szTime[g] = expiredate[i];
			g++;
			
			for(x = 0; x < szTimeLength_Size; x++)
			{
				if(equali(szTimeLength[x], szTime))
				{
					iExpireLength += iLengthMultiplier[x] * str_to_num(szNum);
					g = c = 0;
					
					arrayset(szTime, 0, sizeof szTime);
					arrayset(szNum, 0, sizeof szNum);
				}
			}
		}
	}
	
	new szDateTime[40];

	if(iExpireLength > 0)
	{
		format_time(szDateTime, charsmax(szDateTime), "%m/%d/%Y - %H:%M:%S", (iExpireLength + get_systime()));
	}
	
	new iAccessMethod;
	if(containi(usermethod, szVIP_ACCESSFLAG[ACCESSFLAG_STEAMID]) != -1)
	{
		get_user_authid(uid, userid, charsmax(userid))
		iAccessMethod |= VLOGIN_STEAMID;
	}
	else if(containi(usermethod, szVIP_ACCESSFLAG[ACCESSFLAG_IPADDRESS]) != -1)
	{
		get_user_ip(uid, userid, charsmax(userid), 1)
		iAccessMethod |= VLOGIN_IP;
	}
	else if(containi(usermethod, szVIP_ACCESSFLAG[ACCESSFLAG_NAME]) != -1)
	{
		get_user_name(uid, userid, charsmax(userid))
		iAccessMethod |= VLOGIN_NAME;
	}
	
	if(containi(usermethod, szVIP_ACCESSFLAG[ACCESSFLAG_PASSWORD]) != -1)
	{
		iAccessMethod |= VLOGIN_PASS;
	}
	
	if(!iAccessMethod)
	{
		console_print(id, "Error Argument #3 Insert a valid vip accessflags ([d=IPADDRESS|c=STEAMID] & a=PASSWORD)!")
		return 1;
	}
	
	if(!strlen(userflags) || (~vip_existed_flags & read_flags(userflags)) > 0)
	{
		console_print(id, "Error Argument #2 Insert a valid vip flags (amx_available_vip_flags)!")
		return 1;
	}
	
	new szName[32];
	get_user_name(uid, szName, charsmax(szName))
	
	if(user_data[uid][VIP_USER])
	{
		if(user_data[uid][VIP_FLAGS] == read_flags(userflags) && user_data[uid][VIP_ACCESS_FLAGS] == iAccessMethod)
		{
			console_print(id, "%s is already a vip with %s flags and '%s' as accessflags!", szName, userflags, usermethod)
			return 1
		}
		
		remove_user_vip(userid, true, true);
		set_user_vip(uid, userflags, "",iAccessMethod, true, szDateTime);
		return 1;
	}
	
	if(strlen(userpassword) < 3 && (iAccessMethod & VLOGIN_PASS))
	{
		console_print(id, "Error Argument #3 The password length must be greater than 3 chars!")
		return 1;
	}
	
	log_amx("^"%s^" has been successfully added as vip with the current flags ^"%s^"!", userid, userflags)
	console_print(id, "^"%s^" has been successfully added as vip with the current flags ^"%s^"!", userid, userflags)
	
	set_user_vip(uid, userflags, userpassword, iAccessMethod, true, szDateTime)
	
	new sBuffer[128];
	formatex(sBuffer, charsmax(sBuffer), "You have been successfully^nadded as a vip!");
	if(iAccessMethod & VLOGIN_PASS)
	{
		new xCvar[16];
		get_pcvar_string(pcvar_vpassword_field, xCvar, charsmax(xCvar))
		format(sBuffer, charsmax(sBuffer), "%s ^n to login as vip ^n\
		type in-console ^n\
		setinfo ^"%s^" ^"%s^"", sBuffer, xCvar, userpassword)
	}
	
	set_hudmessage(255, 255, 255, -1.0, 0.30, 0, 6.0, 12.0)
	show_hudmessage(uid, sBuffer)
	
	return 1
}

public concmd_check_vip_flags(id, level, cid)
{
	if(!cmd_access(id, level, cid, 1))
		return 1
	
	new vip_flag_data[VIP_FLAG_DATA];
	
	console_print(id, "[AMXX] AVAILABLE VIP FLAGS:-^n^n")
	
	for(new i, k, x, szString[64]; i < vip_flags_num; i++)
	{
		ArrayGetArray(g_array_flags, i, vip_flag_data)
		console_print(id, "- FLAG ('%c')^n", vip_flag_data[VIP_FLAG])
		
		for(k = 0, x = ArraySize(vip_flag_data[VIP_FLAG_INFO]); k < x; k++)
		{
			ArrayGetString(vip_flag_data[VIP_FLAG_INFO], k, szString, charsmax(szString));
			console_print(id, "  ~ %s^n", szString)
		}
		
	}
	
	console_print(id, "^n******************************")
	
	return 1
}

public mysql_vipflags_table(const Handle:iTuple, const szTablePrefix[], const szNetAddress[])
{
	new vip_flag_data[VIP_FLAG_DATA];
	
	for(new i, k, x, szString[64], szQuery[256]; i < vip_flags_num; i++)
	{
		ArrayGetArray(g_array_flags, i, vip_flag_data)
		
		for(k = 0, x = ArraySize(vip_flag_data[VIP_FLAG_INFO]); k < x; k++)
		{
			ArrayGetString(vip_flag_data[VIP_FLAG_INFO], k, szString, charsmax(szString));
			formatex(szQuery, charsmax(szQuery), "INSERT INTO `%s_flags` ( `flag`, `server`, `info` ) VALUES ( '%c', '%s', '%s' );", szTablePrefix, vip_flag_data[VIP_FLAG], szNetAddress, szString);
			SQL_ThreadQuery(iTuple, "Ignore_query", szQuery);
		}
	}
}

public Ignore_query(failstate, Handle:query, error[], errnum, data[], size, Float:queuetime) {
	
	if(failstate != TQUERY_SUCCESS)
	{
		log_error(AMX_ERR_NATIVE, "Error Code: #%d ('%s')", errnum, error);
	}
}

new inc_password[33], cmethod[33], cflags[33], bool:flag_checking[33], user_iDate[33];

public clcmd_modifievips_menu(id, level, cid)
{
	if(!cmd_access(id, level, cid, 1))
		return 1
	
	new sText[64]
	
	formatex(sText, charsmax(sText), "\rModifie a vip^n\yChoose an Option!")
	new mvm = menu_create(sText, "modifievips_menu_handle")
	
	formatex(sText, charsmax(sText), "Delete a vip!")
	menu_additem(mvm, sText, "", 0)
	
	formatex(sText, charsmax(sText), "Add a vip!")
	menu_additem(mvm, sText, "", 0)
	
	//formatex(sText, charsmax(sText), "Edit a vip!")
	//menu_additem(mvm, sText, "", 0)
	
	flag_checking[id] = false;
	cmethod[id] = 0;
	inc_password[id] = 0;
	user_iDate[id] = 2;
	
	menu_display(id, mvm)
	
	return 1
}

public modifievips_menu_handle(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu)
		return 1;
	}
	
	switch( item )
	{
		case 0: delete_vipmenu(id)
		case 1: add_vipmenu1(id)
		//case 2: //edit_vipmenu(id)
	}
	
	return 0;
}

delete_vipmenu(id)
{
	if(!file_exists(USERS_VIP_FILE))
	{
		return -1;
	}
	
	new szBuffer[196];
	formatex(szBuffer, charsmax(szBuffer), "\rDelete a vip^n\yChoose your one!")
	new dvm = menu_create(szBuffer, "deletevip_menu_handle")
	
	new fp = fopen(USERS_VIP_FILE, "rt"), any:j, bool:bCataFound=false,
		szKey[32], gTempData[VIP_USER_DATA], szFlags[32], szAccessFlags[4], szCatagory[32];
	
	if(!fp)
	{
		return 1;
	}
	
	while(!feof(fp))
	{
		fgets(fp, szBuffer, charsmax(szBuffer));
		trim(szBuffer);
		
		if(strlen(szBuffer) < 3 || szBuffer[0] == ';' || (szBuffer[0] == '/' && szBuffer[1] == '/'))
		{
			continue;
		}
		
		if(szBuffer[0] == '[')
		{
			bCataFound = true;
			copyc(szCatagory, charsmax(szCatagory), szBuffer[1], ']');
			j = 0;
			continue;
		}

		if(bCataFound)
		{
			strtok(szBuffer, szKey, charsmax(szKey), szBuffer, charsmax(szBuffer), '=');
			trim(szKey);
			trim(szBuffer);
			remove_quotes(szKey);
			remove_quotes(szBuffer);
			
			if(!(j & FLAG_V_FLAGS) && equali(szKey, "FLAGS")) {
				gTempData[VIP_FLAGS] = read_flags(szBuffer);
				j |= FLAG_V_FLAGS;
			}
			else if(!(j & FLAG_V_ACCESS) && equali(szKey, "ACCESS_FLAGS")) {
				gTempData[VIP_ACCESS_FLAGS] = read_flags(szBuffer);
				j |= FLAG_V_ACCESS;
			}
			else if(!(j & FLAG_V_PASSWORD) && equali(szKey, "PASSWORD"))
			{
				copy(gTempData[VIP_PASSWORD], charsmax(gTempData[VIP_PASSWORD]), szBuffer)
				j |= FLAG_V_PASSWORD;
			}
			else if(!(j & FLAG_V_EXPIRATION) && equali(szKey, "EXPIRE_DATE"))
			{
				copy(gTempData[VIP_EXPIRATION], charsmax(gTempData[VIP_EXPIRATION]), (strlen(szBuffer) < 3) ? "Never":szBuffer);
				j |= FLAG_V_EXPIRATION;
			}
			else if(!(j & FLAG_V_NAME) && equali(szKey, "NAME"))
			{
				copy(gTempData[VIP_NAME], charsmax(gTempData[VIP_NAME]), szBuffer);
				j |= FLAG_V_NAME;
			}
			
			if((j & FLAG_V_FLAGS|FLAG_V_ACCESS|FLAG_V_EXPIRATION|FLAG_V_NAME) == (FLAG_V_FLAGS|FLAG_V_ACCESS|FLAG_V_EXPIRATION|FLAG_V_NAME))
			{
				if(gTempData[VIP_ACCESS_FLAGS] & VLOGIN_PASS)
				{
					if(j & (1<<VIP_PASSWORD))
					{
						get_flags(gTempData[VIP_FLAGS], szFlags, charsmax(szFlags))
						get_flags(gTempData[VIP_ACCESS_FLAGS], szAccessFlags, charsmax(szAccessFlags))
						formatex(szBuffer, charsmax(szBuffer), "\yAuthID: \r%s (%s) \
						\yAccess: \r%s \
						\yFlags: \r%s \
						\yPassword: \r%s ^n \yEXP: \r%s", szCatagory, gTempData[VIP_NAME], szAccessFlags, szFlags, gTempData[VIP_PASSWORD], gTempData[VIP_EXPIRATION]);
						menu_additem(dvm, szBuffer, szCatagory);
					}
					else // VIP Password yet is not cached.
					{
						continue;
					}
				}
				else
				{
					get_flags(gTempData[VIP_FLAGS], szFlags, charsmax(szFlags));
					get_flags(gTempData[VIP_ACCESS_FLAGS], szAccessFlags, charsmax(szAccessFlags));
					formatex(szBuffer, charsmax(szBuffer), "\yAuthID: \r%s (%s) \
					\yAccess: \r%s \
					\yFlags: \r%s ^n \yEXP: \r%s", szCatagory, gTempData[VIP_NAME], szAccessFlags, szFlags, gTempData[VIP_EXPIRATION]);
					menu_additem(dvm, szBuffer, szCatagory);
				}

				bCataFound = false;
			}
		}
	}
	fclose(fp);
	
	if(!menu_items(dvm))
	{
		menu_destroy(dvm);
		return 1;
	}
	
	menu_setprop(dvm, MPROP_PERPAGE, 5);
	
	menu_display(id, dvm)
	
	return 1
}

public deletevip_menu_handle(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu);
		return 1;
	}
	
	if(!file_exists(USERS_VIP_FILE))
	{
		return 1;
	}
	
	new sData[32];
	new iAccess, iCallback
	menu_item_getinfo(menu, item, iAccess, sData, charsmax(sData), _, 0, iCallback)
	
	menu_destroy(menu);
	
	remove_user_vip(sData, true, true);
	log_amx("(%s) user with this data has been successfully deleted from vip!", sData)
	client_print(id, print_center, "You have successfully deleted this user from the vip!")
	server_cmd("amx_reloadvips")
	
	return 1;
}

add_vipmenu1(id)
{
	new sText[96]
	
	formatex(sText, charsmax(sText), "\rAdd a vip^n\yChoose an method!");
	new avm1 = menu_create(sText, "addvip_menu_handle1");
	
	formatex(sText, charsmax(sText), "SteamID");
	menu_additem(avm1, sText, "", 0)
	
	formatex(sText, charsmax(sText), "IPAddress");
	menu_additem(avm1, sText, "", 0)
	
	formatex(sText, charsmax(sText), "Name");
	menu_additem(avm1, sText, "", 0)
	
	formatex(sText, charsmax(sText), "\rInclude a Password: \y%s", !inc_password[id] ? "No":"Yes");
	menu_additem(avm1, sText, "", 0);
	
	if(!inc_password[id])
		formatex(sText, charsmax(sText), "\rRandom Password: \y?\r?\y?\r?^n");
	else
		formatex(sText, charsmax(sText), "\rRandom Password: \y%d^n", inc_password[id]);
	menu_additem(avm1, sText, "", 0);
	
	if(!iLengthMultiplier[user_iDate[id]])
		formatex(sText, charsmax(sText), "\rExpiration-Date: \yNever!");
	else
	{
		new szDate[40];
		format_time(szDate, charsmax(szDate), "%m/%d/%Y - %H:%M:%S", (get_systime() + iLengthMultiplier[user_iDate[id]]));
		formatex(sText, charsmax(sText), "\rExpiration-Date: \y%s \w+%s", szDate, szTimeLength[user_iDate[id]]);
	}
	
	menu_additem(avm1, sText, "", 0);
	
	menu_display(id, avm1);
}

public addvip_menu_handle1(id, menu, item)
{
	menu_destroy(menu);
	
	if(item == MENU_EXIT)
	{
		return 1;
	}
	
	switch( item )
	{
		case 0: cmethod[id] |= VLOGIN_STEAMID;
		case 1: cmethod[id] |= VLOGIN_IP;
		case 2: cmethod[id] |= VLOGIN_NAME;
		case 3:
		{
			if(cmethod[id] & VLOGIN_PASS)
				cmethod[id] &= ~VLOGIN_PASS;
			else
				cmethod[id] |= VLOGIN_PASS;
			
			inc_password[id] = !inc_password[id] ? random_num(1000, 9999):0
			
			add_vipmenu1(id);
			return 1;
		}
		case 4:
		{
			inc_password[id] = random_num(1000, 9999)
			
			add_vipmenu1(id)
			return 1;
		}
		case 5:
		{
			if(user_iDate[id] >= charsmax(szTimeLength))
				user_iDate[id] = 2;
			else
				user_iDate[id] = clamp(++user_iDate[id], 2, charsmax(szTimeLength));
			add_vipmenu1(id);
			return 1;
		}
	}
	
	add_vipmenu2(id);
	return 1;
}

add_vipmenu2(id)
{
	new sText[96], szFlags[32];
	get_flags(cflags[id], szFlags, charsmax(szFlags));
	
	formatex(sText, charsmax(sText), "\rAdd flags for vip^n\yChosen flags: %s", szFlags);
	new avm2 = menu_create(sText, "addvip_menu_handle2");
	
	formatex(sText, charsmax(sText), "%sSubmit!", (flag_checking[id] || !cflags[id]) ? "\d":"\y");
	menu_additem(avm2, sText, "", 0);
	
	formatex(sText, charsmax(sText), "%sFlags Info!", !flag_checking[id] ? "\d":"\y");
	menu_additem(avm2, sText, "", 0);
	
	new vip_flag_data[VIP_FLAG_DATA];
	for(new i, szString[32], szFlag[2]; i < vip_flags_num; i++)
	{
		ArrayGetArray(g_array_flags, i, vip_flag_data);
		
		szFlag[0] = vip_flag_data[VIP_FLAG];
		formatex(sText, charsmax(sText), "%s%c",
			(cflags[id] & read_flags(szFlag) || flag_checking[id]) ? "\d":"\r", vip_flag_data[VIP_FLAG]);
		num_to_str(i, szString, charsmax(szString));
		menu_additem(avm2, sText, szString, 0);
	}
	
	menu_display(id, avm2);
}


public addvip_menu_handle2(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu);
		return 1;
	}
	
	new sData[32];
	new paccess, callback;
	menu_item_getinfo(menu, item, paccess, sData, charsmax(sData), "", 0, callback);
	
	menu_destroy(menu);
	
	switch( item )
	{
		case 0:
		{
			if(!flag_checking[id])
			{
				add_vipmenu3(id)
				return 1;
			}
		}
		case 1:
		{
			flag_checking[id] = flag_checking[id] ? false:true
		}
		default: 
		{
			new iData = str_to_num(sData);
			
			if(flag_checking[id])
			{
				vflags_info_menu(id, iData);
				return 1;
			}
			
			new vip_flag_data[VIP_FLAG_DATA];
			ArrayGetArray(g_array_flags, iData, vip_flag_data);
			
			new szFlag[2];
			szFlag[0] = vip_flag_data[VIP_FLAG];
			new iFlag = read_flags(szFlag);
			
			if(cflags[id] & iFlag)
			{
				cflags[id] &= ~iFlag;
			}
			else
			{
				cflags[id] |= iFlag;
			}
		}
	}
	
	add_vipmenu2(id)
	return 1;
}

vflags_info_menu(id, Flag_ID)
{
	new sText[96], sString[64], vip_flag_data[VIP_FLAG_DATA];
	
	ArrayGetArray(g_array_flags, Flag_ID, vip_flag_data)
	new Array:g_array_flag_info = vip_flag_data[VIP_FLAG_INFO],
	vflags_info_size = ArraySize(g_array_flag_info);
	
	formatex(sText, charsmax(sText), "\rFlag-Info: \y%c", vip_flag_data[VIP_FLAG])
	new avmfi = menu_create(sText, "vflags_info_menu_handle")
	
	menu_additem(avmfi, "\rReturn\r!^n", "", 0)
	
	for(new i = 0; i < vflags_info_size; i++)
	{
		ArrayGetString(g_array_flag_info, i, sString, charsmax(sString))
		menu_addtext(avmfi, sString)
	}
	
	menu_display(id, avmfi)
}


public vflags_info_menu_handle(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu)
		return 1;
	}
	
	menu_destroy(menu);
	
	switch( item )
	{
		case 0:
		{
			add_vipmenu2(id)
		}
	}
	return 1;
}


add_vipmenu3(id)
{
	new sText[96];
	
	formatex(sText, charsmax(sText), "\rAdd a vip^n\yChoose your one!")
	new avm3 = menu_create(sText, "addvip_menu_handle3")
	
	new players[32], pnum
	get_players(players, pnum, "ch")
	
	if(!pnum)
	{
		menu_destroy(avm3);
		client_print(id, print_center, "~ No Players Remaning ! ~")
		return;
	}
	
	new Sname[32], sData[2]
	
	for(new i = 0, player; i < pnum; i++)
	{
		player = players[i];
		get_user_name(player, Sname, charsmax(Sname))
		formatex(sText, charsmax(sText), "%s %s", user_data[player][VIP_USER] ? "\r":"\y", Sname)
		
		sData[0] = player;
		menu_additem(avm3, sText, sData, 0)
	}
	
	menu_display(id, avm3);
	return;
}

public addvip_menu_handle3(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu)
		return 1;
	}
	
	new sData[2], sName[64]
	new iAccess, iCallback
	menu_item_getinfo(menu, item, iAccess, sData, charsmax(sData), sName, charsmax(sName), iCallback)
	
	menu_destroy(menu);
	
	new userflags[32], userid[32], userpassword[16];
	
	if(sName[1] == 'd' && sName[0] == '\')
	{
		add_vipmenu3(id)
		return 1;
	}
	
	new uid = sData[0];
	
	if(cmethod[id] & VLOGIN_STEAMID)
	{
		get_user_authid(uid, userid, charsmax(userid))
	}
	else if(cmethod[id] & VLOGIN_IP)
	{
		get_user_ip(uid, userid, charsmax(userid), 1)
	}
	else if(cmethod[id] & VLOGIN_NAME)
	{
		get_user_name(uid, userid, charsmax(userid))
	}
	
	get_flags(cflags[id], userflags, charsmax(userflags));
	
	new sBuffer[128];
	formatex(sBuffer, charsmax(sBuffer), "You have been successfully^nadded as a vip!")
	
	if(cmethod[id] & VLOGIN_PASS)
	{
		new xCvar[16];
		get_pcvar_string(pcvar_vpassword_field, xCvar, charsmax(xCvar))
		set_user_info(uid, xCvar, userpassword)
		copy(userpassword, charsmax(userpassword), inc_password[id]);
		format(sBuffer, charsmax(sBuffer), "%s ^n to login as vip ^n\
		type in-console^nsetinfo ^"%s^" ^"%s^"", sBuffer, xCvar, userpassword)
	}
	
	new szDate[40];
	if(!iLengthMultiplier[user_iDate[id]])
		copy(szDate, charsmax(szDate), "0");
	else
		format_time(szDate, charsmax(szDate), "%m/%d/%Y - %H:%M:%S", (get_systime() + iLengthMultiplier[user_iDate[id]]))
	set_user_vip(uid, userflags, userpassword, cmethod[id], true, szDate);
	
	log_amx("^"%s^" has been successfully added as vip with the current flags ^"%s^"!", userid, userflags)
	console_print(id, "^"%s^" has been successfully added as vip with the current flags ^"%s^"!", userid, userflags)
	
	set_hudmessage(255, 255, 255, -1.0, 0.30, 0, 6.0, 12.0);
	show_hudmessage(uid, sBuffer);
 
	return 1;
}

public plugin_end()
{
	if(SqlTuple != Empty_Handle) SQL_FreeHandle(SqlTuple);
	TrieDestroy(g_trie_flags);
	TrieDestroy(g_trie_loadedvips);
	ArrayDestroy(g_array_flags);
}

public plugin_cfg()
{
	g_savetype = get_pcvar_num(g_cvar_savetype);
	
	switch( g_savetype )
	{
		case 1:
		{
			copy(vip_file, charsmax(vip_file), VIP_FILE_NAME_SQL);
			formatex(USERS_VIP_FILE, charsmax(USERS_VIP_FILE), "%s/%s", CONFIGS_DIR, vip_file);
			
			delete_file(USERS_VIP_FILE);
			
			if(SqlTuple == Empty_Handle) SqlTuple = SQL_MakeStdTuple();
			new iError, szError[512];
			
			new Handle:SqlConnection = SQL_Connect(SqlTuple, iError, szError, charsmax(szError));
			
			if(SqlConnection == Empty_Handle)
			{
				log_error(AMX_ERR_NATIVE, "Error #%d (%s)", iError, szError);
				
				
				copy(vip_file, charsmax(vip_file), VIP_FILE_NAME);
				log_amx("Failed to connect to DataBase loading vip from file!")
				console_print(0, "[AMXX] Loading vip from server file ^n [%d] VIP are active!", reload_vips());
				return;
			}
			
			new szTablePrefix[32], szNetAddress[32], iCount;
			get_pcvar_string(g_cvar_vip_sqltable, szTablePrefix, charsmax(szTablePrefix));
			get_cvar_string("net_address", szNetAddress, charsmax(szNetAddress));
			formatex(TABLE_NAME, charsmax(TABLE_NAME), "%s_%s", szTablePrefix, szNetAddress)
			
			SQL_QueryAndIgnore(SqlConnection, "CREATE TABLE IF NOT EXISTS `%s_flags` ( flag CHAR NOT NULL, server VARCHAR(32) NOT NULL, info VARCHAR(64) NOT NULL );", szTablePrefix);
			
			SQL_QueryAndIgnore(SqlConnection, "DELETE FROM `%s_flags` WHERE `server`='%s';", szTablePrefix, szNetAddress);
			
			SQL_QueryAndIgnore(SqlConnection, "CREATE TABLE IF NOT EXISTS `%s_global` ( \
			`name`VARCHAR( 32 ) NOT NULL,\
			`auth` VARCHAR( 32 ) NOT NULL PRIMARY KEY UNIQUE,\
			`password` VARCHAR( 32 ) NOT NULL,\
			`access` VARCHAR( 6 ) NOT NULL,\
			`expire` VARCHAR( 32 ) NOT NULL,\
			`created` VARCHAR( 32 ) NOT NULL ) COMMENT = 'VIPS'", szTablePrefix);
			
			SQL_QueryAndIgnore(SqlConnection, "CREATE TABLE IF NOT EXISTS `%s` ( \
			`name`VARCHAR( 32 ) NOT NULL,\
			`auth` VARCHAR( 32 ) NOT NULL PRIMARY KEY UNIQUE,\
			`password` VARCHAR( 32 ) NOT NULL,\
			`access` VARCHAR( 6 ) NOT NULL,\
			`flags` VARCHAR( 32 ) NOT NULL,\
			`expire` VARCHAR( 32 ) NOT NULL,\
			`created` VARCHAR( 32 ) NOT NULL ) COMMENT = 'VIPS'", TABLE_NAME);
			new Handle:iQuery = SQL_PrepareQuery(SqlConnection, "SELECT `name`,`auth`,`password`,`access`,`flags`,`expire` FROM `%s`", TABLE_NAME)
			
			if(!SQL_Execute(iQuery))
			{
				SQL_QueryError(iQuery, szError, charsmax(szError));
				log_error(AMX_ERR_NATIVE, "Can't load vips ERROR: %s", szError);
			}
			else if(!SQL_NumResults(iQuery))
			{
				log_amx("No VIPs were registered!");
			}
			else {
				/** do this incase people change the query order and forget to modify below */
				new qcolName = SQL_FieldNameToNum(iQuery, "name");
				new qcolAuth = SQL_FieldNameToNum(iQuery, "auth");
				new qcolPass = SQL_FieldNameToNum(iQuery, "password");
				new qcolAccess = SQL_FieldNameToNum(iQuery, "access");
				new qcolFlags = SQL_FieldNameToNum(iQuery, "flags");
				new qcolExpire = SQL_FieldNameToNum(iQuery, "expire");
				
				new NameData[32];
				new AuthData[32];
				new Password[32];
				new Access[32];
				new Flags[32];
				new ExpireDate[32];
				
				while (SQL_MoreResults(iQuery))
				{
					SQL_ReadResult(iQuery, qcolName, NameData, charsmax(NameData));
					SQL_ReadResult(iQuery, qcolAuth, AuthData, charsmax(AuthData));
					SQL_ReadResult(iQuery, qcolPass, Password, charsmax(Password));
					SQL_ReadResult(iQuery, qcolAccess, Access, charsmax(Access));
					SQL_ReadResult(iQuery, qcolFlags, Flags, charsmax(Flags));
					SQL_ReadResult(iQuery, qcolExpire, ExpireDate, charsmax(ExpireDate));
			
					get_file_keyvalue(vip_file, AuthData, "NAME", NameData, charsmax(NameData));
					get_file_keyvalue(vip_file, AuthData, "FLAGS", Flags, charsmax(Flags));
					get_file_keyvalue(vip_file, AuthData, "ACCESS_FLAGS", Access, charsmax(Access));
					get_file_keyvalue(vip_file, AuthData, "PASSWORD", Password, charsmax(Password));
					get_file_keyvalue(vip_file, AuthData, "EXPIRE_DATE", ExpireDate, charsmax(ExpireDate));
					
					SQL_NextRow(iQuery);
					
					iCount ++;
				}
			}
			
			server_print("[AMXX] %d vips loaded from the database!^n", iCount);
			
			SQL_FreeHandle(iQuery);
			SQL_FreeHandle(SqlConnection);
			
			mysql_vipflags_table(SqlTuple, szTablePrefix, szNetAddress);
		}
		default:
		{
			copy(vip_file, charsmax(vip_file), VIP_FILE_NAME);
			formatex(USERS_VIP_FILE, charsmax(USERS_VIP_FILE), "%s/%s", CONFIGS_DIR, vip_file);
		}
	}
	
	console_print(0, "[AMXX] %d vips are loaded!", reload_vips());
}

public concmd_reload_vips(id, level, cid)
{
	if(!cmd_access(id, level, cid, 1))
		return 1
	
	clear_vips();
	plugin_cfg();
	console_print(id, "[AMXX] VIPs has been successfully reloaded!");
	return 1
}

clear_vips()
{
	TrieClear(g_trie_loadedvips);

	new players[32], pnum
	get_players(players, pnum, "ch")
	
	for(new i = 0; i < pnum; i++)
	{
		remove_user_vip(players[i], false);
	}
}

reload_vips()
{
	new loaded = load_vips_from_ini_file();
	
	new players[32], pnum;
	get_players(players, pnum, "ch");
	
	for(new i; i < pnum; i++)
	{
		check_user_vip(players[i]);
	}
	
	return loaded;
}

load_vips_from_ini_file()
{
	new fp = fopen(USERS_VIP_FILE, "rt");
	
	if(!fp) return -1;
	
	new szBuffer[128], szKey[32], szCatagory[32], gTempData[VIP_USER_DATA], j, iCount;
	
	while(!feof(fp))
	{
		fgets(fp, szBuffer, charsmax(szBuffer));
		trim(szBuffer);
		
		if(strlen(szBuffer) < 3 || szBuffer[0] == ';' || (szBuffer[0] == '/' && szBuffer[1] == '/'))
		{
			continue;
		}
		
		if(szBuffer[0] == '[')
		{
			j = 0;
			copyc(szCatagory, charsmax(szCatagory), szBuffer[1], ']');
			continue;
		}
			
		if(szCatagory[0] != EOS)
		{
			strtok(szBuffer, szKey, charsmax(szKey), szBuffer, charsmax(szBuffer), '=');
			trim(szKey);
			trim(szBuffer);
			remove_quotes(szKey);
			remove_quotes(szBuffer);
			
			if(!(j & FLAG_V_FLAGS) && equali(szKey, "FLAGS")) {
				gTempData[VIP_FLAGS] = read_flags(szBuffer);
				j |= FLAG_V_FLAGS;
			}
			else if(!(j & FLAG_V_ACCESS) && equali(szKey, "ACCESS_FLAGS")) {
				gTempData[VIP_ACCESS_FLAGS] = read_flags(szBuffer);
				j |= FLAG_V_ACCESS;
			}
			else if(!(j & FLAG_V_PASSWORD) && equali(szKey, "PASSWORD"))
			{
				copy(gTempData[VIP_PASSWORD], charsmax(gTempData[VIP_PASSWORD]), szBuffer)
				j |= FLAG_V_PASSWORD;
			}
			else if(!(j & FLAG_V_EXPIRATION) && equali(szKey, "EXPIRE_DATE"))
			{
				copy(gTempData[VIP_EXPIRATION], charsmax(gTempData[VIP_EXPIRATION]), szBuffer)
				j |= FLAG_V_EXPIRATION;
			}
			
			if((j & (FLAG_V_EXPIRATION|FLAG_V_FLAGS|FLAG_V_ACCESS)) == (FLAG_V_EXPIRATION|FLAG_V_FLAGS|FLAG_V_ACCESS))
			{
				if(gTempData[VIP_ACCESS_FLAGS] & VLOGIN_PASS)
				{
					if(j & FLAG_V_PASSWORD)
					{
						TrieSetArray(g_trie_loadedvips, szCatagory, gTempData, sizeof gTempData);
						szCatagory[0] = EOS;
						iCount++;
					}
				}
				else
				{
					TrieSetArray(g_trie_loadedvips, szCatagory, gTempData, sizeof gTempData);
					szCatagory[0] = EOS;
					iCount++;
				}
			}
		}
	}
	fclose(fp);

	return iCount;
}
	

check_user_vip(id)
{
	static gTempData[VIP_USER_DATA], sAuthid[32], sCvar[16], sInfo[16];

	get_user_authid(id, sAuthid, charsmax(sAuthid));

	if(!TrieKeyExists(g_trie_loadedvips, sAuthid))
	{
		get_user_name(id, sAuthid, charsmax(sAuthid));

		if(!TrieKeyExists(g_trie_loadedvips, sAuthid))
		{
			get_user_ip(id, sAuthid, charsmax(sAuthid), 1);

			if(!TrieKeyExists(g_trie_loadedvips, sAuthid))
			{
				return false;
			}
		}
	}

	TrieGetArray(g_trie_loadedvips, sAuthid, gTempData, sizeof gTempData);

	if(gTempData[VIP_ACCESS_FLAGS] & VLOGIN_PASS)
	{
		get_pcvar_string(pcvar_vpassword_field, sCvar, charsmax(sCvar))
		get_user_info(id, sCvar, sInfo, charsmax(sInfo))
		
		if(!equal(gTempData[VIP_PASSWORD], sInfo))
		{
			server_cmd("kick ^"#%d^" ^"Please enter the vip password to login!^"", get_user_userid(id));
			return false;
		}
	}
	
	new szFlags[32];
	get_flags(gTempData[VIP_FLAGS], szFlags, charsmax(szFlags));
	set_user_vip(id, szFlags, gTempData[VIP_PASSWORD], gTempData[VIP_ACCESS_FLAGS],false,gTempData[VIP_EXPIRATION]);
	return true;
}

public client_authorized(id)
{
	if(is_user_bot(id) || is_user_hltv(id))
		return;
	
	check_user_vip(id);
}

#if AMXX_VERSION_NUM > 182
public client_disconnected(id)
#else
public client_disconnect(id)
#endif
{
	if(is_user_bot(id) || is_user_hltv(id))
		return;

	user_data[id][VIP_USER] = false;
	user_data[id][VIP_FLAGS] = 0;
	user_data[id][VIP_ACCESS_FLAGS] = 0;
	user_data[id][VIP_PASSWORD][0] = 0;

	remove_task(id);
}

public client_infochanged(id)
{
	new newname[32], oldname[32]
	get_user_name(id, oldname, charsmax(oldname))
	get_user_info(id, "name", newname, charsmax(newname))
	
	if(!equal(oldname, newname))
	{
		if(user_data[id][VIP_USER] && user_data[id][VIP_ACCESS_FLAGS] & VLOGIN_NAME)
		{
			remove_user_vip(oldname, true);
			check_user_vip(id);
		}
	}
	return 0;
}

public vip_expired(param[], index)
{
	remove_user_vip(param, true, true);
	
	client_print(index, print_chat, "Your vip package has expired!");

	log_amx("Player with authid '%s' VIP package has expired!", param);
}

public _set_user_vip(plugin, cid)
{
	new szFlags[32], szPw[32], szDate[32];
	get_string(2, szFlags, charsmax(szFlags));
	get_string(3, szPw, charsmax(szPw));
	get_string(6, szDate, charsmax(szDate));
	return set_user_vip(get_param(1), szFlags, szPw, get_param(4), get_param(5) == 1 ? true:false, szDate);
}

set_user_vip(index, const vflags[], const password[]="", const method=VLOGIN_STEAMID, const bool:bSaveInFile=false, szExpireDate[])
{
	new szAuthid[32], Float:fLength;
	if( method & VLOGIN_STEAMID ) {
		get_user_authid(index, szAuthid, charsmax(szAuthid));
	}
	else if( method & VLOGIN_IP ) {
		get_user_ip(index, szAuthid, charsmax(szAuthid), 1);
	}
	else if( method & VLOGIN_NAME ) {
		get_user_name(index, szAuthid, charsmax(szAuthid));
	}

	if(szExpireDate[0] != 0 && !equal(szExpireDate, "0") && strlen(szExpireDate) > 3)
	{
		fLength = floatmax(float(parse_time(szExpireDate, "%m/%d/%Y - %H:%M:%S") - get_systime()), 1.0);
		set_task(fLength, "vip_expired", index, szAuthid, sizeof(szAuthid));
	}

	new iVFlags = (vip_existed_flags & read_flags(vflags));
	
	if(!iVFlags)
	{
		return 0;
	}
	
	new szName[32], szFlags[32];
	get_user_name(index, szName, charsmax(szName))
	get_flags(iVFlags, szFlags, charsmax(szFlags))
	
	user_data[index][VIP_USER] = true;
	user_data[index][VIP_FLAGS] = iVFlags;
	user_data[index][VIP_ACCESS_FLAGS] = method;
	copy(user_data[index][VIP_NAME], charsmax(user_data[][VIP_NAME]), szName);
	
	log_amx("#%d %s has login as vip with the current flags ^"%s^", expire date: %s / %.2f seconds left!", get_user_userid(index), szName, szFlags, szExpireDate, fLength);
	console_print(index, "You have been successfully logged in as vip!");
	client_print(index, print_center, "You have been successfully logged in as vip!");

	new aTempRecord[VIP_USER_DATA];
	aTempRecord[VIP_USER] = true;
	aTempRecord[VIP_FLAGS] = iVFlags;
	aTempRecord[VIP_ACCESS_FLAGS] = method;
	copy(aTempRecord[VIP_PASSWORD], charsmax(aTempRecord[VIP_PASSWORD]), password);
	copy(aTempRecord[VIP_EXPIRATION], charsmax(aTempRecord[VIP_EXPIRATION]), szExpireDate);
	copy(aTempRecord[VIP_NAME], charsmax(aTempRecord[VIP_NAME]), szName);
	TrieSetArray(g_trie_loadedvips, szAuthid, aTempRecord, sizeof aTempRecord);
	
	if(bSaveInFile)
	{
		get_file_keyvalue(vip_file, szAuthid, "NAME", szName);
		get_file_keyvalue(vip_file, szAuthid, "FLAGS", szFlags);
		get_file_keyvalue(vip_file, szAuthid, "EXPIRE_DATE", szExpireDate);
		
		new szAccessFlags[4];
		get_flags(method, szAccessFlags, charsmax(szAccessFlags));
		
		if(user_data[index][VIP_ACCESS_FLAGS] & VLOGIN_PASS)
		{
			copy(szFlags, charsmax(szFlags), password);
			get_file_keyvalue(vip_file, szAuthid, "PASSWORD", szFlags);
			szAccessFlags[1] = szVIP_ACCESSFLAG[ACCESSFLAG_PASSWORD][0];
		}
		
		get_file_keyvalue(vip_file, szAuthid, "ACCESS_FLAGS", szAccessFlags);
		
		if(g_savetype == 1)
		{
			new iError, szError[512];
			
			new Handle:SqlConnection = SQL_Connect(SqlTuple, iError, szError, charsmax(szError))
			
			if(SqlConnection == Empty_Handle)
			{
				log_error(AMX_ERR_NATIVE, "Error #%d (%s)", iError, szError);
			}
			else
			{
				new szCreated[40], szTablePrefix[32];
				get_pcvar_string(g_cvar_vip_sqltable, szTablePrefix, charsmax(szTablePrefix));
				format_time(szCreated, charsmax(szCreated), "%m/%d/%Y - %H:%M:%S");
				
				new Handle:iQuery = SQL_PrepareQuery(SqlConnection, "REPLACE INTO `%s` (`name`,`auth`,`password`,`access`,`flags`,`expire`,`created`) VALUES ('%s','%s','%s','%s','%s','%s','%s'); \
										REPLACE INTO `%s_global` (`name`,`auth`,`password`,`access`,`flags`,`expire`,`created`) VALUES ('%s','%s','%s','%s','%s','%s','%s');",
				TABLE_NAME, szName, szAuthid, password, szAccessFlags, szFlags, szExpireDate, szCreated,
				szTablePrefix, szName, szAuthid, password, szAccessFlags, szFlags, szExpireDate, szCreated)
				
				if(!SQL_Execute(iQuery))
				{
					new szError[512];
					SQL_QueryError(iQuery, szError, charsmax(szError))
					log_error(AMX_ERR_NATIVE, "Failed to insert vip user into the database!");
					log_error(AMX_ERR_NATIVE, szError);
				}
				
				SQL_FreeHandle(iQuery);
				SQL_FreeHandle(SqlConnection);
			}
		}
		return 2;
	}
	
	return 1;
}

public _remove_user_vip(plugin, cid)
{
	new szAuthid[32];
	get_string(1, szAuthid, charsmax(szAuthid))
	remove_user_vip(szAuthid, get_param(2) == 1 ? true:false, get_param(3) == 1 ? true:false);
}

remove_user_vip(const authid[], const bool:bLog=false, const bool:bPermanent=false)
{
	new index = find_player("ah", authid);
	if(!index) index = find_player("ch", authid);
	if(!index) index = find_player("dh", authid);
	if(is_user_connected(index))
	{
		new szName[32]
		get_user_name(index, szName, charsmax(szName))
		
		if(bLog)
		{
			new szFlags[32];
			get_flags(user_data[index][VIP_FLAGS], szFlags, charsmax(szFlags));
			log_amx("#%d %s is no longer vip with the current flags ^"%s^"", get_user_userid(index), szName, szFlags);
			client_print(index, print_center, "You are no longer a vip!");
		}
	}
	
	if(index > 0)
	{
		user_data[index][VIP_USER] = false;
		user_data[index][VIP_FLAGS] = 0;
		user_data[index][VIP_ACCESS_FLAGS] = 0;
		user_data[index][VIP_PASSWORD][0] = 0;
	}
	
	if(bPermanent)
	{
		// Remove the record.
		TrieDeleteKey(g_trie_loadedvips, authid);

		new fp = fopen(USERS_VIP_FILE, "rt"), sFile2[128];

		if( !fp )
		{
			return;
		}
		
		formatex(sFile2, charsmax(sFile2), "%s2", USERS_VIP_FILE);
		new fp2 = fopen(sFile2, "wt"), szCata[32], sBuffer[128], bool:bRemoval=false;
		
		if( !fp2 )
		{
			fclose(fp);
			return;
		}

		fseek(fp, 0, SEEK_SET);
		while(!feof(fp))
		{
			fgets(fp, sBuffer, charsmax(sBuffer));
			trim(sBuffer);
			replace(sBuffer, charsmax(sBuffer), "^n", "");
				
			if(sBuffer[0] == EOS || sBuffer[0] == ';' || strlen(sBuffer) <= 3 || (sBuffer[0] == '/' && sBuffer[1] == '/'))
			{
				fputs(fp2, sBuffer);
				fputc(fp2, '^n');
				continue;
			}
				
			if(sBuffer[0] == '[')
			{
				bRemoval = false;
				
				copyc(szCata, charsmax(szCata), sBuffer[1], ']');
				if(equal(szCata, authid))
				{
					bRemoval = true;
				}
			}
			
			if(bRemoval)
			{
				format(sBuffer, charsmax(sBuffer), "; %s", sBuffer);
				fputs(fp2, sBuffer);
				fputc(fp2, '^n');
				continue;
			}

			fputs(fp2, sBuffer);
			fputc(fp2, '^n');
		}
		fclose(fp);
		fclose(fp2);
			
		delete_file(USERS_VIP_FILE);
		
		if(!rename_file(sFile2, USERS_VIP_FILE, 1))
		{
			delete_file(sFile2);
		}
		
		if(g_savetype == 1)
		{
			new iError, szError[512];
			
			new Handle:SqlConnection = SQL_Connect(SqlTuple, iError, szError, charsmax(szError))
			
			if(SqlConnection == Empty_Handle)
			{
				log_error(AMX_ERR_NATIVE, "Error #%d (%s)", iError, szError);
			}
			else
			{
				new Handle:iQuery = SQL_PrepareQuery(SqlConnection, "DELETE FROM `%s` WHERE `auth`='%s';", TABLE_NAME, authid)
				
				if(!SQL_Execute(iQuery))
				{
					new szError[512];
					SQL_QueryError(iQuery, szError, charsmax(szError))
					log_error(AMX_ERR_NATIVE, "Failed to delete vip user from the database!");
					log_error(AMX_ERR_NATIVE, szError);
				}
				
				SQL_FreeHandle(iQuery);
				SQL_FreeHandle(SqlConnection);
			}
		}
	}
}

public _register_vip_flag(plugin, argc)  // native
{
	new szFlag[2], iFlag;
	szFlag[0] = get_param(1);
	iFlag = read_flags(szFlag);
	
	if(!isalpha(szFlag[0]))
	{
		log_error(AMX_ERR_PARAMS, "Error couldn't create a vip flag ^"%c^", vip flag must be an alphabet!", szFlag[0])
		return -3;
	}
	
	new flag_existed = -1, szFlagInfo[64];
	get_string(2, szFlagInfo, charsmax(szFlagInfo));
	
	if(TrieKeyExists(g_trie_flags, szFlag))
	{
		TrieGetCell(g_trie_flags, szFlag, flag_existed)
	}
	
	if(flag_existed >= 0)
	{
		ArrayPushString(any:flag_existed, szFlagInfo);
		return 1;
	}
	
	new vip_flag_data[VIP_FLAG_DATA];
	vip_existed_flags |= iFlag;
	vip_flag_data[VIP_FLAG] = szFlag[0];
	new Array:iArray = vip_flag_data[VIP_FLAG_INFO] = any:ArrayCreate(64,1);
	ArrayPushArray(g_array_flags, vip_flag_data);
	ArrayPushString(iArray, szFlagInfo);
	TrieSetCell(g_trie_flags, szFlag, _:iArray);
	
	vip_flags_num ++;
	return vip_flags_num-1;
}

public _get_user_vip(plugin, cid) // native
{
	new index = get_param(1);
	
	if(!(1 <= index <= g_iMaxplayers))
	{
		return 0;
	}
	
	return user_data[index][VIP_FLAGS];
}

get_file_keyvalue(const file[], const cata[], const key[], value[], len=0)
{
	static sFile[MAX_FILE_DIRECTORY_LEN], fp;
	formatex(sFile, charsmax(sFile), "%s/%s", CONFIGS_DIR, file);

	fp = fopen(sFile, "at+");

	if(!fp)
	{
		set_fail_state("Error opening the file!");
		return 0;
	}

	static sBuffer[256], szCata[64], szKey[64], key_found, cata_found, line, bool:keyvalue_update;
	key_found = INVALID_KEY;
	cata_found = INVALID_CATEGORY;
	line = INVALID_LINE;
	keyvalue_update = false;

	fseek(fp, 0, SEEK_SET);
	while(!feof(fp))
	{
		line ++;

		fgets(fp, sBuffer, charsmax(sBuffer));
		trim(sBuffer);

		if(!sBuffer[0] || strlen(sBuffer) <= 3 || sBuffer[0] == ';' || (sBuffer[0] == '/' && sBuffer[1] == '/'))
			continue;

		if(sBuffer[0] == '[' && contain(sBuffer[1], "]") > -1)
		{
			if(cata_found != INVALID_CATEGORY)
			{
				break;
			}

			copyc(szCata, charsmax(szCata), sBuffer[1], ']');

			if(equali(szCata, cata))
			{
				cata_found = line;
			}

			continue;
		}

		if(cata_found != INVALID_CATEGORY && key_found == INVALID_KEY)
		{
			strtok(sBuffer, szKey, charsmax(szKey), sBuffer, charsmax(sBuffer), '=');
			trim(szKey);
			trim(sBuffer);
			remove_quotes(szKey);
			remove_quotes(sBuffer);

			if(equali(szKey, key))
			{
				key_found = line;

				if(sBuffer[0] == EOS)
				{
					if(value[0] != EOS)
					{
						keyvalue_update = true;
						break;
					}

					fclose(fp);
					return FILE_KEYVALUE_EMPTY;
				}

				copy(value, len, sBuffer);

				fclose(fp);
				return FILE_KEYVALUE_BUFFERED;
			}
		}
	}

	if(cata_found == INVALID_CATEGORY)
	{
		formatex(szCata, charsmax(szCata), "^n[%s]^n", cata);
		fputs(fp, szCata);

		formatex(sBuffer, charsmax(sBuffer), "%s = ^"%s^" ^n", key, value)
		fputs(fp, sBuffer);
	}

	else if((cata_found != INVALID_CATEGORY && key_found == INVALID_KEY) || keyvalue_update == true)
	{
		static sFile2[128], fp2;
		formatex(sFile2, charsmax(sFile2), "%s/2_%s", CONFIGS_DIR, file);

		fp2 = fopen(sFile2, "at+");

		if(!fp2)
		{
			set_fail_state("Error opening the file!");
			return 0;
		}

		line = INVALID_LINE;
		fseek(fp, 0, SEEK_SET);
		while( !feof(fp) )
		{
			line ++;
			if(fgets(fp, sBuffer, charsmax(sBuffer)) == 0) continue;

			if(keyvalue_update == true)
			{
				if(key_found == line)
				{
					formatex(sBuffer, charsmax(sBuffer), "%s = ^"%s^" ^n", key, value)
				}
			}
			else if(cata_found == line)
			{
				formatex(szCata, charsmax(szCata), "[%s]^n", cata);
				fputs(fp2, szCata);
				formatex(sBuffer, charsmax(sBuffer), "%s = ^"%s^"^n", key, value)
			}

			fputs(fp2, sBuffer);
		}
		fclose(fp);
		fclose(fp2);

		delete_file(sFile);
		if(!rename_file(sFile2, sFile,1))
		{
			delete_file(sFile2);
			return FILE_ERROR;
		}

		return keyvalue_update ? FILE_KEYVALUE_UPDATED : FILE_KEYVALUE_CREATED;
	}

	fclose(fp);
	return FILE_CATEGORY_CREATED;
}
